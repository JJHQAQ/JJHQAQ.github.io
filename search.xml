<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>主席树练习题1(远古补题)</title>
    <url>/2020/07/06/%E4%B8%BB%E5%B8%AD%E6%A0%91%E7%BB%83%E4%B9%A0%E9%A2%981-%E8%BF%9C%E5%8F%A4%E8%A1%A5%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>害，懒癌发作了就是没办法，一个月前做的题，半个月才补，然后今天回来做的总结。。。。离谱<br><a id="more"></a></p>
<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给一棵树，树有边权，多次询问，每组询问给定X(起点)，Y(终点)，C,K.<br>求最小的P,使得路径上小于C-P的边和大于C+P的边的数量小于等于K.<br><a href="https://ac.nowcoder.com/acm/contest/5891/H" target="_blank" rel="noopener">原题链接</a></p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>首先可以做一个主席树，可以做到logn得查询路径上比某个值小的边权的个数，然后就对P做个二分答案，就可以过了。<br>(这题卡快读QAQ)</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch == <span class="string">'-'</span>)w = <span class="number">-1</span>; ch = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[maxn&lt;&lt;<span class="number">5</span>],rs[maxn&lt;&lt;<span class="number">5</span>],val[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> N,Q;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;E[maxn*<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt2=<span class="number">0</span>,head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt2].next = head[x];</span><br><span class="line">    E[cnt2].to = y;</span><br><span class="line">    E[cnt2].w = w;</span><br><span class="line">    head[x] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = lower_bound(A+<span class="number">1</span>,A+len+<span class="number">1</span>,k)-A;</span><br><span class="line">    <span class="keyword">if</span> (A[id]!=k) id--;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_tree</span><span class="params">(<span class="keyword">int</span> &amp;dir,<span class="keyword">int</span> root,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dir = ++cnt;</span><br><span class="line">    ls[dir] = ls[root];</span><br><span class="line">    rs[dir] = rs[root];</span><br><span class="line">    val[dir] = val[root]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=mid) add_tree(ls[dir],ls[root],l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> add_tree(rs[dir],rs[root],mid+<span class="number">1</span>,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree_build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x!=<span class="number">1</span>) add_tree(rt[x],rt[fa],<span class="number">1</span>,len,getid(w));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i].to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        Tree_build(E[i].to,x,E[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">16</span>],dep[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> bin[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pow2 = <span class="number">16</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    bin[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=pow2<span class="number">-1</span>;i++)bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dep[root] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=pow2<span class="number">-1</span>;i++)f[root][i] = <span class="number">0</span>;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pow2; i++)<span class="keyword">if</span> (bin[i] &lt;= dep[u]) &#123;</span><br><span class="line">            f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i =E[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[i].to; <span class="keyword">if</span> (v == f[u][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;  f[v][<span class="number">0</span>] = u; q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pow2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dep[x]-dep[y])&amp;bin[i])</span><br><span class="line">        x = f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x][i]!=f[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x = f[x][i];</span><br><span class="line">            y = f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> Lca,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> val[x]+val[y]<span class="number">-2</span>*val[Lca];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=mid) <span class="keyword">return</span> query(ls[x],ls[y],ls[Lca],l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> val[ls[x]]+val[ls[y]]-val[ls[Lca]]*<span class="number">2</span>+query(rs[x],rs[y],rs[Lca],mid+<span class="number">1</span>,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">k_num</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> uvlca = lca(u,v);</span><br><span class="line">    <span class="keyword">return</span> query(rt[u],rt[v],rt[uvlca],<span class="number">1</span>,len,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">l_r_num</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">long</span> <span class="keyword">long</span> l,<span class="keyword">long</span> <span class="keyword">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> down = getid(l);</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=A[down]) down--;</span><br><span class="line">    down = <span class="built_in">max</span>(<span class="number">0</span>,down);</span><br><span class="line">    <span class="keyword">int</span> up = getid(r);</span><br><span class="line">    <span class="keyword">if</span> (down) down = k_num(u,v,down);</span><br><span class="line">    <span class="keyword">if</span> (up) up = k_num(u,v,up);</span><br><span class="line">    <span class="keyword">return</span> up-down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> X[maxn],Y[maxn],C[maxn],K[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);</span><br><span class="line">    N=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;i++) val[i]=ls[i]=rs[i] = <span class="number">0</span>;</span><br><span class="line">        cnt2 = cnt = <span class="number">0</span>;</span><br><span class="line">        N = <span class="built_in">read</span>();</span><br><span class="line">        Q = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            u = <span class="built_in">read</span>();</span><br><span class="line">            v = <span class="built_in">read</span>();</span><br><span class="line">            w = <span class="built_in">read</span>();</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            add(v,u,w);</span><br><span class="line">            A[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++) &#123;</span><br><span class="line">            X[i] = <span class="built_in">read</span>();</span><br><span class="line">            Y[i] = <span class="built_in">read</span>();</span><br><span class="line">            C[i] = <span class="built_in">read</span>();</span><br><span class="line">            K[i] = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sort(A+<span class="number">1</span>,A+N);</span><br><span class="line">        len = unique(A+<span class="number">1</span>,A+N)-A<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        bfs(<span class="number">1</span>);</span><br><span class="line">        Tree_build(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> all = k_num(X[i],Y[i],len);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>,r = <span class="number">2e9</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (all-(l_r_num(X[i],Y[i],C[i]-mid,C[i]+mid))&lt;=K[i])&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>随缘补题</tag>
      </tags>
  </entry>
  <entry>
    <title>BJTU第14届校赛题解</title>
    <url>/2020/06/02/BJTU%E7%AC%AC14%E5%B1%8A%E6%A0%A1%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>校赛的难度梯度是真的顶不住，不到两个小时就写完了六道水题，结果后边的就搞不动了，最后也就多搞了两道，剩下的题刚不动就直接挂机了QAQAQAQ。(果然还是我太菜了。o(╥﹏╥)o)</p>
<p>题目大意写的可能十分大意，原题可以在这找到<br><a href="https://citel.bjtu.edu.cn/acm/problem" target="_blank" rel="noopener">BJTU校OJ</a><br><a id="more"></a></p>
<h1 id="气球你不要掉下来辣"><a href="#气球你不要掉下来辣" class="headerlink" title="气球你不要掉下来辣"></a>气球你不要掉下来辣</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求一个字符串指定的字符是否严格超过一半。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>扫一遍记个数就成。<del>手速题</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c = s[i];</span><br><span class="line">		<span class="keyword">if</span> (c==<span class="string">'W'</span>||c==<span class="string">'T'</span>||c==<span class="string">'Y'</span>||c==<span class="string">'U'</span>||c==<span class="string">'I'</span>||c==<span class="string">'O'</span>||c==<span class="string">'A'</span>||c==<span class="string">'H'</span>||c==<span class="string">'X'</span>||c==<span class="string">'V'</span>||c==<span class="string">'M'</span>)</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num&gt;len/<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="学到十一点才是真学霸"><a href="#学到十一点才是真学霸" class="headerlink" title="学到十一点才是真学霸"></a>学到十一点才是真学霸</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个楼层的开灯情况，问有多少个教室开着灯。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>模拟即可</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">300</span>][<span class="number">210</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k[i];j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>,tmp;t&lt;=f[i][j];t++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">                <span class="keyword">if</span> (tmp) flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="憨中憨的幽兰拿铁"><a href="#憨中憨的幽兰拿铁" class="headerlink" title="憨中憨的幽兰拿铁"></a>憨中憨的幽兰拿铁</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>问用给定的固定材料和万能材料能制作几杯幽兰拿铁</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>显然二分答案可做，二分能制作的拿铁数，每次O(N)检查是否可做。</p>
<p>但是数据范围还留了其他的解法，主要是因为m比较小，不过没有二分好写。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x,y,z;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100100</span>],b[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]*x&gt;b[i])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-=a[i]*x-b[i];</span><br><span class="line">            <span class="keyword">if</span> (tmp&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">// long long maxx = 1e8+10,minn = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">0</span>,r=<span class="number">2e8</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Battle"><a href="#Battle" class="headerlink" title="Battle"></a>Battle</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>求最大生成树。</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>裸题。。。。我写的Kruskal</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span>  <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f;</span><br><span class="line">&#125;E[<span class="number">2000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct Edge a,struct Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.f&gt;b.f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        E[++cnt].x = i;</span><br><span class="line">        E[cnt].y = j;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;E[cnt].f);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(E+<span class="number">1</span>,E+cnt+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = <span class="built_in">find</span>(E[i].x);</span><br><span class="line">        <span class="keyword">int</span> yy = <span class="built_in">find</span>(E[i].y);</span><br><span class="line">        <span class="keyword">if</span> (xx==yy) <span class="keyword">continue</span>;</span><br><span class="line">        fa[xx] = yy;</span><br><span class="line">        ans+=E[i].f;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (num==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="铁憨憨骑士团的圣诞礼物"><a href="#铁憨憨骑士团的圣诞礼物" class="headerlink" title="铁憨憨骑士团的圣诞礼物"></a>铁憨憨骑士团的圣诞礼物</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一棵树，从1号点出发，最少需要走多少路才能遍历所有节点。</p>
<h2 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h2><p>答案显然是 （所有路径距离和）/*2-（从根节点出发的最远路径距离）</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">&#125;E[<span class="number">700010</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">400000</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">long</span> <span class="keyword">long</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt].next = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    E[cnt].w = w;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">400000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to,x);</span><br><span class="line">        dp[x] = <span class="built_in">max</span>(dp[x],dp[to]+E[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        add(a,b,c);</span><br><span class="line">        add(b,a,c);</span><br><span class="line">        ans+=c*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ans-=dp[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="jerry99的数列"><a href="#jerry99的数列" class="headerlink" title="jerry99的数列"></a>jerry99的数列</h1><h1 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h1><p>ai 代表(离根下i最近的整数）<br>求1-i的a数列连乘值。</p>
<h2 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h2><p>数列的规律很明显，写个大概十几项就看出来了。直接用类似整除分块的方法，配合快速幂加速即可。</p>
<h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tmp = x;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> as = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) as = as*tmp%mod;</span><br><span class="line">		tmp = tmp*tmp%mod;</span><br><span class="line">		y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (;i*i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = ans*mi(i<span class="number">-1</span>,i<span class="number">-1</span>)%mod;</span><br><span class="line">			ans = ans*mi(i,i)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		i--;</span><br><span class="line">		n-=i*i;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span> (n&gt;=i<span class="number">-1</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			ans = ans*mi(i<span class="number">-1</span>,i<span class="number">-1</span>)%mod;</span><br><span class="line">			n-=i<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span> (n) ans = ans*mi(i,n)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ans = ans*mi(i<span class="number">-1</span>,n)%mod;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="灵能矩阵"><a href="#灵能矩阵" class="headerlink" title="灵能矩阵"></a>灵能矩阵</h1><h2 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h2><p>求数字矩阵，从左上角到右下角的路径的按位与操作的最大值。</p>
<h2 id="解决-6"><a href="#解决-6" class="headerlink" title="解决"></a>解决</h2><p>一共就30个数位，从高位到低位一位一位判断能否在保证高位通行的情况下通行即可。(自认为写的挺好理解的QAQ)</p>
<h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">600</span>][<span class="number">600</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">600</span>][<span class="number">600</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (((a[i][j]&amp;k)==k) &amp;&amp; (a[i][j]&amp;(<span class="number">1l</span>l&lt;&lt;x))!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]|dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"aaa.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i][j]);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">29</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        bfs(i);</span><br><span class="line">        <span class="keyword">if</span> (dp[n][m])&#123;</span><br><span class="line">            k|=<span class="number">1l</span>l&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="bugaosuni59的SSR"><a href="#bugaosuni59的SSR" class="headerlink" title="bugaosuni59的SSR"></a>bugaosuni59的SSR</h1><h2 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h2><p>n次独立重复实验，问至少连续中K次的概率是多少。</p>
<h2 id="解决-7"><a href="#解决-7" class="headerlink" title="解决"></a>解决</h2><p>我。。。。。对不起我炸胡的，感觉像是刚好凑出了答案。。。。。就贴一下代码仅做参考吧。</p>
<h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">double</span> sum[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">double</span> mi[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">   <span class="keyword">int</span> T;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">   <span class="keyword">while</span>(T--)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N,K;</span><br><span class="line">        <span class="keyword">double</span> P;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;K);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;P);</span><br><span class="line">        <span class="keyword">double</span> tmp =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++) tmp*=P;</span><br><span class="line">        mi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K+<span class="number">1</span>;i++) mi[i] = mi[i<span class="number">-1</span>]*P;</span><br><span class="line">        <span class="keyword">double</span> s=<span class="number">0</span>,num =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N-K+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> tm=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i-K&gt;=<span class="number">0</span>)tm = sum[i-K];</span><br><span class="line">            s*=P;</span><br><span class="line">            <span class="keyword">if</span> (num==K<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s-=ans[i-K];</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            tm += s;</span><br><span class="line">            tm = <span class="number">1.0</span>-tm;</span><br><span class="line">            ans[i] = tmp*tm;</span><br><span class="line">            s+=tm;</span><br><span class="line">            num++;   </span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>]+ans[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,sum[N-K+<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="qwq-vs-quq"><a href="#qwq-vs-quq" class="headerlink" title="qwq vs quq"></a>qwq vs quq</h1><p>补不动了。。。主要当时讲题的时候也没注意听。。听那几个人讲，好像意思是用期望的一种啥操作，然后转换成矩阵相乘，然后结果就是算矩阵区间积，用线段树什么的维护就行。</p>
<h1 id="RayTracing"><a href="#RayTracing" class="headerlink" title="RayTracing"></a>RayTracing</h1><p>计算几何。。。。告辞QAQ!</p>
<h1 id="大膜法师HYX的奇妙冒险"><a href="#大膜法师HYX的奇妙冒险" class="headerlink" title="大膜法师HYX的奇妙冒险"></a>大膜法师HYX的奇妙冒险</h1><p>分两个问题，第一个是问整个图是否连通，枚举去掉的障碍物的位置，暴算即可。第二个是问方法数，用状压dp做的。。。虽然我其实不是很清楚具体怎么转移的。回头看看金老师的std吧，咱的确做不动QAQ.枯了</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>校赛结束第二天给自己儿童节放假，啥都没干23333，果然颓废才是人间真谛。QAQAQAQAQAQ</p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>BJTU</tag>
      </tags>
  </entry>
  <entry>
    <title>BJTU校赛热身赛题解(部分)</title>
    <url>/2020/05/27/BJTU%E6%A0%A1%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B%E9%A2%98%E8%A7%A3-%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>其实并没有做完，实在是有点颓。。。。所以只做了部分题的。如果没做的题就不贴代码了。。。。题解可能有些粗略，如果有任何疑问欢迎联系我    <del>如果有人看的话QAQ</del>。<br><a id="more"></a></p>
<h1 id="A-sqy-的锡纸烫"><a href="#A-sqy-的锡纸烫" class="headerlink" title="A sqy 的锡纸烫"></a>A sqy 的锡纸烫</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个时间轴(数轴)，有n个事件，每个事件在x时间发生，收到y元，之后的y天，每天会消耗1元，问所有的时间中，哪一天你获得的钱数最大。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>因为时间轴的长度很短，所以可以直接开个1e6的数组，对于每个事件给对应时间打一个标记，价值加y，再维护一个<strong>差分数组</strong>（一种区间修改很快的数据结构），给之后的y天的受益都-1,然后O(n)扫一遍统计最大值即可。</p>
<p>Ps:如果用sort排序事件，然后模拟的方法虽然理论上也可行，但是会超时。。。。虽然我也觉得挺迷的。。。。QAQ</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">1000010</span>],b[<span class="number">1000100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000010</span>;i++) a[i] = b[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>,x,y;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;x,&amp;y);</span><br><span class="line">		a[x] += y;</span><br><span class="line">		b[x+<span class="number">1</span>]--;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> r = <span class="built_in">min</span>((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1000010</span>,x+y+<span class="number">1</span>);</span><br><span class="line">		b[r]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> cha = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cha+=b[i];</span><br><span class="line">		tmp+=a[i];</span><br><span class="line">		tmp+=cha;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans,tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-hwf-吃烤翅"><a href="#B-hwf-吃烤翅" class="headerlink" title="B hwf 吃烤翅"></a>B hwf 吃烤翅</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>一周中的每一天都有一个特定的概率p,表示这一天吃上烤翅的几率，然后第一天是周一，问期望第几天能吃上烤翅。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>普通的概率题，坑点是，不只有7天，而是无数天，而无数天每天的概率都因为是星期几而确定的。所以不停地计算每天能吃上烤翅的概率，然后算个几万天，基本就符合精度了。</p>
<p>对于每天的期望，假设是第t天，那么期望就是，t*(前t-1都吃不上烤翅的概率)*第t天吃上烤翅的概率。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> q[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">1000100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;q[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++) q[i]/=<span class="number">100.0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> ans =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=dp[i<span class="number">-1</span>]*q[(i<span class="number">-1</span>)%<span class="number">7</span>+<span class="number">1</span>]*(<span class="keyword">double</span>)i;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>]*(<span class="number">1</span>-q[(i<span class="number">-1</span>)%<span class="number">7</span>+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-膜法师-lanpang-的树学期望"><a href="#C-膜法师-lanpang-的树学期望" class="headerlink" title="C 膜法师 lanpang 的树学期望"></a>C 膜法师 lanpang 的树学期望</h1><h2 id="红胖老师的题属实惹不起，我队友说就是个递推数学题。。。我推了半天也没整明白。。。咕了咕了"><a href="#红胖老师的题属实惹不起，我队友说就是个递推数学题。。。我推了半天也没整明白。。。咕了咕了" class="headerlink" title="红胖老师的题属实惹不起，我队友说就是个递推数学题。。。我推了半天也没整明白。。。咕了咕了"></a>红胖老师的题属实惹不起，我队友说就是个递推数学题。。。我推了半天也没整明白。。。咕了咕了</h2><p>天晴了雨停了，我觉得我又行了。。。。。一开始是问张大佬怎么做的，然后这人跟我说用<strong>oeis</strong>炸胡的。。。。。我当时就 <strong>!!!∑(ﾟДﾟノ)ノ</strong>。</p>
<p>然后又问了章总，章总就给了个递推式，我愣是没看懂。。。。然后后来发给张大佬，张大佬给讲的。</p>
<p>总之我好像会了。</p>
<p>递推式是：<br>a[1] = 1;<br>a[n] = 1+2*n+a[n-1]+2*a[n-1]/n;</p>
<p>a[n]的意思是n个点组成树时，每个点与其他点的期望距离。</p>
<p>最后对于每个n的答案就是，a[n]/(n*n)。</p>
<h1 id="D-摘果子"><a href="#D-摘果子" class="headerlink" title="D 摘果子"></a>D 摘果子</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>这么短的题面还用讲吗。。。QAQ</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>贪心，最后肯定是有一条链只需要经过一次，而其他的与该链相连的部分都是要走一个来回的，所以我们让这条链尽量长，也就是直径。设直径长度为l，那么最终答案就是l+max(0,k-l)*2</p>
<p>其实就是求<strong>树的直径</strong>，标准算法是两边dfs，不是很难。。。。所以懒得写了。。。</p>
<h1 id="E-成为膜法师吧！"><a href="#E-成为膜法师吧！" class="headerlink" title="E 成为膜法师吧！"></a>E 成为膜法师吧！</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一棵树，树的每个节点有一种颜色。然后多组询问，每次问两点之间的路径上，连续色块的个数。</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>这样想，从当前节点往父亲方向跳一下，如果父亲的颜色与当前节点不一样，答案就加1，然后维护一个跳颜色倍增数组，将两点都跳到<strong>lca</strong>(最近公共祖先)处即可。</p>
<p>关键就是要预处理出两个倍增数组，然后在求lca的过程中计算答案就好了。注意第一个节点本身也有1的答案贡献。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;E[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	E[++cnt].nxt = head[x];</span><br><span class="line">	E[cnt].to = y;</span><br><span class="line">	head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> col[maxn];</span><br><span class="line"><span class="keyword">int</span> dep[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn][<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> colnum[maxn][<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fa[x][<span class="number">0</span>] = f;</span><br><span class="line">	<span class="keyword">if</span> (col[x]!=col[f]&amp;&amp;f!=<span class="number">0</span>)</span><br><span class="line">	colnum[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	dep[x] = dep[f]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to = E[i].to;</span><br><span class="line">		<span class="keyword">if</span> (to==f) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(to,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[fa[x][i]]&gt;=dep[y])</span><br><span class="line">		&#123;			</span><br><span class="line">			ans+=colnum[x][i];</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span> (x==y) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fa[x][i]!=fa[y][i])</span><br><span class="line">		&#123;</span><br><span class="line">			ans += colnum[x][i]+colnum[y][i];</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">			y = fa[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans+colnum[x][<span class="number">0</span>]+colnum[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	col[<span class="number">0</span>] = <span class="number">-100</span>;</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) head[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) colnum[i][<span class="number">0</span>] = fa[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">			add(x,y);</span><br><span class="line">			add(y,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;col[i]);</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			fa[j][i] = fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				colnum[j][i] = colnum[j][i<span class="number">-1</span>]+colnum[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">while</span>(q--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x,y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lca(x,y));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-jerry99-的序列"><a href="#F-jerry99-的序列" class="headerlink" title="F jerry99 的序列"></a>F jerry99 的序列</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>额。。。。一看就明白了</p>
<h2 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h2><p>把N分解质因数，对于所有的质因数都操作如下，对于质因数q,枚举q的倍数，计算他们的质因数q的方次，累加起来，累加的方次大于等于N中q的方次时停止，该数就是可能的整数分界点。记录最大的分界点，从而计算出答案。</p>
<p>代码也没写。。。。<del>因为去年暑训的时候写过这题</del><br>wtclQAQ….</p>
<h1 id="G-大膜法师-WZH-的膜典十字"><a href="#G-大膜法师-WZH-的膜典十字" class="headerlink" title="G 大膜法师 WZH 的膜典十字"></a>G 大膜法师 WZH 的膜典十字</h1><p>阿。。。这题我也没做呢，不过听说是用字典树维护一下就行。。。。。先咕了咕了</p>
<h1 id="大膜法师-HWF-的并发吟唱"><a href="#大膜法师-HWF-的并发吟唱" class="headerlink" title="大膜法师 HWF 的并发吟唱"></a>大膜法师 HWF 的并发吟唱</h1><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个矩阵，每个矩阵格子有一个正整数，代表这个格子里的魔法数。每次询问一个子矩阵，然后求这个矩阵里的“咏唱魔法的方法数”？</p>
<h2 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h2><p>对于给定的一个矩阵，如何计算它的方法数呢？可以想到如果不加限制就是是矩阵中所有魔法的全排列。然后因为对于每一个格子咏唱的顺序固定（高中排列组合的题型），所以再除以每一个格子阶乘的积，就是答案。</p>
<p>要完成这个需要维护一个二维前缀和，一个二维前缀阶乘 积，还有一些求逆元的知识。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> jie[<span class="number">8000100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum1[<span class="number">301</span>][<span class="number">301</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum2[<span class="number">301</span>][<span class="number">301</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">300</span>][<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = mod<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tt = x;</span><br><span class="line">    <span class="keyword">while</span>(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp&amp;<span class="number">1</span>) ans=ans*tt%mod;</span><br><span class="line">        tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        tt = tt*tt%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    jie[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=<span class="number">8000000</span>;i++) jie[i] = jie[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">300</span>;i++) sum2[<span class="number">0</span>][i]=sum2[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,m,q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            sum1[i][j] = sum1[i<span class="number">-1</span>][j]+sum1[i][j<span class="number">-1</span>]+a[i][j]-sum1[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> S = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                &#123;   </span><br><span class="line">                    S = S*jie[a[i][j]]%mod;</span><br><span class="line">                    sum2[i][j] = sum2[i<span class="number">-1</span>][j]*S%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp1 = jie[sum1[x2][y2]-sum1[x1<span class="number">-1</span>][y2]-sum1[x2][y1<span class="number">-1</span>]+sum1[x1<span class="number">-1</span>][y1<span class="number">-1</span>]];</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp2 = sum2[x2][y2]*sum2[x1<span class="number">-1</span>][y1<span class="number">-1</span>]%mod;</span><br><span class="line">            tmp1=tmp1*sum2[x1<span class="number">-1</span>][y2]%mod*sum2[x2][y1<span class="number">-1</span>]%mod;</span><br><span class="line">            tmp2 = inv(tmp2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tmp1*tmp2%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="I-OverCooked"><a href="#I-OverCooked" class="headerlink" title="I OverCooked!"></a>I OverCooked!</h1><p>我也没做。。。不过算签到题。暴力模拟去匹配就好。</p>
<h1 id="大膜法师-HYX-的与或膜法"><a href="#大膜法师-HYX-的与或膜法" class="headerlink" title="大膜法师 HYX 的与或膜法"></a>大膜法师 HYX 的与或膜法</h1><h2 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h2><p>将一个数字集合，分成两个集合，对于每个集合，将里面的数字全部按位与起来，两个集合的与结果或起来，得到答案。问如何分配集合，可以使得答案最大？</p>
<h2 id="解决-6"><a href="#解决-6" class="headerlink" title="解决"></a>解决</h2><p>因为数据范围比较小，所以暴力枚举就可以。</p>
<p>就是说，与操作不会产生更大的数，所以对于某个集合，进行与操作的可能的得数是小于1e4的。我们直接枚举一个集合的结果，如果一个数与操作进来之后结果不变，就贪心的将这个数加入到该集合中，否则加入另一个集合。（感性理解一下，这么做是对的QAQ）</p>
<p>最后输出最高答案即可。</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10010</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp1 = (<span class="number">1</span>&lt;&lt;<span class="number">17</span>)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp2 = tmp1;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> ((a[j]&amp;i)==i) tmp1&amp;=a[j];</span><br><span class="line">            <span class="keyword">else</span> tmp2&amp;=a[j];</span><br><span class="line">            <span class="comment">// cout&lt;&lt;tmp1&lt;&lt;" "&lt;&lt;tmp2&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span> (tmp1!=(<span class="number">1</span>&lt;&lt;<span class="number">17</span>)<span class="number">-1</span>&amp;&amp;tmp2!=(<span class="number">1</span>&lt;&lt;<span class="number">17</span>)<span class="number">-1</span>) ans = <span class="built_in">max</span>(ans,tmp1|tmp2);</span><br><span class="line">            <span class="keyword">if</span> (tmp2==(<span class="number">1</span>&lt;&lt;<span class="number">17</span>)<span class="number">-1</span>) ans = <span class="built_in">max</span>(ans,tmp1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="K-zxt-与他的红茶"><a href="#K-zxt-与他的红茶" class="headerlink" title="K zxt 与他的红茶"></a>K zxt 与他的红茶</h1><p>签到题。。。我也没做来着QAQ.<br>应该会用getchar就能过吧，大概。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>校赛又要被各路大佬毒打了。。。。害怕QAQAQAQAQAQ</p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>BJTU校赛</tag>
      </tags>
  </entry>
  <entry>
    <title>python模拟三体运动(三维已补)</title>
    <url>/2020/05/22/python%E6%A8%A1%E6%8B%9F%E4%B8%89%E4%BD%93%E8%BF%90%E5%8A%A8-%E4%BA%8C%E7%BB%B4/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我们大物老师好像挺牛的，老感觉他虽然是个物理老师，但是还会一些乱七八糟的编程技术。但是没想到阿，没想到，他竟然以为我们也会些乱起八遭的技术….这谁会阿。。。枯了o(╥﹏╥)o<br><img src="/2020/05/22/python%E6%A8%A1%E6%8B%9F%E4%B8%89%E4%BD%93%E8%BF%90%E5%8A%A8-%E4%BA%8C%E7%BB%B4/P1.png" alt="大物作业"><br><a id="more"></a></p>
<h1 id="使用技术"><a href="#使用技术" class="headerlink" title="使用技术"></a>使用技术</h1><p>使用python的numpy模块，以及配套的matplotlib,其实只是个简单的数学画图工具，但是用不断刷新的办法可以类似达到动画的效果。</p>
<h2 id="几个用到的函数"><a href="#几个用到的函数" class="headerlink" title="几个用到的函数"></a>几个用到的函数</h2><ul>
<li>ion()</li>
</ul>
<p>是matplotlib里的函数，意思是开启交互模式。</p>
<ul>
<li>clf()</li>
</ul>
<p>清空屏幕</p>
<ul>
<li>plot()</li>
</ul>
<p>画图函数，里面的参数很多，可以用它来画自定义的曲线或者点，可以设置大小，颜色等。</p>
<ul>
<li>axis()</li>
</ul>
<p>设置观测轴范围</p>
<ul>
<li>show()</li>
</ul>
<p>打印图形</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>其实没啥技术含量，就是通过不断的计算每一个小时间点的加速度，从而得到球体下一个时刻的位置，然后不断打印。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    a_x = <span class="number">0</span></span><br><span class="line">    a_y = <span class="number">0</span></span><br><span class="line">    v_x = <span class="number">0</span></span><br><span class="line">    v_y = <span class="number">0</span></span><br><span class="line">    x_all = []</span><br><span class="line">    y_all = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x,y,v_x,v_y,m)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.v_x = v_x</span><br><span class="line">        self.v_y = v_y</span><br><span class="line">        self.m = m</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self,t)</span>:</span></span><br><span class="line">        self.v_x = self.v_x+self.a_x*t</span><br><span class="line">        self.v_y = self.v_y+self.a_y*t</span><br><span class="line">        self.x = self.x+self.v_x*t</span><br><span class="line">        self.y = self.y+self.v_y*t</span><br><span class="line">        self.x_all = np.append(self.x_all,self.x)</span><br><span class="line">        self.y_all = np.append(self.y_all,self.y)</span><br><span class="line">A = Node(<span class="number">300</span>,<span class="number">60</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">15</span>)</span><br><span class="line">B = Node(<span class="number">-120</span>,<span class="number">-200</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">12</span>)</span><br><span class="line">C = Node(<span class="number">-100</span>,<span class="number">150</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">G = <span class="number">100</span></span><br><span class="line">t = <span class="number">0.1</span></span><br><span class="line">plt.ion()</span><br><span class="line"><span class="keyword">for</span> tim <span class="keyword">in</span> range(<span class="number">2500</span>):</span><br><span class="line">    r12 = np.sqrt((A.x-B.x)**<span class="number">2</span>+(A.y-B.y)**<span class="number">2</span>)</span><br><span class="line">    r13 = np.sqrt((A.x-C.x)**<span class="number">2</span>+(A.y-C.y)**<span class="number">2</span>)</span><br><span class="line">    r23 = np.sqrt((C.x-B.x)**<span class="number">2</span>+(C.y-B.y)**<span class="number">2</span>)</span><br><span class="line">    r12 = max(r12,<span class="number">10</span>)</span><br><span class="line">    r23 = max(r23,<span class="number">10</span>)</span><br><span class="line">    r13 = max(r13,<span class="number">10</span>)</span><br><span class="line">    <span class="comment">#物体A</span></span><br><span class="line">    a12 = G*B.m/(r12**<span class="number">2</span>)</span><br><span class="line">    a13 = G*C.m/(r13**<span class="number">2</span>)</span><br><span class="line">    A.a_x = a12*((B.x-A.x)/r12)+a13*((C.x-A.x)/r13)</span><br><span class="line">    A.a_y = a12*((B.y-A.y)/r12)+a13*((C.y-A.y)/r13)</span><br><span class="line">    A.next(t)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#物体B</span></span><br><span class="line">    a21 = G*A.m/(r12**<span class="number">2</span>)</span><br><span class="line">    a23 = G*C.m/(r23**<span class="number">2</span>)</span><br><span class="line">    B.a_x = a21*(A.x-B.x)/r12+a23*(C.x-B.x)/r23</span><br><span class="line">    B.a_y = a21*(A.y-B.y)/r12+a23*(C.y-B.y)/r23</span><br><span class="line">    B.next(t)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#物体C</span></span><br><span class="line">    a31 = G*A.m/(r13**<span class="number">2</span>)</span><br><span class="line">    a32 = G*B.m/(r23**<span class="number">2</span>)</span><br><span class="line">    C.a_x = a31*(A.x-C.x)/r13+a32*(B.x-C.x)/r23</span><br><span class="line">    C.a_y = a31*(A.y-C.y)/r13+a32*(B.y-C.y)/r23</span><br><span class="line">    C.next(t)</span><br><span class="line"></span><br><span class="line">    centerx = (A.x+B.x+C.x)/<span class="number">3</span></span><br><span class="line">    centery = (A.y+B.y+C.y)/<span class="number">3</span></span><br><span class="line">    obmax = max(r12,max(r23,r13))*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    plt.clf()</span><br><span class="line">    plt.plot(A.x,A.y,<span class="string">"og"</span>,markersize=A.m)</span><br><span class="line">    plt.plot(B.x,B.y,<span class="string">"or"</span>,markersize=B.m)</span><br><span class="line">    plt.plot(C.x,C.y,<span class="string">"ob"</span>,markersize=C.m)</span><br><span class="line">    plt.plot(A.x_all,A.y_all,<span class="string">"-g"</span>)</span><br><span class="line">    plt.plot(B.x_all,B.y_all,<span class="string">"-r"</span>)</span><br><span class="line">    plt.plot(C.x_all,C.y_all,<span class="string">"-b"</span>)</span><br><span class="line">    plt.axis([centerx-obmax,centerx+obmax,centery-obmax,centery+obmax])</span><br><span class="line">    plt.show() </span><br><span class="line">    plt.pause(<span class="number">0.0001</span>)</span><br></pre></td></tr></table></figure>
<h1 id="效果分析"><a href="#效果分析" class="headerlink" title="效果分析"></a>效果分析</h1><p>效果异常垃圾。。。基本运行一小会三体平衡就直接崩溃了，很容易变成一颗星球被甩，另外两颗星球私奔的情况。具体运行文件可以去我的github里找到。</p>
<h1 id="加强版"><a href="#加强版" class="headerlink" title="加强版"></a>加强版</h1><h2 id="为啥会有加强版"><a href="#为啥会有加强版" class="headerlink" title="为啥会有加强版"></a>为啥会有加强版</h2><p>QAQ好吧是我太菜了，我不知道这个模块还有三维画图模式，经舍友提醒就给搞了一个，其实跟原来的代码差不太多，只是换了几个函数，但是效果确实比之前的好很多(虽然还是分分钟结束的样子)。</p>
<h2 id="用到的函数"><a href="#用到的函数" class="headerlink" title="用到的函数"></a>用到的函数</h2><ul>
<li><p>模块 mpl-toolkits.mplot3d</p>
</li>
<li><p>axes(projection=’3d’) 设置三维坐标轴</p>
</li>
<li><p>scatter   </p>
</li>
</ul>
<p>画点的函数</p>
<ul>
<li>plot</li>
</ul>
<p>画轨迹的函数</p>
<ul>
<li>set_zlim3d()</li>
</ul>
<p>设定坐标轴的最大最小值</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span>  numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    a_x = <span class="number">0</span></span><br><span class="line">    a_y = <span class="number">0</span></span><br><span class="line">    a_z = <span class="number">0</span></span><br><span class="line">    v_x = <span class="number">0</span></span><br><span class="line">    v_y = <span class="number">0</span></span><br><span class="line">    v_z = <span class="number">0</span></span><br><span class="line">    x_all = []</span><br><span class="line">    y_all = []</span><br><span class="line">    z_all = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x,y,z,v_x,v_y,v_z,m)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.z = z</span><br><span class="line">        self.v_x = v_x</span><br><span class="line">        self.v_y = v_y</span><br><span class="line">        self.v_z = v_z</span><br><span class="line">        self.m = m</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self,t)</span>:</span></span><br><span class="line">        self.v_x = self.v_x+self.a_x*t</span><br><span class="line">        self.v_y = self.v_y+self.a_y*t</span><br><span class="line">        self.v_z = self.v_z+self.a_z*t</span><br><span class="line">        self.x = self.x+self.v_x*t</span><br><span class="line">        self.y = self.y+self.v_y*t</span><br><span class="line">        self.z = self.z+self.v_z*t</span><br><span class="line">        self.x_all = np.append(self.x_all,self.x)</span><br><span class="line">        self.y_all = np.append(self.y_all,self.y)</span><br><span class="line">        self.z_all = np.append(self.z_all,self.z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fig = plt.figure()</span></span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line">A = Node(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>)<span class="comment">#green</span></span><br><span class="line">B = Node(<span class="number">150</span>,<span class="number">150</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>)<span class="comment">#blue</span></span><br><span class="line">C = Node(<span class="number">75</span>,<span class="number">75</span>,<span class="number">75</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">5</span>)<span class="comment">#red</span></span><br><span class="line">G = <span class="number">50</span></span><br><span class="line">t = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    r12 = np.sqrt((A.x - B.x) ** <span class="number">2</span> + (A.y - B.y) ** <span class="number">2</span>+(A.z-B.z)**<span class="number">2</span>)</span><br><span class="line">    r13 = np.sqrt((A.x - C.x) ** <span class="number">2</span> + (A.y - C.y) ** <span class="number">2</span>+(A.z-C.z)**<span class="number">2</span>)</span><br><span class="line">    r23 = np.sqrt((C.x - B.x) ** <span class="number">2</span> + (C.y - B.y) ** <span class="number">2</span>+(C.z-B.z)**<span class="number">2</span>)</span><br><span class="line">    r12 = max(r12, <span class="number">5</span>)</span><br><span class="line">    r23 = max(r23, <span class="number">5</span>)</span><br><span class="line">    r13 = max(r13, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 物体A</span></span><br><span class="line"></span><br><span class="line">    a12 = G * B.m / (r12 ** <span class="number">2</span>)</span><br><span class="line">    a13 = G * C.m / (r13 ** <span class="number">2</span>)</span><br><span class="line">    A.a_x = a12 * ((B.x - A.x) / r12) + a13 * ((C.x - A.x) / r13)</span><br><span class="line">    A.a_y = a12 * ((B.y - A.y) / r12) + a13 * ((C.y - A.y) / r13)</span><br><span class="line">    A.a_z = a12 * ((B.z - A.z) / r12) + a13 * ((C.z - A.z) / r13)</span><br><span class="line">    A.next(t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 物体B</span></span><br><span class="line">    a21 = G * A.m / (r12 ** <span class="number">2</span>)</span><br><span class="line">    a23 = G * C.m / (r23 ** <span class="number">2</span>)</span><br><span class="line">    B.a_x = a21 * (A.x - B.x) / r12 + a23 * (C.x - B.x) / r23</span><br><span class="line">    B.a_y = a21 * (A.y - B.y) / r12 + a23 * (C.y - B.y) / r23</span><br><span class="line">    B.a_z = a21 * (A.z - B.z) / r12 + a23 * (C.z - B.z) / r23</span><br><span class="line">    B.next(t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 物体C</span></span><br><span class="line">    a31 = G * A.m / (r13 ** <span class="number">2</span>)</span><br><span class="line">    a32 = G * B.m / (r23 ** <span class="number">2</span>)</span><br><span class="line">    C.a_x = a31 * (A.x - C.x) / r13 + a32 * (B.x - C.x) / r23</span><br><span class="line">    C.a_y = a31 * (A.y - C.y) / r13 + a32 * (B.y - C.y) / r23</span><br><span class="line">    C.a_z = a31 * (A.z - C.z) / r13 + a32 * (B.z - C.z) / r23</span><br><span class="line">    C.next(t)</span><br><span class="line"></span><br><span class="line">    obmax = max(r12, max(r23, r13)) * <span class="number">1</span></span><br><span class="line">    centerx = (A.x + B.x + C.x) / <span class="number">3</span></span><br><span class="line">    centery = (A.y + B.y + C.y) / <span class="number">3</span></span><br><span class="line">    centerz = (A.z + B.z + C.z) / <span class="number">3</span></span><br><span class="line">    ax1 = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line">    plt.title(<span class="string">"JJH's three body simulation"</span>)</span><br><span class="line">    ax1.scatter(A.x,A.y,A.z,zdir=<span class="string">'z'</span>, s=A.m, c=<span class="string">'green'</span>)</span><br><span class="line">    ax1.scatter(B.x,B.y,B.z,zdir=<span class="string">'z'</span>, s=B.m, c=<span class="string">'blue'</span>)</span><br><span class="line">    ax1.scatter(C.x,C.y,C.z, zdir=<span class="string">'z'</span>, s=C.m, c=<span class="string">'red'</span>)</span><br><span class="line">    ax1.plot(A.x_all,A.y_all,A.z_all,<span class="string">"green"</span>)</span><br><span class="line">    ax1.plot(B.x_all,B.y_all,B.z_all, <span class="string">"blue"</span>)</span><br><span class="line">    ax1.plot(C.x_all, C.y_all, C.z_all, <span class="string">"red"</span>)</span><br><span class="line">    ax1.set_zlim3d(centerz-obmax,centerz+obmax)</span><br><span class="line">    ax1.set_xlim3d(centerx-obmax,centerx+obmax)</span><br><span class="line">    ax1.set_ylim3d(centery-obmax,centery+obmax)</span><br><span class="line">    plt.show()</span><br><span class="line">    plt.pause(<span class="number">0.000000005</span>)</span><br><span class="line">    plt.clf()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂学</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces round 622 Div2(补题)</title>
    <url>/2020/05/22/Codeforces-round-622-Div2-%E8%A1%A5%E9%A2%98/</url>
    <content><![CDATA[<p><strong>终于熬过了几场考试（虽然考的稀烂QAQ）,有了一点补题的想法</strong><br><a id="more"></a></p>
<h1 id="A-Fast-Food-Restaurant"><a href="#A-Fast-Food-Restaurant" class="headerlink" title="A.Fast Food Restaurant"></a>A.Fast Food Restaurant</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你三种菜，数量分别有a盘，b盘，c盘。要求将他们组合成不同的套餐，套餐的定义是，至少有一盘菜，每种菜至多一盘。问给出a,b,c,最多能组合出几种套餐。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>仔细想想，他顶多就7种，然后基本随便做就好了。dfs肯定是可以的，但是简单点写的话可以做一个贪心策略。优先凑出只要一盘的套餐，然后再凑只要两盘的套餐（从较多的菜开始凑），最后凑三盘都要的。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>],&amp;a[<span class="number">2</span>]);</span><br><span class="line">		sort(a,a+<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">2</span>]) &#123;ans++;a[<span class="number">2</span>]--;&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">1</span>]) &#123;ans++;a[<span class="number">1</span>]--;&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">0</span>]) &#123;ans++;a[<span class="number">0</span>]--;&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">2</span>] &amp;&amp; a[<span class="number">1</span>])&#123;ans++;a[<span class="number">2</span>]--;a[<span class="number">1</span>]--;&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">2</span>] &amp;&amp; a[<span class="number">0</span>])&#123;ans++;a[<span class="number">2</span>]--;a[<span class="number">0</span>]--;&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">1</span>] &amp;&amp; a[<span class="number">0</span>])&#123;ans++;a[<span class="number">1</span>]--;a[<span class="number">0</span>]--;&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &amp;&amp; a[<span class="number">2</span>]) &#123;ans++;&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Different-Rules"><a href="#B-Different-Rules" class="headerlink" title="B. Different Rules"></a>B. Different Rules</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>有1到n的两排数字，有n个人，每个人在两排数字中分别取一个，不能取之前的人取过的数字。然后每个人的得分就是他们所取的数字的和。<br>现在给数字n，和主角取到的两个数x,y。问至少有多少个小于等于他得分的人，至多有多少个小于等于他得分的人。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>就数学题，单纯de….</p>
<p>首先，讨论最小化得分少的人数。对于普通的两组连续整数[a,b]，他们首尾相加，一定可以得到一串大小为a+b的数，所以如果给定的数小于1+n的话，那就有办法可以让所有人都比他大，答案是1.但是如果给定的数大于等于n+1的话，那就必然有人的得分要小于等于主角，这时就贪心让最小的两个数给同一个人，这时剩下的数的平均取法得到的一串大小相等的数的值就可以+1，这样不断取最小的数，到达一个临界状态的时候，就是答案。这个过程其实不用一个一个处理，只是那么想而已，实际上就是个加减法运算。</p>
<p>最大化得分同理，取最大的两个数给同一人可以降低剩余人的总体平均数。</p>
<h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans1=<span class="number">1</span>,ans2=n;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=x+y) ans1+=x+y-n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;x+y) ans2-=n-x-y;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,<span class="built_in">min</span>(ans1,n<span class="number">-1</span>),<span class="built_in">max</span>(ans2,<span class="number">1l</span>l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C2-Skyscrapers-hard-version"><a href="#C2-Skyscrapers-hard-version" class="headerlink" title="C2. Skyscrapers (hard version)"></a>C2. Skyscrapers (hard version)</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一排数，每个数字给定一个能取得的最大值，选定每个数的值，保证不存在i &lt; j &lt; k,使得ai > aj > ak。要求使得所有数字的和最大。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>仔细一想，答案数列必然是一个单峰的状态。所以我们只需要知道峰值在什么位置时总体的值最大，就可以根据这个位置得到整个数列。做一个dp。</p>
<p>dpl[i]表示峰值位置为i时，i左侧所有数字取最大值的和，dpr[i]表示峰值位置为i时，i右侧所有数字取最大值的和。</p>
<p>l[i]表示位置i左侧最靠近位置i的比ai小的数的位置，r[i]位置i右侧最靠近位置i的比ai小的数的位置。</p>
<p>l,r数组可以用单调栈维护出来，dpl的转移为，dpl[i] = dp[l[i]] +(i-l[i])*ai,dpr同理。</p>
<p>最终位置t为峰值得到的整个数列的值就是dpl[i]+dpr[i]-ai。记录最大峰值位置，就可以得到最终的序列。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[maxn],l[maxn],r[maxn],dpl[maxn],dpr[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ansid[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn],top=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">	</span><br><span class="line">	st[++top] = <span class="number">1</span>;</span><br><span class="line">	l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(top&amp;&amp;a[st[top]]&gt;a[i]) top--;</span><br><span class="line">		l[i] = st[top];</span><br><span class="line">		st[++top] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r[n] = n+<span class="number">1</span>;</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">	st[<span class="number">0</span>] = n+<span class="number">1</span>;</span><br><span class="line">	st[++top] = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(top&amp;&amp;a[st[top]]&gt;a[i]) top--;</span><br><span class="line">		r[i] = st[top];</span><br><span class="line">		st[++top] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dpl[i] = dpl[l[i]]+(i-l[i])*a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		dpr[i] = dpr[r[i]]+(r[i]-i)*a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> maxid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> tmp = dpl[i]+dpr[i]-a[i];</span><br><span class="line">		<span class="keyword">if</span> (tmp&gt;ans)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = tmp;</span><br><span class="line">			maxid = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ansid[maxid] = a[maxid];</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> last = a[maxid];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=maxid<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            last = <span class="built_in">min</span>(last,a[i]);</span><br><span class="line">            ansid[i] = last;</span><br><span class="line">        &#125;</span><br><span class="line">	last = a[maxid];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=maxid+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			last = <span class="built_in">min</span>(last,a[i]);</span><br><span class="line">            ansid[i] = last;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ansid[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Happy-New-Year"><a href="#D-Happy-New-Year" class="headerlink" title="D. Happy New Year"></a>D. Happy New Year</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个初始为全为0的数列，有m个操作，每次操作可以使一个区间[l,r]都+1，可以选择操作或者不操作。求，最多有多少个数字能变成奇数。(数据保证每个点数字的最终值最大为k,k &lt; 8)</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>是个状压dp，说起来我也就是刚刚看懂别人的代码的程度。讲不出来，直接贴代码吧。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,col[maxn&lt;&lt;<span class="number">1</span>],colorMask[maxn&lt;&lt;<span class="number">1</span>],dp[<span class="number">2</span>*maxn][<span class="number">266</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        p.push_back(make_pair(l,i+n));</span><br><span class="line">        p.push_back(make_pair(r+<span class="number">1</span>,i));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> id = p[i<span class="number">-1</span>].second;</span><br><span class="line">            <span class="keyword">if</span> (id&gt;=n)&#123;<span class="comment">//是其实节点，给该节点增加可选项</span></span><br><span class="line">                id-=n;</span><br><span class="line">                <span class="keyword">for</span> (col[id]=<span class="number">0</span>;col[id]&lt;k;++col[id]) <span class="keyword">if</span> ((colorMask[i<span class="number">-1</span>]&gt;&gt;col[id]&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                colorMask[i] = colorMask[i<span class="number">-1</span>]|(<span class="number">1</span>&lt;&lt;col[id]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> colorMask[i] = colorMask[i<span class="number">-1</span>]^(<span class="number">1</span>&lt;&lt;col[id]);<span class="comment">//区间结束。</span></span><br><span class="line">        &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=p[i<span class="number">-1</span>].first,j=p[i<span class="number">-1</span>].second;</span><br><span class="line">            <span class="keyword">int</span> numChild = (i==<span class="number">2</span>*n?<span class="number">0</span>:p[i].first-x);</span><br><span class="line">            <span class="keyword">int</span> color = col[j%n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mask=<span class="number">0</span>;mask&lt;(<span class="number">1</span>&lt;&lt;k);++mask)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> happy=(__builtin_popcount(mask&amp;colorMask[i])%<span class="number">2</span>?numChild:<span class="number">0</span>);</span><br><span class="line">                dp[i][mask] = happy+dp[i<span class="number">-1</span>][mask];<span class="comment">//默认不选择</span></span><br><span class="line">                <span class="keyword">if</span> (j&lt;n) dp[i][mask] = <span class="built_in">max</span>(dp[i][mask],happy+dp[i<span class="number">-1</span>][mask^(<span class="number">1</span>&lt;&lt;color)]);<span class="comment">//选择这个区间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">2</span>*n][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>虚树入门解析</title>
    <url>/2020/05/05/%E8%99%9A%E6%A0%91%E5%85%A5%E9%97%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实很早之前就知道虚树这个东西了。。。。说起来好像是去年的暑训？一个金牌学长讲的，然后当时就云里雾里，想着找时间再补，结果就把一个叫虚树入门的网页放在浏览器收藏夹吃灰了一年。。。。。<br><a id="more"></a></p>
<p>不过也的确是没碰到过虚树的题。。。。（是我做的太少了对八七QAQ）。。然后最近跟同学水他们学校的校赛的时候突然碰到了一道用虚树的题。。。脑子不好了。。。交了发N方算法企图过百万。。。。</p>
<p>然后最近赶紧回来补了QAQ…</p>
<h1 id="虚树是啥？"><a href="#虚树是啥？" class="headerlink" title="虚树是啥？"></a>虚树是啥？</h1><p>虚树是用来解决一类树形DP题的优化方法。具体来说，就是有一些树形DP题的DP过程中，只跟一些关键点有关系，其他的点的转移都是不需要操作的。这种时候，我们就可以把做一棵虚树，只把<strong>关键点和他们的LCA</strong>连起来，形成一棵虚树，在虚树上进行DP就会快很多。</p>
<h1 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h1><p>首先我们知道我们在进行普通的树形dp的时候，其实并不是在一棵树上跑的，而是一个栈，其中的节点不断入栈出栈，并进行dp。节点入栈出栈的顺序就是dfs序。</p>
<p>而显然我们造的虚树的相对dfs序跟原树一定是相同的。</p>
<p>那么如何建一棵虚树呢？<br>暴力建是不可行的。因为那样每次建虚树都要遍历整个树，那样的话虚树优化的意义就没有了。我们希望的是，我们只去扫一遍那些关键点，就可以将一棵虚树造出来。</p>
<p>具体来说。</p>
<p>我们首先遍历一遍原树，记录他们每个节点的  dfs序以及深度  deep。然后我们就可以对一组关键点进行建虚树了（这类的题一般关键点有好几组）。</p>
<p>我们要对这些关键点，按照他们的dfs序进行排序。然后建立一个栈，一边模拟他们的入栈出栈顺序，一边建树。</p>
<p>我们的栈，用来维护的，是一条链，从根节点到当前节点的一条链。</p>
<p>我们先把第一个节点放进栈中（暂时当根节点）。<br>之后我们考虑继续添加的节点。</p>
<p>我们设我们要新加入的节点为  x  ,栈顶元素为  stack[top]  ,他们的最近公共祖先为   lc=lca(stack[top],x)。</p>
<p>因为我们确定，最近公共祖先一定是在stack维护的这条链上的，所以我们只需要对于lc的位置进行分类讨论如何建边即可。</p>
<ul>
<li><p>情况1:</p>
<p>  deep[lc] &lt; deep[stack[top-1]]</p>
<p>  这时当前插入的点一定是已经跳出栈维护的这条链了，那么我们可以不断地建边stack[top-1]-&gt;stack[top]，出栈,直到不满足这个条件。</p>
<p>  在处理完情况1之后，那么lc一定实在stack[top-1]的下方了。而lc又一定在stack[top]的上方，所以只剩下三种情况了。</p>
</li>
</ul>
<ul>
<li><p>情况2:</p>
<p>  lc==stack[top] ,也就是当前要加入的节点可以使得链继续延伸，那么把新节点入栈就好了。</p>
</li>
<li><p>情况3：</p>
<p>  lc==stack[top-1],也就是说，stack[top-1]之下的子树已经构建完了，连边stack[top-1]-&gt;stack[top],栈顶出栈,并把新节点入栈即可。</p>
</li>
<li><p>情况4:</p>
<p>  说明lc在stack[top-1]与stack[top]之间，其实跟情况三类似，我们需要建边lc-&gt;stack[top],然后栈顶出栈，再依次将lc,新节点,加入到栈中即可。</p>
</li>
</ul>
<p>最后，我们再把栈中的节点都连起来即可。</p>
<p>这样一个虚树就完成了，而且只需要扫一遍关键点就OK了，关于LCA的算法，倍增，tarjan，树剖都行。</p>
<h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>这个真心不会算，留坑吧<br>QAQ</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="洛谷-消耗战"><a href="#洛谷-消耗战" class="headerlink" title="[洛谷]消耗战"></a>[洛谷]消耗战</h2><p>原题链接：<a href="https://www.luogu.com.cn/problem/P2495" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2495</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一棵树，每个边有边权，每次给你一组关键点，问如何删边，可以使得所有关键点都不与1号节点连接，问最小删边代价。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>如果没有多组询问就是普通的树形DP,</p>
<p>对于一个点，如果他是关键点，那么他必须删除他与根节点的联系，代价就是他到根节点的路径上的边权的最小值。</p>
<p>如果他不是关键点，那么它可以删除他自己，跟关键点的删除方法一样，也可以删除他子树中的所有关键点的联系，代价是他们的和，这样一来，他两者之间取一个最小值即可。</p>
<p>这么来看，实际上这个树形dp只与关键点和他们的lca有关系，典型的虚树题。</p>
<p>我们先预处理出每个点的与根节点路径上的边权的最小值mn[i];</p>
<p>之后对每组关键点建一棵虚树，在虚树上正常dp即可。</p>
<p>注意初始化虚树也需要dfs来做，否则时间复杂度会退化。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf = <span class="number">1000000000000000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">&#125;E[<span class="number">600000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">500010</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt].to = y;</span><br><span class="line">    E[cnt].w = w;</span><br><span class="line">    E[cnt].next = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">500010</span>][<span class="number">20</span>],deep[<span class="number">500010</span>],dfn[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">int</span> Time=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mn[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[x][<span class="number">0</span>] = f;</span><br><span class="line">    deep[x] = deep[f]+<span class="number">1</span>;</span><br><span class="line">    dfn[x] = ++Time;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==f) <span class="keyword">continue</span>;</span><br><span class="line">        mn[to] = <span class="built_in">min</span>(mn[x],E[i].w);</span><br><span class="line">        dfs1(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x]&lt;deep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[fa[x][i]]&gt;=deep[y])</span><br><span class="line">        x = fa[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i]!=fa[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">            y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">500010</span>],num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[a]&lt;dfn[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head2[<span class="number">500010</span>],cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> <span class="title">E2</span>[500010];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E2[++cnt2].next = head2[x];</span><br><span class="line">    E2[cnt2].to = y;</span><br><span class="line">    head2[x] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">500010</span>],top=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">0</span>) &#123;<span class="built_in">stack</span>[++top]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> lc = lca(<span class="built_in">stack</span>[top],x);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;lc&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">while</span>(deep[<span class="built_in">stack</span>[top<span class="number">-1</span>]]&gt;deep[lc]) &#123;</span><br><span class="line">        add2(<span class="built_in">stack</span>[top<span class="number">-1</span>],<span class="built_in">stack</span>[top]);</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lc==<span class="built_in">stack</span>[top]) &#123;<span class="built_in">stack</span>[++top] = x;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[<span class="built_in">stack</span>[top]]&gt;deep[lc])</span><br><span class="line">    &#123;   </span><br><span class="line">        add2(lc,<span class="built_in">stack</span>[top]);</span><br><span class="line">        <span class="keyword">if</span> (lc!=<span class="built_in">stack</span>[top<span class="number">-1</span>])</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="built_in">stack</span>[top] = lc;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag[<span class="number">500010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = inf;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tem = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head2[x];i;i=E2[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E2[i].to;</span><br><span class="line">        tem+=dfs2(to); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag[x]) ans = mn[x];</span><br><span class="line">    <span class="keyword">else</span> ans = <span class="built_in">min</span>(tem,mn[x]); </span><br><span class="line">    flag[x] = <span class="literal">false</span>;</span><br><span class="line">    head2[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        add(u,v,w);</span><br><span class="line">        add(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    mn[<span class="number">1</span>] = inf;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">    fa[j][i] = fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++) &#123;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id[i]);flag[id[i]]=<span class="literal">true</span>;&#125;</span><br><span class="line">        sort(id+<span class="number">1</span>,id+num+<span class="number">1</span>,cmp);</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;id[i]&lt;&lt;endl;</span></span><br><span class="line">            insert(id[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;top;i++) add2(<span class="built_in">stack</span>[i],<span class="built_in">stack</span>[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;stack[1]&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dfs2(<span class="built_in">stack</span>[<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="牛客-王国"><a href="#牛客-王国" class="headerlink" title="[牛客]王国"></a>[牛客]王国</h2><p>原题链接：<a href="https://ac.nowcoder.com/acm/contest/5403/C" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/5403/C</a></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一棵树，每个节点有个序号，边权为1，问相同序号的节点的最大距离的平方是多少？</p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>没有序号的话，就是随便求个直径就行，有了序号的话，就需要对于每组相同序号的节点，建一棵虚树，再求直径即可。<br>注意边权可以用树上差分得到，我也不知道为啥直接深度相减他不行QAQ.</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;E[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	E[++cnt].next = head[x];</span><br><span class="line">	E[cnt].to = y;</span><br><span class="line">	head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[maxn],fa[maxn][<span class="number">23</span>],dfn[maxn],Time;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fa[x][<span class="number">0</span>] =f;</span><br><span class="line">	dep[x] = dep[f]+<span class="number">1</span>;</span><br><span class="line">	dfn[x] = ++Time;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to = E[i].to;</span><br><span class="line">		<span class="keyword">if</span> (to==f) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(to,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[fa[x][i]]&gt;=dep[y])</span><br><span class="line">		x = fa[x][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fa[x][i]!=fa[y][i])</span><br><span class="line">		&#123;</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">			y = fa[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> <span class="title">E2</span>[<span class="title">maxn</span>&lt;&lt;1];</span></span><br><span class="line"><span class="class">int head2[maxn],cnt2;</span></span><br><span class="line"><span class="class">void add2(int x,int y,int w)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">	E2[++cnt2].to = y;</span></span><br><span class="line"><span class="class">	E2[cnt2].next = head2[x];</span></span><br><span class="line"><span class="class">	E2[cnt2].w = w;</span></span><br><span class="line"><span class="class">	head2[x] = cnt2;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int getln(int x,int y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">	return dep[x]+dep[y]-2*dep[lca(x,y)];</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int stak[maxn],top=0;</span></span><br><span class="line"><span class="class">void insert(int x)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">	if (top==0) &#123;stak[++top]=x;return;&#125;</span></span><br><span class="line"><span class="class">	int lc = lca(x,stak[top]);</span></span><br><span class="line"><span class="class">	while(dep[stak[top-1]]&gt;dep[lc])&#123;</span></span><br><span class="line"><span class="class">		int W = getln(stak[top-1],stak[top]);</span></span><br><span class="line"><span class="class">		add2(stak[top-1],stak[top],W);</span></span><br><span class="line"><span class="class">		add2(stak[top],stak[top-1],W);</span></span><br><span class="line"><span class="class">		top--;</span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">	if (lc==stak[top])&#123;stak[++top]=x;return;&#125;</span></span><br><span class="line"><span class="class">	if (dep[stak[top]]&gt;<span class="title">dep</span>[<span class="title">lc</span>])</span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> W = getln(lc,stak[top]);</span><br><span class="line">		add2(lc,stak[top],W);</span><br><span class="line">		add2(stak[top],lc,W);</span><br><span class="line">		<span class="keyword">if</span> (stak[top<span class="number">-1</span>]==lc)</span><br><span class="line">		&#123;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			stak[top] = lc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stak[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dep2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=head2[x];i;i=E2[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to = E2[i].to;</span><br><span class="line">		<span class="keyword">if</span> (to==f) <span class="keyword">continue</span>;</span><br><span class="line">		dep2[to] = dep2[x]+E2[i].w;</span><br><span class="line">		<span class="keyword">int</span> temp = dfs2(to,x);</span><br><span class="line">		<span class="keyword">if</span> (dep2[temp]&gt;dep2[ans])</span><br><span class="line">		ans = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=head2[x];i;i=E2[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to = E2[i].to;</span><br><span class="line">		<span class="keyword">if</span> (to==f) <span class="keyword">continue</span>;</span><br><span class="line">		init_dfs(to,x);</span><br><span class="line">	&#125;</span><br><span class="line">	head2[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep2[stak[<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> rt=dfs2(stak[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">	dep2[rt]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = dfs2(rt,<span class="number">0</span>);</span><br><span class="line">	init_dfs(stak[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> dep2[ans];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dfn[x]&lt;dfn[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">		a[x].push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">		add(u,v);add(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">21</span>;i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	fa[j][i] = fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i].<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		sort(a[i].<span class="built_in">begin</span>(),a[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">		cnt2 = <span class="number">0</span>;</span><br><span class="line">		top = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a[i].<span class="built_in">size</span>();j++)</span><br><span class="line">		&#123;</span><br><span class="line">			insert(a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;top;j++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> W = getln(stak[j],stak[j+<span class="number">1</span>]);</span><br><span class="line">			add2(stak[j],stak[j+<span class="number">1</span>],W);</span><br><span class="line">			add2(stak[j+<span class="number">1</span>],stak[j],W);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> temp = solve();</span><br><span class="line">		ans = <span class="built_in">max</span>(ans,temp*temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="无关题目"><a href="#无关题目" class="headerlink" title="无关题目"></a>无关题目</h1><p>一棵线段树的题目，牵扯一点数论知识。把代码放这了。。。（懒得再开一个post了QAQ）</p>
<p>题目：<a href="https://ac.nowcoder.com/acm/contest/5403/G" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/5403/G</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">200000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tr[<span class="number">4</span>][<span class="number">400010</span>];<span class="comment">//2 3 5 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id,<span class="keyword">int</span> is,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[id][t]+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid&gt;=is) insert(t&lt;&lt;<span class="number">1</span>,l,mid,id,is,val);</span><br><span class="line">    <span class="keyword">if</span> (mid&lt;is) insert(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,id,is,val);</span><br><span class="line">    tr[id][t] = tr[id][t&lt;&lt;<span class="number">1</span>]+tr[id][t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=ll&amp;&amp;r&lt;=rr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[id][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid&gt;=ll) ans+=<span class="built_in">get</span>(t&lt;&lt;<span class="number">1</span>,l,mid,id,ll,rr);</span><br><span class="line">    <span class="keyword">if</span> (mid&lt;=rr) ans+=<span class="built_in">get</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,id,ll,rr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">2</span>) insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">0</span>,i,f*<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">3</span>) insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,i,f*<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">4</span>) insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">0</span>,i,f*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">5</span>) insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">2</span>,i,f*<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">6</span>) &#123;insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">0</span>,i,f*<span class="number">1</span>);insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,i,f*<span class="number">1</span>);&#125; </span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">7</span>) insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">3</span>,i,f*<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">8</span>) insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">0</span>,i,f*<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">9</span>) insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,i,f*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">10</span>) &#123;insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">2</span>,i,f*<span class="number">1</span>);insert(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">0</span>,i,f*<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        in(a[i],i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num,a1,b1;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;num,&amp;a1,&amp;b1);</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            in(a[a1],a1,<span class="number">-1</span>);</span><br><span class="line">            a[a1] = b1;</span><br><span class="line">            in(b1,a1,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">            ans = ans*(<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">0</span>,a1,b1)+<span class="number">1</span>)%mod;</span><br><span class="line">            ans = ans*(<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,a1,b1)+<span class="number">1</span>)%mod;</span><br><span class="line">            ans = ans*(<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">2</span>,a1,b1)+<span class="number">1</span>)%mod;</span><br><span class="line">            ans = ans*(<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">3</span>,a1,b1)+<span class="number">1</span>)%mod;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>python近日细节性总结(无序)</title>
    <url>/2020/04/21/python%E4%BB%8A%E6%97%A5%E7%BB%86%E8%8A%82%E6%80%A7%E6%80%BB%E7%BB%93-%E6%97%A0%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h1><p>如果使用python2，可能会碰到中文编码错误的问题，解决方法是在程序开头加一行  </p>
<blockquote>
<p># -<em>- coding：UTF-8 -</em>-<br>或者<br># coding=utf-8</p>
</blockquote>
<p>python3默认是utf-8,所以一般没啥问题<br><a id="more"></a></p>
<h1 id="写法细节"><a href="#写法细节" class="headerlink" title="写法细节"></a>写法细节</h1><h2 id="可以用斜杠（-将一行分为多行显示"><a href="#可以用斜杠（-将一行分为多行显示" class="headerlink" title="可以用斜杠（\)将一行分为多行显示"></a>可以用斜杠（\)将一行分为多行显示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = one+\</span><br><span class="line">    two+\</span><br><span class="line">    three</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释有两种 ‘#‘ 和 三个引号</p>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>同一行显示多条语句用分号’;’分割</p>
<h2 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h2><p>print输出默认换行，如果不换行需要在末尾加逗号(,)</p>
<h2 id="代码组"><a href="#代码组" class="headerlink" title="代码组"></a>代码组</h2><p>很多复合性的语句，如if,while,for 要以冒号(:)结尾</p>
<h1 id="Python变量类型"><a href="#Python变量类型" class="headerlink" title="Python变量类型"></a>Python变量类型</h1><p>Python的标准数据类型有五个：</p>
<ul>
<li>Numbers</li>
<li>String</li>
<li>List(列表)</li>
<li>Tuple(元组)</li>
<li>Dictionary(字典)</li>
</ul>
<p>python是动态语言，变量没有固定的类型限制，就是说虽然一个变量一个时间点只能是一种变量，但是他并不是不能更改用来储存其他类型的变量。差不多只是一个容器的作用。</p>
<h2 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h2><p>python支持整数，浮点数，复数的数字类型。<br>整数型并没有int和long类型的明确限制，在int溢出是会自动转换为long</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String是python的字符串类型，很多意义上与C语言的字符数组类似。</p>
<p>值得一提的是，他支持一些很舒服的操作：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'JJHQAQ'</span> <span class="comment"># 普通字符串</span></span><br><span class="line">str1 = str[<span class="number">0</span>] <span class="comment"># 一个字符的字符串</span></span><br><span class="line">str2 = str[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 由第二个字符到第三个字符组成的字符串</span></span><br><span class="line">str3 = str[<span class="number">2</span>:] <span class="comment"># 由第三个字符往后的字符串</span></span><br><span class="line">str4 = str*<span class="number">2</span>  <span class="comment"># 玄幻的乘法操作，是两个相同的str连接而成</span></span><br><span class="line">str5 = str + <span class="string">"cai"</span> <span class="comment"># 将新字符串接在末尾</span></span><br></pre></td></tr></table></figure></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表[]"></a>列表[]</h2><p>python的数据组形式，可以理解成一串连续的各种类型的变量组成的连续储存结构，类似于C语言的数组，可以嵌套自己；<br>支持+,’*‘,和那几种切片运算</p>
<h2 id="元组（）"><a href="#元组（）" class="headerlink" title="元组（）"></a>元组（）</h2><p>跟列表相似，只是不能再更改其中内容。类比的话，就好像列表存的是变量，元组存的是常量。<br>用法类似</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典{}"></a>字典{}</h2><p>惊了，这个竟然直接是基本数据类型，太舒服了。<br>字典类似于C语言里的map，可以通过键值访问对应的值。一一对应。</p>
<h2 id="强转"><a href="#强转" class="headerlink" title="强转"></a>强转</h2><p>python支持用类似   int(x) 的形式强行进行变量类型之间的转换。 而且转换效果异常强大。 各种意义上。<br><del> 能直接把字符串转换成整数我也是惊了 </del></p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>值的注意的是</p>
<p>整除是’\\’ 幂运算是’**‘</p>
<p>不支持++,—</p>
<p>逻辑运算符有：</p>
<blockquote>
<p>and<br>or<br>not</p>
</blockquote>
<p>类比</p>
<blockquote>
<p>&amp;&amp;<br>||<br>!</p>
</blockquote>
<p>‘in’ 运算符，贼好用，判断序列中是否存在某个值，可以用于列表，元组，字符串，字典</p>
<p>ps: 常量 in 序列  返回 bool类型（int的子类）<br>变量 in 序列 一般是for里进行枚举</p>
<p>‘is’ 运算符，判断左右两边变量是否引用同一内存块</p>
<p>其他都与C语言类似</p>
<h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">    sentence</span><br><span class="line"><span class="keyword">elif</span> expression:</span><br><span class="line">    sentence</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sentence</span><br></pre></td></tr></table></figure>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>有while , for ,有关的关键字是continue ， break ,pass</p>
<p>其中有点特别的是for，pass</p>
<p>for用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 序列</span><br><span class="line">    sentence</span><br></pre></td></tr></table></figure>
<p>pass:<br>占行语句，什么都不会做</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>python的函数用def关键字来定义</p>
<p>语法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">( parameters )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><br>函数文档可以用help的方法调用来显示。</p>
<p>函数的参数不会限定类型,但是可以用类似下面的方法进行限制：</p>
<blockquote>
<p>def function(var : type) -&gt;return_type:</p>
</blockquote>
<p>具体再补趴。。。</p>
<h1 id="最近刷水题细节总结"><a href="#最近刷水题细节总结" class="headerlink" title="最近刷水题细节总结"></a>最近刷水题细节总结</h1><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var = true_val <span class="keyword">if</span> expression <span class="keyword">else</span> false_val</span><br></pre></td></tr></table></figure>
<h2 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h2><p>len()返回序列长度</p>
<h2 id="str-join"><a href="#str-join" class="headerlink" title="str.join()"></a>str.join()</h2><p>以str为中间连接符连接join内部的内容.<br>写马拉车的时候回比较方便</p>
<h2 id="str-replace-str1-str2"><a href="#str-replace-str1-str2" class="headerlink" title="str.replace(str1,str2)"></a>str.replace(str1,str2)</h2><p>讲str中的字符换成指定字符</p>
<h2 id="list-index-val"><a href="#list-index-val" class="headerlink" title="list.index(val)"></a>list.index(val)</h2><p>返回val对应的一地个序列中匹配值的下标</p>
<h2 id="快读的正则表达式写法（震撼我妈）"><a href="#快读的正则表达式写法（震撼我妈）" class="headerlink" title="快读的正则表达式写法（震撼我妈）"></a>快读的正则表达式写法（震撼我妈）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">      <span class="keyword">return</span> max(min(int(*re.findall(<span class="string">'^[\+\-]?\d+'</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), <span class="number">-2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure>
<h2 id="bool函数"><a href="#bool函数" class="headerlink" title="bool函数"></a>bool函数</h2><p>有两个返回值True和False</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>远古向补题——环球旅行</title>
    <url>/2020/04/18/%E8%BF%9C%E5%8F%A4%E5%90%91%E8%A1%A5%E9%A2%98%E2%80%94%E2%80%94%E7%8E%AF%E7%90%83%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="题源"><a href="#题源" class="headerlink" title="题源"></a>题源</h1><p>来自之前牛客的一场挑战赛，当时偷偷进去看了一眼，发现一道都不会，顿时觉得自己太过懈怠，功力不足，娱乐过度，十分后悔———————————————————————————————————然后就去颓废了(*･ω&lt; )</p>
<p>原题连接：<a href="https://ac.nowcoder.com/acm/contest/4912/A" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/4912/A</a><br><a id="more"></a></p>
<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给一棵树，有边权，可以删除一条边，要求是让剩下的两棵树(或者一棵)中的最大直径最小。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>首先很容易想到删除原树非直径边的话，最大直径大小不会变小，所以要删的边一定在直径上。</p>
<p>求直径是O(N)，但是如果暴力枚举两边的子树直径，就成O(N^2)了，显然对于1e6的数据范围不是不允许的.</p>
<p>然后想到一个直径的性质，比如直径是点对（r1,r2）之间的路径的话，那么切割直径上的一条路径后，剩下的两子树的直径一定是（r1,x）,(y,r2),可以用反证法很容易得证明以上性质。</p>
<p>具体来说就是，如果子树上存在一条更长的直径的某一条端点不是r1，那么r1是直径的前提就不成立，因为总是可以从那条子树更长直径上找到原树的更长的直径。</p>
<p>所以根据这个性质预处理直径上每个点i向非直径方向的最长伸展，记为mdis[i]，在讲从r1端开始到该节点的距离记为dis[i];这样去枚举删除直径上每一条路径得到的答案，O(N)就能解决了。</p>
<p>小计，树的直径的求法：<br>首先从任意一个点dfs，找到离这个点最远的一个点，就是直径的一个端点，再从这条端点再次dfs，找到最远的点，就是另一个端点了。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,r1,r2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt,to,w;</span><br><span class="line">&#125;E[<span class="number">3000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">1500000</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1500000</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1500000</span>];</span><br><span class="line"><span class="keyword">int</span> mdis[<span class="number">1500000</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1500000</span>];</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">1500000</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = INT32_MAX;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt].nxt = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    E[cnt].w = w;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==f) <span class="keyword">continue</span>;</span><br><span class="line">        dis[to] = dis[x]+E[i].w;</span><br><span class="line">        dfs(to,x);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">int</span> r = dis[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==f||dis[to]!=inf) <span class="keyword">continue</span>;</span><br><span class="line">        dis[to] = dis[x]+E[i].w;</span><br><span class="line">        r = <span class="built_in">max</span>(r,dfs2(to,x));    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gettr</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> &amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dis[i] = inf;</span><br><span class="line">    dis[s] = <span class="number">0</span>; </span><br><span class="line">    dfs(s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (dis[i]&gt;maxx)&#123;maxx=dis[i];r=i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gettr(<span class="number">1</span>,r1);</span><br><span class="line">    gettr(r1,r2);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(r1);</span><br><span class="line">    pre[r1] = r1;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to==pre[x]) <span class="keyword">continue</span>;</span><br><span class="line">            pre[to] = x;</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u = r2;</span><br><span class="line">    <span class="keyword">while</span>(pre[u]!=u)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(u);</span><br><span class="line">        u = pre[u];</span><br><span class="line">    &#125;</span><br><span class="line">    a.push_back(u);<span class="comment">//r2-&gt;r1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,a,b,w;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        add(a,b,w);</span><br><span class="line">        add(b,a,w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getList();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i] = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: a) dis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: a) mdis[i]=dfs2(i,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    gettr(r2,r1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = mdis[a[i]]+dis[a[i]];</span><br><span class="line">        <span class="keyword">if</span> (i) f[i] = <span class="built_in">max</span>(f[i],f[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = dis[r1]-dis[a[i]]+mdis[a[i]];</span><br><span class="line">        <span class="keyword">if</span> (i!=a.<span class="built_in">size</span>()<span class="number">-1</span>) g[i] = <span class="built_in">max</span>(g[i],g[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a.<span class="built_in">size</span>()<span class="number">-2</span>;i++)</span><br><span class="line">    ans = <span class="built_in">min</span>(ans,<span class="built_in">max</span>(f[i],g[i+<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>随缘补题</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 635 Div2</title>
    <url>/2020/04/18/Codeforces-635-Div2/</url>
    <content><![CDATA[<h1 id="A-Ichihime-and-Triangle"><a href="#A-Ichihime-and-Triangle" class="headerlink" title="A Ichihime and Triangle"></a>A Ichihime and Triangle</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给三个首尾相连的闭区间，要求在每个区间中取一个数，使得取得的三个数可以组成三角形。<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>仔细一想就能发现，因为三角形要满足两边之和大于第三边，这样的话我们让较大的两条边相等，那么剩下一条边就可以随便选了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,a,b,c,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,b,c,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Kana-and-Dragon-Quest-game"><a href="#B-Kana-and-Dragon-Quest-game" class="headerlink" title="B. Kana and Dragon Quest game"></a>B. Kana and Dragon Quest game</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个整数h，要求用下面两种操作使得h变为0或负数。</p>
<ul>
<li>操作一，使h变为 h/2-10(整除)</li>
<li>操作二，使h变为 h-10</li>
</ul>
<p>可以使用至多n次操作一，至多m次操作二。问能否实现将h变为非正整数。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>对于操作二，其贡献是稳定的-10，而操作一是在数字越大时贡献越大（百分比伤害和固定伤害？打游戏的都懂），所以我们先尽可能得使用操作一，在操作一没有效果了过或者用完之后在进行操作二即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x/<span class="number">2</span>+<span class="number">10</span>&lt;x)</span><br><span class="line">            x = x/<span class="number">2</span>+<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;=m*<span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Linova-and-Kingdom"><a href="#C-Linova-and-Kingdom" class="headerlink" title="C Linova and Kingdom"></a>C Linova and Kingdom</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一棵树，有n个节点，根节点为1号，现在让你选择k个节点，每个节点的贡献值为该节点到1号节点的最短路径上的非选定节点个数，要求使得总贡献最大，求这个最大贡献。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>首先有一个很明显的性质，如果你要选择一个节点，那么他的子树里一定是没有未选择节点存在了。因为如果有的话，选择子树中的节点一定比选择这个节点更优。</p>
<p>如此一来，每次选择的节点肯定是子树都被选满了的。那么这个选择顺序一定是满足拓扑序列的。</p>
<p>另一个问题是，同级别的节点，在拓扑序中是不固定的，那么如何去筛选呢？贪心即可，因为有上边说的性质，所以每个节点的贡献值是固定的，即从该节点到根节点的路径上节点数 - 他的子树大小（dep[i] - size[i）;</p>
<p>用一个堆去筛选即可。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val&lt;a.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&gt; <span class="title">q</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;E[<span class="number">500000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">300000</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	E[++cnt].nxt = head[x];</span><br><span class="line">	E[cnt].to = y;</span><br><span class="line">	head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">300000</span>],du[<span class="number">300000</span>],fa[<span class="number">300000</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">300000</span>];</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">300000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	dep[x] = dep[f]+<span class="number">1</span>;</span><br><span class="line">	sum[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to = E[i].to;</span><br><span class="line">		<span class="keyword">if</span> (to==f) <span class="keyword">continue</span>;</span><br><span class="line">		du[x]++;</span><br><span class="line">		fa[to] = x;</span><br><span class="line">		dfs(to,x);</span><br><span class="line">		sum[x]+=sum[to];</span><br><span class="line">	&#125;</span><br><span class="line">	val[x] = dep[x]-sum[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		add(x,y);</span><br><span class="line">		add(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	dep[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (du[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">N</span>;</span></span><br><span class="line">			N.id = i;</span><br><span class="line">			N.val = val[i];</span><br><span class="line">			q.push(N);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">x</span> = <span class="title">q</span>.<span class="title">top</span>();</span></span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="comment">// cout&lt;&lt;x.id&lt;&lt;endl;</span></span><br><span class="line">		ans+=(<span class="keyword">long</span> <span class="keyword">long</span>)x.val;</span><br><span class="line">		du[fa[x.id]]--;</span><br><span class="line">		<span class="keyword">if</span> (du[fa[x.id]]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">N</span>;</span></span><br><span class="line">			N.id = fa[x.id];</span><br><span class="line">			N.val = val[fa[x.id]];</span><br><span class="line">			q.push(N);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Xenia-and-Colorful-Gems"><a href="#D-Xenia-and-Colorful-Gems" class="headerlink" title="D. Xenia and Colorful Gems"></a>D. Xenia and Colorful Gems</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给三个整数集合，要求在每个集合中选择一个数，得到x,y,z.要求选出的三个数使得（x-y）^2 + (y-z)^2 + (z-x)^2 最小</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>每次固定某个集合中的一个数x，那么与他有关的可能答案就是在另两个集合中最靠近他的数组成的答案。<br>另外两个集合中与x最靠近的数一般会有两个，可以用lower_bound()在log级别时间里找到，之后把找到的四个数与x的四个组合挨个排查一遍即可。</p>
<p>每个集合都去筛选一遍，保证不会有漏选。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ss</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x-y)*(x-y)+(x-z)*(x-z)+(y-z)*(y-z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; b,<span class="built_in">vector</span>&lt;<span class="keyword">long</span>  <span class="keyword">long</span>&gt; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ret = LLONG_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ib = lower_bound(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),a[i])-b.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ic = lower_bound(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),a[i])-c.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">if</span> (ib!=b.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (ic!=c.<span class="built_in">size</span>()) ret = <span class="built_in">min</span>(ret,ss(a[i],b[ib],c[ic]));</span><br><span class="line">			<span class="keyword">if</span> (ic) ret = <span class="built_in">min</span>(ret,ss(a[i],b[ib],c[ic<span class="number">-1</span>]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ib)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (ic!=c.<span class="built_in">size</span>()) ret = <span class="built_in">min</span>(ret,ss(a[i],b[ib<span class="number">-1</span>],c[ic]));</span><br><span class="line">			<span class="keyword">if</span> (ic) ret = <span class="built_in">min</span>(ret,ss(a[i],b[ib<span class="number">-1</span>],c[ic<span class="number">-1</span>]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y,z;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a(x),b(y),c(z);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;y;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;z;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;c[i]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = LLONG_MAX;</span><br><span class="line"></span><br><span class="line">		sort(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">		sort(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">		sort(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">		ans = <span class="built_in">min</span>(ans,solve(a,b,c));</span><br><span class="line">		ans = <span class="built_in">min</span>(ans,solve(b,a,c));</span><br><span class="line">		ans = <span class="built_in">min</span>(ans,solve(c,b,a));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Kaavi-and-Magic-Spell"><a href="#E-Kaavi-and-Magic-Spell" class="headerlink" title="E. Kaavi and Magic Spell"></a>E. Kaavi and Magic Spell</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给两个字符串S,T和一个空串A。有以下两种操作</p>
<ul>
<li>删除S的第一个字符，并将它添加到A的最前面</li>
<li>删除S的第一个字符，并将它添加到A的最后面</li>
</ul>
<p>操作n次，问有多少种不同的方案，使得得到的A串的前缀是T串。</p>
<h2 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h2><p>不同的方案数，具体是指对于S的第i个字母，做了不同的操作。<br>那么首先可以想到，可以对于每一个S的字母进行dp转移。</p>
<p>那么从哪开始转移呢？<br>我们设dp[i][j]表示A串中的[i,j]区间的串已经符合条件的不同填法。</p>
<p>因为T串总是比S串短或者相等的，设S串长度为n,T串为m,所以A的合法串就是指，在区间[1,m]与T串相同，在[m+1,n]随便填</p>
<p>如此一来可以就用区间dp的方法进行转移了。</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5000</span>],t[<span class="number">5000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">4000</span>][<span class="number">4000</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) dp[i][i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=n;len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l =<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;m || s[len]==t[l] ) </span><br><span class="line">            dp[l][r] = (dp[l][r]+dp[l+<span class="number">1</span>][r]) % mod;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;m || s[len]==t[r])</span><br><span class="line">            dp[l][r] = (dp[l][r]+dp[l][r<span class="number">-1</span>]) % mod;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=m;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    ans = (ans+dp[<span class="number">1</span>][i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>初探git使用</title>
    <url>/2020/04/13/%E5%88%9D%E6%8E%A2git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><strong>我发现我这两天竟然天天跟着狗硕学东西，题都懒得刷了QAQ,感觉要完蛋蛋了</strong><br><a id="more"></a></p>
<h1 id="关于git-个人理解"><a href="#关于git-个人理解" class="headerlink" title="关于git(个人理解)"></a>关于git(个人理解)</h1><p>git是一款非常流行的版本控制软件，其开发者Linus Torvalds好像还是linux的创始人(看名字就看出来了嘛…牛是怎么被定义的23333)。</p>
<p>所谓版本控制，其实就是开发代码的管理与保存。比如你今天写了一份代码，明天又写了一份，一个月后你写了好多份代码，删删改改之后，最后写了一个很大的项目。然后突然有一天，你可能发现之前某一天的代码改错了，你需要之前的历史版本的代码，结果之前的历史代码早就被你删掉了；也有可能你没删，你有个好习惯，每次改代码都把历史版本的代码备份了一遍，结果你还是找不到你要的那一份代码，因为历史版本的代码实在太多太乱了；再或者你和另一个伙伴一起写一个东西，结果你们把代码存的乱起八糟的，每个人都在互相使绊子。所以git就诞生了，为了解决这些个头疼的问题。</p>
<p>git能够以一个很优雅的代码管理方式帮你保存这些代码（或者是其他文件，但实际上只对于文本类的文件有特别强大的力量），能让你非常方便的寻找你需要的任何一个历史版本的代码。同时，他也提供了非常友好的团队协作模式。</p>
<p>阿。。。。其实我上边说的都属于任何一个版本控制软件的功能。然而git之所以脱颖而出，其实是因为它分布式，可离线的工作模式，具体我也感触不深，不过是老程序员们的选择，估计是优秀的不行吧。</p>
<h1 id="关于git的安装"><a href="#关于git的安装" class="headerlink" title="关于git的安装"></a>关于git的安装</h1><p>windows的话，需要去官网下载安装包进行安装。安装之后在随便一个文件管理窗口右键点击能看到git bush here 的选项，就是安装完成了。</p>
<p>Linux就舒服多了,安装过程及其舒适(毕竟可以说是一家的东西2333)。<br>在linux的shell里输入git，之后他会告诉你输入什么东西去安装，然后输入他给的那行代码，就安上了（自然是要联网的）。</p>
<p>安装完成后需要进行一步设置：</p>
<blockquote>
<p>git config —global user.name “Your Name”<br>git config —global user.email “Your email”</p>
</blockquote>
<p>双引号里写你的用户名和邮箱，大概意思就是告诉git你的用户信息，不填写的话会影响git的使用。</p>
<h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><h2 id="创建一个版本库"><a href="#创建一个版本库" class="headerlink" title="创建一个版本库"></a>创建一个版本库</h2><p>说是库，其实就是你工作的文件夹，不过都这么叫就是了。</p>
<p>首先在一个你觉得靠谱的地方创建一个文件夹，然后在这个文件夹里打开git窗口(就是使窗口的当前目录是你刚创建的文件夹)。</p>
<p>之后使用命令：</p>
<blockquote>
<p>git init</p>
</blockquote>
<p>然后库就用git建好了,虽然表面上看不到什么变化，但是实际上是多了一个名叫“.git”的隐藏文件夹的，这个文件夹就不要去管了，也不要去乱改里面的东西。</p>
<h2 id="将文件添加到库中"><a href="#将文件添加到库中" class="headerlink" title="将文件添加到库中"></a>将文件添加到库中</h2><p>你可以从创建一个.txt文件开始，在文件里随便输入点啥(根据我看的教程，windows选手请不要使用记事本去写.txt文件，建议用Notepad++去写)。</p>
<p>然后使用命令：</p>
<blockquote>
<p>git add filename</p>
</blockquote>
<p>将文件添加到暂存区，这里filename是你要添加的文件的名字，如果是刚刚呢个文本文件，你就写***.txt。暂存区是暂存，并不会将库内改动记录到git的改动记录里。</p>
<p>然后使用命令：</p>
<blockquote>
<p>git commit -m “一些注释”</p>
</blockquote>
<p>这样将当前库内的状态提交。双引号内部可以写你这次改动的东西，写啥都行，是类似注释的东西，给你自己或者别人看的。</p>
<p>以后每次做什么库内的改动，最后都git add,git commit就可以保存下历史状态了。<br>注意，可以多次git add之后再一起git commit,太多的commit指令会令人头疼。</p>
<h2 id="查看历史版本及其他状态"><a href="#查看历史版本及其他状态" class="headerlink" title="查看历史版本及其他状态"></a>查看历史版本及其他状态</h2><blockquote>
<p>git status<br>可以查看当前的暂存区与工作区的状态，他会告诉你什么改了，什么改了没交。</p>
<p>git log<br>可以查看各个commit操作的相应提交状态，每次提交都会分配一个提交序号(乱序)，你可以根据这个序号去访问之前的库版本<br>常用参数 ： —graph —pretty=oneline —abbrev-commit</p>
<p>git branch<br>可以查看各个提交分支</p>
</blockquote>
<h2 id="撤销修改和版本回退"><a href="#撤销修改和版本回退" class="headerlink" title="撤销修改和版本回退"></a>撤销修改和版本回退</h2><p>如果你只是用git add把一个文件放到了暂存区，没有commit，那么你可以用如下指令去撤销对于某一个文件的修改：</p>
<blockquote>
<p>git checkout —filename</p>
</blockquote>
<p>如果你已经commit过了，那么如果你想要撤回这次修改，那么你可以修改之后在commit一遍，或者使用reset命令。</p>
<blockquote>
<p>git reset —hard commit id</p>
</blockquote>
<p>后边的commitid是指你要回退的版本的编号，可以用git log查看。或者你也可以用HEAD^表示上一个版本，HEAD^^上两个版本，HEAD^n上n个版本。</p>
<p>这里—hard参数是指完全回退到提交完回退版本时的状态，并清空暂存区，重置工作区。<br>另外还有参数—soft 会保存工作区当前的修改，并把版本的工作区状态差异放在暂存区。<br>参数—mixed 则是清空暂存区，将当前版本和回退版本的差异直接体现在各个文档里，需要手动去解除冲突。</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>使用如下命令删除文件：</p>
<blockquote>
<p>git rm filename</p>
</blockquote>
<p>作用类似于git add,修改都会放在暂存区，可以用git checkout —file 进行恢复</p>
<h2 id="分支的创建管理"><a href="#分支的创建管理" class="headerlink" title="分支的创建管理"></a>分支的创建管理</h2><p>因为自己也没咋用过这个，就大体记录一下常用的命令：</p>
<blockquote>
<p>git branch //查看分支</p>
<p>git branch name//创建分支</p>
<p>git checkout name //切换分支</p>
<p>git merge name //合并分支,使用—no-ff保留分支合并历史记录</p>
<p>git branch -d name //删除分支</p>
</blockquote>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>之前有提过git是分布式的版本库管理软件，所以自然也可以对远程的库进行操作。<br>比较常见的远程库就是github。</p>
<p>如何连接github?</p>
<p>前提当然是需要有一个github的账号。</p>
<p>然后按一下步骤操作：<br>1.创建SSH Key<br>一般来说，我们与github的文件传输都是用SSH协议的，因为快一些。<br>首先去用户主目录里寻找.ssh目录(是个隐藏目录)，然后去找这个目录下的id_rsa和id_rsa.pub文件就是你的私钥和公钥(如果有的话)。<br>如果没有，就在git窗口里输入：</p>
<blockquote>
<p>ssh-keygen -t rsa -C “your email”</p>
</blockquote>
<p>双引号里写你的邮箱地址，然后后边都回车用默认值就好，之后应该就可以按照上面的步骤找到公钥和私钥了。</p>
<p>2.在github中对你的电脑添加信任<br>具体来说就是在github的setting页面跟SSH相关的那个地方，将你的公钥添加进去。</p>
<p>这样你就可以向这个账号的仓库里推送你的东西了。</p>
<p>3.在github 创建一个新的空仓库。<br>然后。。。github里就会有提示如何去做了，里面的做法一定是更与时俱进的。</p>
<p>关于推送的命令：</p>
<blockquote>
<p>git push //向指定仓库推送。</p>
<p>git remote //查看当前连接成功的远程库</p>
<p>git clone //下载github上的库的内容，不一定是你的，别人的也可以随便下。</p>
</blockquote>
<h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>为不务正业的自己，自罚三杯<del>纯牛奶</del>QAQ(吨吨吨吨吨吨)</p>
]]></content>
      <categories>
        <category>杂学</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu16.04双系统安装过程记录</title>
    <url>/2020/04/04/ubuntu16-04%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="装的原因"><a href="#装的原因" class="headerlink" title="装的原因"></a>装的原因</h1><p>emmm，其实也不能说原因吧，毕竟俺也早就想装了，提前熟悉下Linux系统什么的还是挺重要的，大概。但是之前由于没有经验嘛，网上的教程又都乱七八糟的，也不是很急，所以就一直咕着了。<br><a id="more"></a><br><strong>然后,辣个男人他出现了！</strong></p>
<p>万能的硕爷突然就给安好了，甚至还写了教程<del>zzsTXDY!!</del>,那我这一看，现在不装啥时候装阿，这还有个无敌的顾问在23333。</p>
<p>说起来装这个是挺头疼的其实，我听说硕爷他重装系统了好几次，害怕…但是万幸在硕爷的指导下一次就装成功了<del>zzsTXDY!!</del></p>
<h1 id="装的具体步骤"><a href="#装的具体步骤" class="headerlink" title="装的具体步骤"></a>装的具体步骤</h1><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p>虽然装个虚拟机的话，一个文件夹就够了，但是装双系统的话，启动盘还是必要的。<br>具体来说就是，去一些镜像网站下载一个ubuntu文件（华为的，阿里云的，或者一些别的杂七杂八的网站都能找到，官网也可）。然后需要一个刻录软件，我用的是UltraISO.exe.<br>具体链接如下：<br>华为的镜像网站: <a href="http://mirrors.huaweicloud.com/repository/ubuntu-releases/16.04/" target="_blank" rel="noopener">http://mirrors.huaweicloud.com/repository/ubuntu-releases/16.04/</a><br>ULtraISO:  <a href="https://www.cr173.com/html/50530_1.html" target="_blank" rel="noopener">https://www.cr173.com/html/50530_1.html</a></p>
<p>具体制作过程附赠我的参考博客： <a href="https://www.jianshu.com/p/187c4ab01add" target="_blank" rel="noopener">https://www.jianshu.com/p/187c4ab01add</a></p>
<h2 id="压缩硬盘空间"><a href="#压缩硬盘空间" class="headerlink" title="压缩硬盘空间"></a>压缩硬盘空间</h2><p>右键我的电脑-&gt;管理-&gt;磁盘管理 可以在其中管理磁盘空间，右键对应的盘选择压缩卷可以分割出空间。<br>我的电脑是双硬盘的，就是一个是C盘，一个是其他盘。这样我们在其他盘里分出100G左右的空间用作ubuntu的使用空间，然后在C盘分出200M用来存ubantu的系统启动引导项。<br>这里说明一下，因为电脑开机的时候是先在c盘搜索系统的启动引导项的，所以我们把ubantu的引导项也放在C盘的话，就可以在开机的时候自由切换两个系统了。<br>压缩完之后就可以进入下一步了。</p>
<h2 id="调整BISO设置"><a href="#调整BISO设置" class="headerlink" title="调整BISO设置"></a>调整BISO设置</h2><p>插入启动盘，重启电脑，在logo界面按F2(或者F12?不同电脑是不一样的)，之后要做两件事，一个是调整启动项为USB启动，另一个是把电脑的安全模式关掉(secure boot？或者也可能有fast boot，总之都关掉) 然后再次重启。<br>(Dell的部分电脑还有个radi on 的选项，要改成arhi,根据硕爷说的是ubuntu不支持这个radi on 的引导选项)</p>
<h2 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h2><p>再次重启之后不出意外就可以看到install Ubuntu的选项了，选择他就可以进入安装界面了。<br>之后会有一系列设置界面，语言选择英文或者中文，后面准备安装界面的选项不用选，最后一定注意在一个叫安装类型的界面要选其他选项。<br>然后会进入自定义分区界面。关于具体分区设置————<br>一下摘抄————</p>
<blockquote>
<p>在这里，你可以看到在第三步已经分好的空闲分区，上图是单硬盘的情况，只有一个空闲分区，大小是你分区时给定的；双硬盘的话还能看到另一个空闲分区，大小200M左右，所以下面的分区操作单双硬盘存在一点差别。</p>
<p>在这里，我们进行手动分区，假设你留出的空闲分区为 80G，点击空闲盘符，点击”+”进行分区，如下：</p>
<p>(1)efi：如果是单硬盘，在唯一的一个空闲分区上添加，大小200M，逻辑分区，空间起始位置，用于efi；如果是双硬盘，找到事先分好的200M空闲分区添加，逻辑分区，空间起始位置，用于efi。这个分区必不可少，用于安装ubuntu启动项。以下步骤单双硬盘就一样了，都在那个80G的空闲分区上添加</p>
<p>(2)swap:中文是”交换空间”，充当ubuntu的虚拟内存，一般的大小为电脑物理内存的2倍左右，可以将其分为 8G，逻辑分区，空间起始位置，用于”swap”或”交换空间”</p>
<p>(3) /:这是ubuntu 的根目录,用于安装系统和软件，相当于windows的C盘，我们将其分为 20G，主分区，空间起始位置，用于”ext4日志文件系统”，挂载点为”/“（根据你的磁盘空间调整，可以大一点，毕竟ubuntu装软件都是默认装在根目录的）</p>
<p>(4)/home:相当于windows的其他盘，剩下的全分给它，逻辑分区，空间起始位置，用于”ext4日志文件系统”，挂载点为”/home”</p>
<p>好了，分区完毕，你完全可以按照上面的描述进行分区，不会有任何问题，起码我一直都是这么做的（强烈建议）。当然，你也可以划分的更详细，具体划分可以百度。</p>
<p>下面的这一步很重要：在分区界面的下方，选择安装启动项的位置，我们刚刚不是创建了200M的efi分区吗，现在你看看这个区前面的编号是多少，比如是/dev/sda1,不同的机子会有不同的编号，下拉列表选择这个efi分区编号（这里一定要注意，windows的启动项也是efi文件，大小大概是500M，而我们创建的ubuntu的efi大小是200M，一定要选对），之后点击”Install Now”</p>
</blockquote>
<p>之后会有设置时间，键盘设置啥的的，都是小事了，随便选。最后会有用户名和用户密码的设置，密码很重要，谨慎设置（自己好记的）。<br>最后就等待安装完成就好了。</p>
<h2 id="其他可能遇到的问题"><a href="#其他可能遇到的问题" class="headerlink" title="其他可能遇到的问题"></a>其他可能遇到的问题</h2><p>极有可能在装完双系统之后会在第一次启动Ubuntu的时候卡住或者黑屏，解决方法搬运到这了：<a href="https://www.cnblogs.com/masbay/p/10718514.html" target="_blank" rel="noopener">https://www.cnblogs.com/masbay/p/10718514.html</a><br>还是网上大佬多。。。。<br>还有什么其他问题去我的友链里找Zs吧，去他博客里call他，一定会给你解决问题的<del>解决速度可能与性别或者表情包可爱程度有关</del></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>虽然一开始用不惯，但是Ubuntu有些地方还是挺香的，比如自带的开发工具啥的。终于踏入了Linux学习的第一步，恭喜自己，感谢硕爷！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>BJTU2020寒训题组(2.21)</title>
    <url>/2020/03/01/BJTU%E5%AF%92%E8%AE%AD%E9%A2%98%E7%BB%84-2-21/</url>
    <content><![CDATA[<p><strong>QAQ咕了太久以至于我都忘记是啥题了，wtcl…</strong><br><a id="more"></a></p>
<h1 id="A-CodeForces-1000B-Light-It-Up"><a href="#A-CodeForces-1000B-Light-It-Up" class="headerlink" title="A CodeForces - 1000B / Light It Up"></a>A CodeForces - 1000B / Light It Up</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一串灯泡，中间有若干个分界点，在分界点处之前是灭的灯，之后会变亮，相反也是，问在你至多额外加一个分界点的情况下你最多能让多少灯亮起来。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>仔细一想就知道加的分界点一定在已有的分界点左右，然后挨个枚举就好了，每次的新答案都可以利用前缀和O(1)求，取所有答案的最大值即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">100005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n,M;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;M);</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> la = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">	a[n+<span class="number">1</span>] = M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[i][t]=sum[i<span class="number">-1</span>][t]+a[i]-la;</span><br><span class="line">		sum[i][t^<span class="number">1</span>]=sum[i<span class="number">-1</span>][t^<span class="number">1</span>];</span><br><span class="line">		t^=<span class="number">1</span>;</span><br><span class="line">		la = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	t=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = sum[n+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> tt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[i+<span class="number">1</span>]-a[i]&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tt = sum[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (t==<span class="number">1</span>) tt++;</span><br><span class="line">			<span class="keyword">else</span> tt--;</span><br><span class="line">			tt+=sum[n+<span class="number">1</span>][<span class="number">0</span>]-sum[i][<span class="number">0</span>];</span><br><span class="line">			ans = <span class="built_in">max</span>(ans,tt);</span><br><span class="line">		&#125;</span><br><span class="line">		t^=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-CodeForces-1000C-Covered-Points-Count"><a href="#B-CodeForces-1000C-Covered-Points-Count" class="headerlink" title="B CodeForces 1000C / Covered Points Count"></a>B CodeForces 1000C / Covered Points Count</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出若干闭区间，问被x个区间覆盖的点分别有多少个（1\&lt; x \&lt;=n）。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>把区间里的左右点都放在一个map里，记录map中的每个点包含多少左端点和多少右端点，然后扫一遍更新答案就好了</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125;N[<span class="number">500000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> ,<span class="keyword">long</span> <span class="keyword">long</span>&gt; m; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>,l,r;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">int</span> t = m[l];</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="number">0</span>) &#123;N[++cnt].l=<span class="number">0</span>;N[cnt].r=<span class="number">0</span>;t=cnt;m[l]=t;&#125;;</span><br><span class="line">        N[t].l++;</span><br><span class="line">        t = m[r];</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="number">0</span>)&#123;N[++cnt].l=<span class="number">0</span>;N[cnt].r=<span class="number">0</span>;t=cnt;m[r]=t;&#125;</span><br><span class="line">        N[t].r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> la = (*m.<span class="built_in">begin</span>()).first<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (it = m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num!=<span class="number">0</span>)</span><br><span class="line">        ans[num]+=(*it).first-la<span class="number">-1</span>;</span><br><span class="line">        num+=N[(*it).second].l;</span><br><span class="line">        ans[num]++;</span><br><span class="line">        num-=N[(*it).second].r;</span><br><span class="line">        la = (*it).first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-CodeForces-479D-Long-Jumps"><a href="#C-CodeForces-479D-Long-Jumps" class="headerlink" title="C CodeForces 479D / Long Jumps"></a>C CodeForces 479D / Long Jumps</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个尺子和尺子上的每个刻度，给你两个数x和y,问要想量出这两个数，最少添加多少个刻度，怎么添加。(量出是指某两个刻度之差刚好等于需要的数)</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>先只去管一个刻度x，用前缀和加二分可以O(logn)的复杂度内判断以一个数为起点是否可以量出x。如果是能量出x，就直接去找能不能量出y;否则就加一个能量出x的刻度实验一下，看加的这个新刻度能不能量出y;如果怎么加都不能同时量出x,y,那就去看y需不需要量，之后输出答案即可。显然答案只可能是0,1,2个。<br><del>其实是想麻烦了，还有很多更优雅的做法，这里就不补了QAQ</del></p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anss[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,l,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;n,&amp;l,&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;sum[<span class="number">0</span>]);</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = lower_bound(sum+<span class="number">0</span>,sum+n+<span class="number">1</span>,x+sum[i])-sum;</span><br><span class="line">        <span class="keyword">if</span> (sum[t]==x+sum[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            anss[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> T = sum[i]+x;  </span><br><span class="line">        <span class="keyword">if</span> (anss[<span class="number">1</span>]==<span class="number">0</span>) anss[<span class="number">1</span>] = T;</span><br><span class="line">        <span class="keyword">int</span> tt;</span><br><span class="line">        <span class="keyword">if</span> (T&lt;=l)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (T&gt;=y)</span><br><span class="line">            &#123;</span><br><span class="line">              tt = lower_bound(sum+<span class="number">0</span>,sum+n+<span class="number">1</span>,T-y)-sum;</span><br><span class="line">              <span class="keyword">if</span> (sum[tt] == T-y)</span><br><span class="line">              &#123;</span><br><span class="line">                anss[<span class="number">1</span>] = T;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (T+y&lt;=l)</span><br><span class="line">            &#123;</span><br><span class="line">              tt = lower_bound(sum+<span class="number">0</span>,sum+n+<span class="number">1</span>,T+y)-sum;</span><br><span class="line">              <span class="keyword">if</span> (sum[tt]==T+y)</span><br><span class="line">              &#123;</span><br><span class="line">                anss[<span class="number">1</span>] =T;</span><br><span class="line">                flag =<span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T = sum[i]-x;</span><br><span class="line">        <span class="keyword">if</span> (T&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (T&gt;=y)</span><br><span class="line">        &#123;</span><br><span class="line">        tt = lower_bound(sum+<span class="number">0</span>,sum+n+<span class="number">1</span>,T-y)-sum;</span><br><span class="line">        <span class="keyword">if</span> (sum[tt] == T-y)</span><br><span class="line">        &#123;</span><br><span class="line">            anss[<span class="number">1</span>] = T;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (T+y&lt;=l)</span><br><span class="line">        &#123;</span><br><span class="line">        tt = lower_bound(sum+<span class="number">0</span>,sum+n+<span class="number">1</span>,T+y)-sum;</span><br><span class="line">        <span class="keyword">if</span> (sum[tt]==T+y)</span><br><span class="line">        &#123;</span><br><span class="line">            anss[<span class="number">1</span>] =T;</span><br><span class="line">            flag =<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag3 = <span class="literal">false</span>;</span><br><span class="line">        anss[<span class="number">2</span>] = y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (y+sum[i]&lt;=l)</span><br><span class="line">        &#123;</span><br><span class="line">        t = lower_bound(sum+<span class="number">0</span>,sum+n+<span class="number">1</span>,y+sum[i])-sum;</span><br><span class="line">        <span class="keyword">if</span> (sum[t]==y+sum[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flag3 = <span class="literal">true</span>;</span><br><span class="line">            anss[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (!flag3) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++) </span><br><span class="line">    <span class="keyword">if</span> (anss[i]!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,anss[i]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>BJTU2020寒训题组(2.19)</title>
    <url>/2020/02/21/ABCDEFG/</url>
    <content><![CDATA[<h1 id="A-CodeForces-919B-Perfect-Number"><a href="#A-CodeForces-919B-Perfect-Number" class="headerlink" title="A CodeForces 919B / Perfect Number"></a>A CodeForces 919B / Perfect Number</h1><p>问第k小的各个数位相加为10的数是多少，因为k特别小，暴力枚举就可。<br><a id="more"></a></p>
<h1 id="B-CodeForces-918C-The-Monster"><a href="#B-CodeForces-918C-The-Monster" class="headerlink" title="B CodeForces 918C / The Monster"></a>B CodeForces 918C / The Monster</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个包含’(‘,’)’和’?’的字符串，其中’?’可以让你去决定他是左括号还是右括号，问其有多少个子区间，可以通过调整里面的’?’,使得他成为一个合法括号串。<br>合法括号串定义如下：</p>
<ul>
<li>空串合法</li>
<li>如果s是个合法串，那么(s)也是个合法串</li>
<li>如果s是个合法串，t也是个合法串，那么st也是个合法串。<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><del>我人都快傻了，疯狂瞎DP</del>,因为N2的算法可以接受，所以暴力枚举子区间即可。<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5050</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=len;l++)</span><br><span class="line">    &#123;<span class="keyword">int</span> nn = <span class="number">0</span>,n2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r=l;r&lt;=len;r++)</span><br><span class="line">    &#123;   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s[r]==<span class="string">'('</span>)nn++;</span><br><span class="line">        <span class="keyword">if</span> (s[r]==<span class="string">')'</span>)nn--;</span><br><span class="line">        <span class="keyword">if</span> (s[r]==<span class="string">'?'</span>)nn--,n2++;</span><br><span class="line">        <span class="keyword">if</span> (nn==<span class="number">0</span>) ans++;</span><br><span class="line">        <span class="keyword">if</span> (nn&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n2&gt;<span class="number">0</span>)n2--,nn+=<span class="number">2</span>;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-CodeForces-919C-Seat-Arrangements"><a href="#C-CodeForces-919C-Seat-Arrangements" class="headerlink" title="C CodeForces 919C / Seat Arrangements"></a>C CodeForces 919C / Seat Arrangements</h1><p>各一个带障碍物的点阵，问有多少个连续的k个块，他们在同一行或者同一列上。如果没有读假题的话，就随便写了，注意k=1的情况即可。</p>
<h1 id="D-CodeForces-854C-Planning"><a href="#D-CodeForces-854C-Planning" class="headerlink" title="D CodeForces 854C / Planning"></a>D CodeForces 854C / Planning</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>本来有n架飞机，安排在1-n分钟，一分钟飞一架，结果因为天气原因延时了k分钟，现在需要你重新安排他们在k+1—k+n这n分钟起飞，一分钟飞一架。需要保证每架飞机起飞时间都不能早于原计划。每架飞机都有一个对应的属性值c,该飞机每延误一分钟起飞就扣钱c.现在问最少的扣钱数是多少，以及该扣钱数下的起飞方案。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>从左往右扫一遍，能起飞的飞机就放在一个堆里，需要起飞的时候就从堆里取一个花钱最多的起飞，贪心即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">300010</span>],sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> k,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,t;i&lt;=n+k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">            q.push(make_pair(t,i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[q.top().second] = i;</span><br><span class="line">            sum+=(<span class="keyword">long</span> <span class="keyword">long</span>)q.top().first*(i-q.top().second);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-CodeForces-1104D-Game-with-modulo"><a href="#E-CodeForces-1104D-Game-with-modulo" class="headerlink" title="E CodeForces 1104D /     Game with modulo"></a>E CodeForces 1104D /     Game with modulo</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>交互式题目，你每次输入两个数x，y,他会根据x,y在膜a意义下的大小返回给你大的呢个，你最多询问60次，让你回答a是多少。<br>具体输入格式见原题：<a href="http://codeforces.com/problemset/problem/1104/D" target="_blank" rel="noopener">Game with modulo</a></p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>我们想，如果a比x大，比y小的话，并且保证y是x的两倍，可以发现，返回的一定是x。这样的话，我们不断用类似这样的区间从小到大去找，如果x和y都小于a，那么会返回y,如果返回了x，那就说明a在[x,y]的区间内，之后在该区间二分去找就ok了。</p>
<p>该题特别的是，每次询问(即输出后)，需要fflush(stdout);一下，保证缓冲区的数据进入到检验程序中。(然而如果用cout就没问题了。)</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>]!=<span class="string">'s'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x=<span class="number">1</span>,y=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"? %lld %lld\n"</span>,x,y);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">'x'</span>) <span class="keyword">break</span>;</span><br><span class="line">            x = y;y&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = x,r = y;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"? "</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>&lt;&lt;mid&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">'x'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"? "</span>&lt;&lt;r&lt;&lt;<span class="string">" "</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">'x'</span>) ans = l;</span><br><span class="line">        <span class="keyword">else</span> ans = r;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"! "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-CodeForces-1113D-Sasha-and-One-More-Name"><a href="#F-CodeForces-1113D-Sasha-and-One-More-Name" class="headerlink" title="F CodeForces 1113D / Sasha and One More Name"></a>F CodeForces 1113D / Sasha and One More Name</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个回文串，你可以给他拆开成任意几个子串，需要你重新组合新的子串成为一个与原串不同的新回文串，问最少切几下。</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>首先如果原串只有一个字符组成那么怎么切都不可能。</p>
<p>特判掉上边以后，可以很容易的想到，不管啥回文串，左边切一刀，右边的相同位置切一刀，交换左右两边切下的，一定还是个回文串。所以我们直到答案最大也是2.</p>
<p>那么有没有可能是1呢？这个就好做了，暴力枚举每一个地方做切点，判断这么切是否符合题意即可，有这种切点答案就是1，没有就是2.</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><p>咕咕咕</p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>BJTU2020寒训题组(2.20)</title>
    <url>/2020/02/20/BJTU2020%E5%AF%92%E8%AE%AD%E9%A2%98%E7%BB%84-1/</url>
    <content><![CDATA[<h1 id="A-CodeForces-1206A-Choose-Two-Numbers"><a href="#A-CodeForces-1206A-Choose-Two-Numbers" class="headerlink" title="A CodeForces 1206A / Choose Two Numbers"></a>A CodeForces 1206A / Choose Two Numbers</h1><p>给两个数列，要求在两数列中各找出一个数，使得这两个数的和没有在两个数列中出现过。直接去枚举就行。。。签到题不谈了。。<br><a id="more"></a></p>
<h1 id="B-CodeForces-916C-Jamie-and-Interesting-Graph"><a href="#B-CodeForces-916C-Jamie-and-Interesting-Graph" class="headerlink" title="B CodeForces 916C    / Jamie and Interesting Graph"></a>B CodeForces 916C    / Jamie and Interesting Graph</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>要求构造一个图，是这个图满足：</p>
<ul>
<li>有n个点，m条边</li>
<li>所有边的长度在[1,1e9]之间</li>
<li>1到n的最短路长度是个质数</li>
<li>最小生成树的边权和是个质数</li>
<li>没有重边和自环</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>构造的方法应该有好多种。。。我单说我的。首先选一个足够大的质数p，然后先从1到n连成一条链，1到2的长度是p-(n-2),之后链上的其他边权是1,然后再去连其他无关紧要的边，只要边权大于等于p就好，凑够m条之后输出。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10000019</span></span><br><span class="line"><span class="keyword">int</span> X = <span class="number">10000019</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,X,X);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1 2 %d\n"</span>,X-(n<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,i,i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    m-=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                m--;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,i,j,X);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-CodeForces-919D-Substring"><a href="#C-CodeForces-919D-Substring" class="headerlink" title="C CodeForces 919D / Substring"></a>C CodeForces 919D / Substring</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个有向图，每个点有一个字母，一条路径的权值的定义为：该路径上所有点上的字母中出现次数最多的字母的出现次数。问图中的权值最大的路径的权值是多少。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>首先考虑如果图中有环的话答案一定是无穷的，所以将有环的情况特判掉。那么除了有环的情况，这个图本身就是一个有向无环图了，满足拓扑排序的条件，之后在拓扑序上做个dp即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">400000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;E[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">400000</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt].nxt = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">300010</span>][<span class="number">27</span>];</span><br><span class="line"><span class="keyword">int</span> du[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">300010</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) val[i+<span class="number">1</span>] = s[i]-<span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        add(x,y);</span><br><span class="line">        du[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (du[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line">        num++;</span><br><span class="line">        dp[x][val[x]]++;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</span><br><span class="line">        tmp = <span class="built_in">max</span>(tmp,dp[x][i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">            du[to]--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">26</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[to][j] = <span class="built_in">max</span>(dp[to][j],dp[x][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (du[to]==<span class="number">0</span>) q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num&lt;n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-CodeForces-454D-Little-Pony-and-Harmony-Chest"><a href="#D-CodeForces-454D-Little-Pony-and-Harmony-Chest" class="headerlink" title="D CodeForces 454D / Little Pony and Harmony Chest"></a>D CodeForces 454D / Little Pony and Harmony Chest</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给n个正整数组成的数列，每个数都不大于30，让你再构造一个长度为n的数列，使得两数列对应位置数字的差值的绝对值的和最小。并且保证构造数列中的数字两两互质，就是最小化——</p>
<script type="math/tex; mode=display">\sum_{i=1}^n|a_i-b_i|</script><p>输出你构造的序列。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>一个很不明显的状压dp。首先b数列可以选的数字肯定不超过58，因为有一个1总是比较优的选择，没必要再去选更大的。又因为要数字两两互质，所以同一个质数(质因子)只能被至多一个所选的数包含。而58以内的质数，一共就17个，所以大胆状压就可。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxz = <span class="number">1</span>&lt;&lt;<span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">57</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; p[<span class="number">101</span>][maxz];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][maxz];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">61</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">59</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">17</span>;j++)</span><br><span class="line">		<span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) t|=<span class="number">1</span>&lt;&lt;j; </span><br><span class="line">		m[i] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">58</span>;j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;maxz;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (m[j]&amp;k) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span> (dp[i<span class="number">-1</span>][k]+<span class="built_in">abs</span>(a[i]-j)&lt;dp[i][k|m[j]])</span><br><span class="line">				&#123;</span><br><span class="line">					dp[i][k|m[j]] = dp[i<span class="number">-1</span>][k]+<span class="built_in">abs</span>(a[i]-j);</span><br><span class="line">					p[i][k|m[j]].first = k;</span><br><span class="line">					p[i][k|m[j]].second = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">int</span> anss = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxz;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (anss&gt;dp[n][i])</span><br><span class="line">		&#123;</span><br><span class="line">			anss = dp[n][i];</span><br><span class="line">			id = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[i] = p[i][id].second;</span><br><span class="line">		id = p[i][id].first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-CodeForces-1239D-Catowice-City"><a href="#E-CodeForces-1239D-Catowice-City" class="headerlink" title="E CodeForces 1239D / Catowice City"></a>E CodeForces 1239D / Catowice City</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>有n个人,需要选择其中一些人当裁判，其他人当运动员(都至少有一人)。而如果有人当裁判的话，那么他熟悉的人就不能当运动员，现给出几组熟悉关系，让你找一个合法的方案。如果找不到就输出“No”</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>首先考虑，因为连边u-&gt;v的意义是u当裁判，v不能当运动员，所以当u是裁判的时候，v只能也是裁判。而如果这些边组成了一个强联通分量，那么这整个强联通分量就要么都是裁判，要么都是运动员了。所以我们tarjan缩点一下，如果全都缩成了一个点，那显然是不合法的，如果不是，那就随便去调整了。</p>
<p>调整的时候我们考虑，裁判是个没啥人愿意当的职业，因为当了裁判就会容易对后面的选择有些限制，那我们就让大部分人都去当运动员好勒。但是总得要有人当裁判。。。那我们可以选那些身份清白的人，就是那些出度为0的点，他们当了裁判也不会对他人的选择造成限制，选完之后输出答案即可。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;E[<span class="number">2000000</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">2000000</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt].to = y;</span><br><span class="line">    E[cnt].nxt = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">2000000</span>],low[<span class="number">2000000</span>],col[<span class="number">2000000</span>],colnum=<span class="number">0</span>,tm = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sta[<span class="number">2000000</span>],top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> du[<span class="number">2000000</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000001</span>],b[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1000001</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x] = ++tm;</span><br><span class="line">    sta[++top] = x;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[to]) &#123;tarjan(to);low[x]=<span class="built_in">min</span>(low[x],low[to]);&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[to]) low[x] = <span class="built_in">min</span>(low[x],dfn[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x]==dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        colnum++;v[colnum].<span class="built_in">clear</span>();v[colnum].push_back(x);</span><br><span class="line">        col[x] = colnum;vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(sta[top]!=x)</span><br><span class="line">        &#123;</span><br><span class="line">            v[colnum].push_back(sta[top]);</span><br><span class="line">            col[sta[top]]=colnum;</span><br><span class="line">            vis[sta[top]] = <span class="number">0</span>;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            head[i] = <span class="number">0</span>;</span><br><span class="line">            dfn[i] = <span class="number">0</span>;</span><br><span class="line">            low[i] = <span class="number">0</span>;</span><br><span class="line">            a[i] = b[i] =<span class="number">0</span>;</span><br><span class="line">            col[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tm=colnum=cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span> (x==y) <span class="keyword">continue</span>;</span><br><span class="line">            add(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(i);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (colnum==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=head[i];j;j=E[j].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to =E[j].to;</span><br><span class="line">            <span class="keyword">if</span> (col[to]==col[i]) <span class="keyword">continue</span>;</span><br><span class="line">            du[col[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=colnum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag&amp;&amp;du[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;v[i].<span class="built_in">size</span>();k++)</span><br><span class="line">                a[++a[<span class="number">0</span>]] = v[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;v[i].<span class="built_in">size</span>();k++)</span><br><span class="line">                b[++b[<span class="number">0</span>]] = v[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a[<span class="number">0</span>],b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[<span class="number">0</span>];i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b[<span class="number">0</span>];i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,b[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-CodeForces-1285F-Classical"><a href="#F-CodeForces-1285F-Classical" class="headerlink" title="F CodeForces 1285F /     Classical?"></a>F CodeForces 1285F /     Classical?</h1><p>搞不动的数学题，等以后有想法了再补趴(咕咕咕）<del>QAQ….wtcl</del></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>BJTU2020寒训题组(2.18)</title>
    <url>/2020/02/18/BJTU%E5%AF%92%E8%AE%AD%E9%A2%98%E7%BB%84-2-18/</url>
    <content><![CDATA[<h1 id="C-CodeForces-740D-Alyona-and-a-tree"><a href="#C-CodeForces-740D-Alyona-and-a-tree" class="headerlink" title="C CodeForces 740D / Alyona and a tree"></a>C CodeForces 740D / Alyona and a tree</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一棵树，每条边有边权，每条点有点权，规定点u被点v控制指，点u是点v的子树中的点，且点u的点权大于等于u，v之间路径的边权和。问每一个点，有多少个被他控制的点。<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>仔细一想，这里的边权和，一定是某种纵深的形式存在的，所以我们可以用一个栈去存他的路径，而对于每一个u，他能影响到的点，或者说他能够为之贡献答案的点，一定是当前栈中路径上的后k个点，而这个k可以用二分的做法找到，这样我们直到了k就知道点u会影响他的几代父亲，这样在树上做个差分，在他的第k个父亲处-1，在当前位置+1,然后直接统计即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> nxt,to,len;</span><br><span class="line">&#125;E[<span class="number">400001</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">200000</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt].len = t;</span><br><span class="line">    E[cnt].nxt = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> val[<span class="number">200010</span>],dep[<span class="number">200010</span>],ans[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sta[<span class="number">200010</span>],top=<span class="number">0</span>,dp[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r=top;</span><br><span class="line">    <span class="keyword">int</span> anss = top<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dep[sta[top]]-dep[sta[mid]]&lt;=x)</span><br><span class="line">        &#123;</span><br><span class="line">            anss = mid<span class="number">-1</span>;</span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">    sta[++top] = x;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; </span><br><span class="line">    num = check(val[x]);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;x&lt;&lt;" "&lt;&lt;num&lt;&lt;" "&lt;&lt;sta[num]&lt;&lt;endl;</span></span><br><span class="line">    dp[x]++;</span><br><span class="line">    dp[sta[num]]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        dep[to] = dep[x]+E[i].len;</span><br><span class="line">        dfs(to);</span><br><span class="line">        dp[x]+=dp[to];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[x] = dp[x]<span class="number">-1</span>;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a,t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;t);</span><br><span class="line">        add(a,i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-CodeForces-586F-Lizard-Era-Beginning"><a href="#F-CodeForces-586F-Lizard-Era-Beginning" class="headerlink" title="F CodeForces 586F/ Lizard Era: Beginning"></a>F CodeForces 586F/ Lizard Era: Beginning</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给n个三元组，每次可以选择其中的两个，最后要求每一维选出的和在相等的前提下最大，输出方案。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>折半搜索。。。u1s1,俺也是第一次写，意思差不多是每次搜一半，将这一半的结果保存下来(坐标是第二维和第一维的差以及第三维和第一维的差，用map做个映射)，然后再去搜令一半，与前一半的结果对照，对凑出来的合法的结果进行记录并取最大值的方案即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">30</span>][<span class="number">3</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; , <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> now[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">700000</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">700000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==n/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = m[make_pair(y,z)];</span><br><span class="line">        <span class="keyword">if</span> (t&amp;&amp;val[t]&gt;=X) <span class="keyword">return</span> ;</span><br><span class="line">        ++cnt;</span><br><span class="line">        m[make_pair(y,z)] = cnt;</span><br><span class="line">        val[cnt] = X;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">        f[cnt][i] = now[i];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    now[x] = <span class="number">0</span>;<span class="comment">//1 2</span></span><br><span class="line">    dfs1(x+<span class="number">1</span>,y+a[x][<span class="number">1</span>]-a[x][<span class="number">0</span>],z-a[x][<span class="number">0</span>],X+a[x][<span class="number">0</span>]);</span><br><span class="line">    now[x] = <span class="number">1</span>;<span class="comment">//1 3</span></span><br><span class="line">    dfs1(x+<span class="number">1</span>,y-a[x][<span class="number">0</span>],z+a[x][<span class="number">2</span>]-a[x][<span class="number">0</span>],X+a[x][<span class="number">0</span>]);</span><br><span class="line">    now[x] = <span class="number">2</span>;<span class="comment">//2 3</span></span><br><span class="line">    dfs1(x+<span class="number">1</span>,y+a[x][<span class="number">1</span>],z+a[x][<span class="number">2</span>],X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = m[make_pair(-y,-z)];</span><br><span class="line">        <span class="keyword">if</span> (!t) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (ans[<span class="number">1</span>]!=<span class="number">-1</span>&amp;&amp;Max&gt;=X+val[t]) <span class="keyword">return</span>;</span><br><span class="line">        Max = X+val[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">        ans[i] = f[t][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n/<span class="number">2</span>+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans[i] = now[i];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    now[x] = <span class="number">0</span>;<span class="comment">//1 2</span></span><br><span class="line">    dfs2(x+<span class="number">1</span>,y+a[x][<span class="number">1</span>]-a[x][<span class="number">0</span>],z-a[x][<span class="number">0</span>],X+a[x][<span class="number">0</span>]);</span><br><span class="line">    now[x] = <span class="number">1</span>;<span class="comment">//1 3</span></span><br><span class="line">    dfs2(x+<span class="number">1</span>,y-a[x][<span class="number">0</span>],z+a[x][<span class="number">2</span>]-a[x][<span class="number">0</span>],X+a[x][<span class="number">0</span>]);</span><br><span class="line">    now[x] = <span class="number">2</span>;<span class="comment">//2 3</span></span><br><span class="line">    dfs2(x+<span class="number">1</span>,y+a[x][<span class="number">1</span>],z+a[x][<span class="number">2</span>],X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a[i][<span class="number">0</span>],&amp;a[i][<span class="number">1</span>],&amp;a[i][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">    &#123;++cnt;</span><br><span class="line">    m[make_pair(<span class="number">0</span>,<span class="number">0</span>)]=cnt;</span><br><span class="line">    val[cnt] = <span class="number">0</span>;&#125;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(n/<span class="number">2</span>+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="number">1</span>]==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i]==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"LM\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans[i]==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"LW\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans[i]==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"MW\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别的题补不动了。。。<del>其实是我又菜又懒对⑧起!!QAQ</del></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>BJTU2020寒训题组(2.17)</title>
    <url>/2020/02/17/BJTU2020%E5%AF%92%E8%AE%AD%E9%A2%98%E7%BB%84/</url>
    <content><![CDATA[<h1 id="A-CodeForces-975B-Mancala"><a href="#A-CodeForces-975B-Mancala" class="headerlink" title="A CodeForces 975B / Mancala"></a>A CodeForces 975B / Mancala</h1><p>暴力模拟就好了，不谈<br><a id="more"></a></p>
<h1 id="B-CodeForces-898E-Squares-and-not-squares"><a href="#B-CodeForces-898E-Squares-and-not-squares" class="headerlink" title="B CodeForces 898E / Squares and not squares"></a>B CodeForces 898E / Squares and not squares</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给n个数(n为偶数)，你可以进行一种操作，每次可以使得某个数+1或-1,问最少要多少次操作，可以使得一半的是整数的平方，一半不是。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>对于每个数记录——</p>
<ul>
<li>如果他是平方数，最少操作几次变成非平方数</li>
<li>如果他是非平方数，最少操作几次变成平方数</li>
</ul>
<p>并记录平方数的个数。<br>最后根据记录数据与所差的平方数或者非平方数个数，优先选需要操作最少的几个数并统计答案即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">2000000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">2000000</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans2[<span class="number">2000000</span>],cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tt = <span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (tt*tt==a[i])&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (a[i]==<span class="number">0</span>) </span><br><span class="line">        ans2[++cnt2] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ans2[++cnt2] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t1 = a[i]-tt*tt;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t2 = (tt+<span class="number">1</span>)*(tt+<span class="number">1</span>)-a[i];</span><br><span class="line">            ans[++cnt] = <span class="built_in">min</span>(t1,t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num&gt;=n/<span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sort(ans2+<span class="number">1</span>,ans2+cnt2+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>,tt = num-n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;i++)</span><br><span class="line">        sum+=ans2[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sort(ans+<span class="number">1</span>,ans+cnt+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>,tt = n/<span class="number">2</span>-num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;i++)</span><br><span class="line">        sum+=ans[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-CodeForces-650B-Image-Preview"><a href="#C-CodeForces-650B-Image-Preview" class="headerlink" title="C CodeForces 650B / Image Preview"></a>C CodeForces 650B / Image Preview</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个环状的点，起点为1号，从1号可以向左到n号，n号想右可以到1号，达到一个点需要一些代价，切换到这个点需要a,在这个点本身需要b+1或者1,已经到达过的点再到达只需要花费a,问在所给代价范围内，能到达的点的个数最大是多少。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>尺取法，首先预处理只从1号向右的方向最远到达哪里，之后左端点每次向左移动一步，缩小右端点到可接受的范围内，以此类推，在所有合法区间中取最大的即可。<br>细节方面主要要仔细考虑清楚每个区间是先向左移动还是先向右移动。。。。具体见代码。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">600000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">600000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,a,b,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;n,&amp;a,&amp;b,&amp;T);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i]==<span class="string">'w'</span>) num[i] = b+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> num[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>]==<span class="string">'w'</span>) tmp+=b+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> tmp++;</span><br><span class="line">    <span class="keyword">if</span> (T&gt;=tmp) ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(tmp+a+num[r+<span class="number">1</span>]&lt;=T&amp;&amp;r+<span class="number">1</span>&lt;n) &#123;tmp+=a+num[r+<span class="number">1</span>];r++;&#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans,<span class="built_in">min</span>(n,r-l+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> kk = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans&gt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (r&lt;(n-i)) kk=<span class="number">1</span>;</span><br><span class="line">        tmp+=a*kk+num[i];</span><br><span class="line">        <span class="keyword">while</span>(tmp&gt;T&amp;&amp;r<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if (i==n-2) cout&lt;&lt;l-1&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">            tmp-=num[r];</span><br><span class="line">            <span class="keyword">if</span> (r&gt;(n-i)) tmp-=a;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (r&lt;=(n-i))</span><br><span class="line">                &#123;</span><br><span class="line">                    kk=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp-=<span class="number">2</span>*a;</span><br><span class="line">            &#125; </span><br><span class="line">            r--;</span><br><span class="line">        <span class="comment">//    if (i==n-2) cout&lt;&lt;l-1&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp&gt;T) <span class="keyword">break</span>;</span><br><span class="line">        l = i-n;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">min</span>(n,r-l+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="built_in">min</span>(n,ans));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-CodeForces-1278D-Segment-Tree"><a href="#D-CodeForces-1278D-Segment-Tree" class="headerlink" title="D CodeForces 1278D / Segment Tree"></a>D CodeForces 1278D / Segment Tree</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给n个节点，每个节点的属性为一个区间，区间相互重叠一部分的两个点之间连边(不是包含，也不是不重叠)，问最后的图是否是一个树。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>队长说的呢个离散化做的方法我给忘了QAQ,想起来再补。估计大同小异，我就说我做的….<del>背原题都背错了wtcl</del></p>
<p>首先把节点按左端点排序，然后挨个扫过去，每扫一个就把右端点放进一个set。在处理当前一个的时候，用set的lower_bound找到比当前节点左端点大或者相等的第一个点，从这个点往下找(因为set内是有序的)，每找一个点就连一下边，连边的时候用并查集稍微维护下，直到set中的值大于当前节点的右端点。</p>
<p>扫完一遍以后，检查并查集中的块的个数是不是一个，是不是连了n-1条边即可(在扫的过程中如果超过了n-1条边就可以直接跳出了，所以时间复杂度不会爆炸)。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> l,r;</span><br><span class="line">&#125;N[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct Node a,struct Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a.l==b.l)</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">	<span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> r,id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node2 A) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;r &lt; A.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;struct Node2&gt; s2;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);y=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x==y) <span class="keyword">return</span> ;</span><br><span class="line">	fa[x] = y;</span><br><span class="line">	sum--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i] = i;</span><br><span class="line">	sum=n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N[i].l,&amp;N[i].r);</span><br><span class="line">	sort(N+<span class="number">1</span>,N+n+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> <span class="title">tmp</span>;</span></span><br><span class="line">	tmp.r = N[<span class="number">1</span>].r;tmp.id = <span class="number">1</span>;</span><br><span class="line">	s2.insert(tmp);</span><br><span class="line">	<span class="built_in">set</span>&lt;struct Node2&gt;::iterator it;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		it = s2.<span class="built_in">end</span>();</span><br><span class="line">		it--;</span><br><span class="line">		<span class="keyword">if</span> ((*it).r&lt;N[i].l)&#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		tmp.r = N[i].l;</span><br><span class="line">		it = s2.lower_bound(tmp);</span><br><span class="line">		<span class="keyword">int</span> ttt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (;it!=s2.<span class="built_in">end</span>();it++)</span><br><span class="line">		<span class="keyword">if</span> ((*it).r&lt;=N[i].r) </span><br><span class="line">		&#123;</span><br><span class="line">			merge((*it).id,i);</span><br><span class="line">			ttt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		num+=ttt;</span><br><span class="line">		<span class="keyword">if</span> (num&gt;n<span class="number">-1</span>) &#123;flag = <span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">		tmp.r = N[i].r;</span><br><span class="line">		tmp.id = i;</span><br><span class="line">		s2.insert(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag&amp;&amp;num==n<span class="number">-1</span>&amp;&amp;sum==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-CodeForces-1037F-Maximum-Reduction"><a href="#E-CodeForces-1037F-Maximum-Reduction" class="headerlink" title="E CodeForces 1037F / Maximum Reduction"></a>E CodeForces 1037F / Maximum Reduction</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于下面的函数，给定初始数列a和整数k，问最后返回的答案是多少。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function z(array a, integer k):</span><br><span class="line">    if length(a) &lt; k:</span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        b &#x3D; empty array</span><br><span class="line">        ans &#x3D; 0</span><br><span class="line">        for i &#x3D; 0 .. (length(a) - k):</span><br><span class="line">            temp &#x3D; a[i]</span><br><span class="line">            for j &#x3D; i .. (i + k - 1):</span><br><span class="line">                temp &#x3D; max(temp, a[j])</span><br><span class="line">            append temp to the end of b</span><br><span class="line">            ans &#x3D; ans + temp</span><br><span class="line">        return ans + z(b, k)</span><br></pre></td></tr></table></figure>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>原函数的意思是每次都找所有的长度为k的子区间，将他们的最大值记录答案并再组成一个序列，不断递归，直到序列长度小于k.</p>
<p>题目都没咋看，直接听得吴队和蔡ls的题解，大概就是考虑每个数会对最终答案的贡献。</p>
<p>对于每个数，用单调栈取找包含他并且以他为最大值的最大的区间，这里听取蔡ls的建议，左边找大于等于的，右边找大于的，可以保证不重不漏。</p>
<p>这样我们知道了每个数统治的最大区间，我们还需要直到这个区间中会有多少个递归出的区间会包含这个数(显然包含这个数就是这个数最大)，这里我们可以用一个记忆化搜索的dp方法快速算出一个区间会递归出的所有的区间数，记为dp[len]。</p>
<p>记这个数统治的区间长度为len，其左边的长度为lenl,右边的长度为lenr,最终我们得到的就是<strong>dp[len]-dp[lenl]-dp[lenr]</strong>,即能贡献当前数的值的区间的个数，最后统计答案即可，注意取模。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">1000100</span>],r[<span class="number">1000100</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val,id;</span><br><span class="line">&#125;N[<span class="number">1000100</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000100</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">1000100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[x]&gt;<span class="number">0</span>) <span class="keyword">return</span> dp[x];</span><br><span class="line">    dp[x] = (dfs(x-k+<span class="number">1</span>)+x-k+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">return</span> dp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N[i].val);N[i].id=i;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;<span class="number">0</span>&amp;&amp;N[a[cnt]].val&lt;=N[i].val) cnt--;</span><br><span class="line">        <span class="keyword">if</span> (cnt==<span class="number">0</span>) l[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l[i] = N[a[cnt]].id+<span class="number">1</span>;</span><br><span class="line">        a[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;<span class="number">0</span>&amp;&amp;N[a[cnt]].val&lt;N[i].val) cnt--;</span><br><span class="line">        <span class="keyword">if</span> (cnt==<span class="number">0</span>) r[i] = n;</span><br><span class="line">        <span class="keyword">else</span> r[i] = N[a[cnt]].id<span class="number">-1</span>;</span><br><span class="line">        a[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = r[i]-l[i]+<span class="number">1</span>;</span><br><span class="line">        ans+=(dfs(len)-dfs(i-l[i])-dfs(r[i]-i))%mod*N[i].val%mod;</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 620(div2)</title>
    <url>/2020/02/16/Codeforces-Round-620-div2/</url>
    <content><![CDATA[<h1 id="A-Two-Rabbits"><a href="#A-Two-Rabbits" class="headerlink" title="A Two Rabbits"></a>A Two Rabbits</h1><p>签到题，不谈了</p>
<h1 id="B-Longest-Palindrome"><a href="#B-Longest-Palindrome" class="headerlink" title="B Longest Palindrome"></a>B Longest Palindrome</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给n个长度均为m的字符串，让你选取其中若干个，首尾相连组成一个回文串，输出最长的回文串长度以及对应的串.<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>因为数据范围很小，直接暴力两两配对，优先将一对对互相倒置的串记录下来（就是A串从左到右与B串从右到左看是一样的），显然这样的一对串只要放在任意回文串的两边依然是个回文串。然后如果某一串没有这样的匹配串，那我们要再检查一下他本身是不是个回文串，如果是的话我们就可以把它放在答案串的最中间(废物利用？笑~).</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">101</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1000</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][k]!=s[j][m-k<span class="number">-1</span>])&#123;flag = <span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                vis[i] = vis[j] = <span class="number">1</span>;</span><br><span class="line">                ans[++cnt] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">            <span class="keyword">if</span> (s[i][k]!=s[i][m<span class="number">-1</span>-k]) &#123;flag = <span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) ans[<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = cnt*m*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="number">0</span>]!=<span class="number">0</span>) len+=m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[ans[i]][j]);</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="number">0</span>]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[ans[<span class="number">0</span>]][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[ans[i]][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Air-Conditioner"><a href="#C-Air-Conditioner" class="headerlink" title="C Air Conditioner"></a>C Air Conditioner</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>餐馆老板贼牛，他奉行顾客至上的道理，连顾客喜欢的温度都要照顾到……老板有一个空调，他可以通过控制空调使得某一分钟之后室内温度+1，-1或者不变。有n个客人，每个客人有一个到来的时间以及其感到满意的温度区间，问老板能否通过控制空调，使得每个到来的顾客都感到满意?</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>输入已经对时间排好序了。我们考虑任意两个客人到来之间的时候，初始温度一定是第一个客人满意温度区间的一个子区间，就就为[l,r],再记两个客人到来的时间差为t,到第二个客人来的时候我们能控制温度到达的区间自然就是[l-t,r+t],用这个新区间与新客人的满意区间取一个交集，就是新的一个初始温度区间(当然如果没有交就是NO)。初始温度是m，则初始温度区间就是[m,m],然后按以上步骤扫一遍就好了。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lal,lar,lat;</span><br><span class="line">        lal = lar = m;</span><br><span class="line">        lat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>,t,l,r;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;t,&amp;l,&amp;r);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tt = t-lat;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ll = lal-tt;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> rr = lar+tt;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;ll&lt;&lt;" "&lt;&lt;rr&lt;&lt;endl;</span></span><br><span class="line">            lat = t;</span><br><span class="line">            <span class="keyword">if</span> (rr&lt;l||ll&gt;r) flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                lal = <span class="built_in">max</span>(ll,l);</span><br><span class="line">                lar = <span class="built_in">min</span>(rr,r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Shortest-and-Longest-LIS"><a href="#D-Shortest-and-Longest-LIS" class="headerlink" title="D Shortest and Longest LIS"></a>D Shortest and Longest LIS</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>让你构造一个全排列满足数据给的一个相邻元素的大小关系，并且要求最长上升子序列最长或者最短，输出相应的子序列。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>我是屁都不会的，听了章大佬的解法好不容易糊上的，就离谱。具体解法就是根据拓扑排序去填数(我写的是大数指向小数)，开一个优先度列，以左右位置序号为基准，从大到小挨个填数。用拓扑排序填出来的序列一定是合法的，至于为啥能使得LIS最大最小….咱是真的不懂QAQwtcl</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">3000005</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3000004</span>];</span><br><span class="line"><span class="keyword">int</span> to[<span class="number">400005</span>][<span class="number">3</span>],cnt[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">int</span> du[<span class="number">300005</span>];</span><br><span class="line"><span class="keyword">int</span> du2[<span class="number">300005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) du2[i]=du[i]=to[i][<span class="number">1</span>]=to[i][<span class="number">2</span>]=cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i<span class="number">-1</span>]==<span class="string">'&gt;'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				to[i][++cnt[i]] = i+<span class="number">1</span>;</span><br><span class="line">				du[i+<span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				to[i+<span class="number">1</span>][++cnt[i+<span class="number">1</span>]] = i;</span><br><span class="line">				du[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// cout&lt;&lt;s[i-1];</span></span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) du2[i] = du[i];</span><br><span class="line">		<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (du2[i]==<span class="number">0</span>) q.push(-i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = n;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x = -q.top();q.pop();</span><br><span class="line">			ans[x] = tmp;</span><br><span class="line">			tmp--;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt[x];j++)</span><br><span class="line">			&#123;</span><br><span class="line">			du2[to[x][j]]--;</span><br><span class="line">			<span class="keyword">if</span> (du2[to[x][j]]==<span class="number">0</span>) q.push(-to[x][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (du[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;to[2]&lt;&lt;endl;</span></span><br><span class="line">		tmp = n;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x = q.top();q.pop();</span><br><span class="line">			<span class="comment">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">			ans[x] = tmp;</span><br><span class="line">			tmp--;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt[x];j++)</span><br><span class="line">			&#123;</span><br><span class="line">			du[to[x][j]]--;</span><br><span class="line">			<span class="keyword">if</span> (du[to[x][j]]==<span class="number">0</span>) q.push(to[x][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-1-Trees-and-Queries"><a href="#E-1-Trees-and-Queries" class="headerlink" title="E 1-Trees and Queries"></a>E 1-Trees and Queries</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一棵树，每个询问在x,y两点之间加条边(下一次询问这条边就不在了),每条点和边可以经过任意次,问在a,b之间是否存在路线恰好经过k条边？</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>前置，树上差分，可以O(nlogn)预处理，然后每次在O(logn)的复杂度里查询任意两点间的距离。<br>然后我们回到这道题，因为每条边都可以经过任意次，所以如果a,b之间的某条路径长度与k奇偶性相同并且小于k,就一定可以在某一条边左右横跳，然后在到达终点的时候恰好经过k条边。</p>
<p>我们先不考虑加的一条边，那么原先的树上就一条路径，如果这条路径符合以上条件，就一定是可以的，如果不可以，那么我们考虑其他的路径，自然就是经过加过边而形成的那个环。假如原路径长度奇偶性与k不同，那么如果这个环是个奇环，就可以调整奇偶性了，或者原先的长度过长，经过环的一部分，可以使距离变短，也有可能使得答案合法。所以我们总共去检查三条路径：</p>
<ul>
<li>a,b之间的原本路径</li>
<li>a到x,x到y(就是1),y到b</li>
<li>a到y,y到x,x到b</li>
</ul>
<p>如果这三条路径都不靠谱，那就没有合法方案了。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;E[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> cnt,head[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt].nxt = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100005</span>][<span class="number">21</span>],dep[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = fa;dep[x] = dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]]&gt;=dep[y])</span><br><span class="line">        x = f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x][i]!=f[y][i])</span><br><span class="line">        x=f[x][i],y=f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        add(x,y);</span><br><span class="line">        add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    f[j][i] = f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// cout&lt;&lt;dep[5]&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,a,b,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;x,&amp;y,&amp;a,&amp;b,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> dis = dep[a]+dep[b]-dep[lca(a,b)]*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis&lt;=k&amp;&amp;(k-dis)%<span class="number">2</span>==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        dis = dep[a]+dep[x]-dep[lca(a,x)]*<span class="number">2</span>+<span class="number">1</span>+dep[b]+dep[y]-dep[lca(b,y)]*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis&lt;=k&amp;&amp;(k-dis)%<span class="number">2</span>==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        dis = dep[b]+dep[x]-dep[lca(b,x)]*<span class="number">2</span>+<span class="number">1</span>+dep[a]+dep[y]-dep[lca(a,y)]*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis&lt;=k&amp;&amp;(k-dis)%<span class="number">2</span>==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);<span class="keyword">continue</span>;&#125;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Codeforces Round619&amp;&amp;ECR82(div2)</title>
    <url>/2020/02/14/Codeforces-Round619-ECR82-div2/</url>
    <content><![CDATA[<p><strong>咕了一场，还有一场是太菜了掉分了，做的都不多，就挤一块趴QAQ</strong><br><a id="more"></a></p>
<h1 id="Educational-Codeforces-Round-82"><a href="#Educational-Codeforces-Round-82" class="headerlink" title="Educational Codeforces Round 82"></a>Educational Codeforces Round 82</h1><h2 id="A-Erasing-Zeroes"><a href="#A-Erasing-Zeroes" class="headerlink" title="A Erasing Zeroes"></a>A Erasing Zeroes</h2><p>问所给01串中1之间的所有0的个数，没啥好说的</p>
<h2 id="B-National-Project"><a href="#B-National-Project" class="headerlink" title="B National Project"></a>B National Project</h2><p>emmmmmm,普通的小学数学题，也没啥好说的</p>
<h2 id="C-Perfect-Keyboard"><a href="#C-Perfect-Keyboard" class="headerlink" title="C Perfect Keyboard"></a>C Perfect Keyboard</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>主角想构造一个懒人键盘，使得他在打某一串字符串的时候能够几乎不移动手指。输入一串小写英文字符串，如果有符合题意的键盘，就输出这个键盘(一定顺序的某个26英文字母全排列)，要求这个输入的串的任意两个相邻字符，在键盘上也相邻。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>将输入串的每两个相邻字母用链表连接起来，最后输出即可，注意一下几种非法键盘：</p>
<ul>
<li>某个字母和2个以上的其他种类字母相邻</li>
<li>所有的有关字母连接起来之后成环</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">1000110</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1000110</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> cnt;</span><br><span class="line">   <span class="keyword">int</span> ch[<span class="number">30</span>];</span><br><span class="line">   Node()&#123;</span><br><span class="line">       cnt = <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;N[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">   <span class="keyword">int</span> t;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">   <span class="keyword">while</span>(t--)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) N[i].cnt = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag2 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=N[s[i]-<span class="string">'a'</span>].cnt;j++)</span><br><span class="line">            <span class="keyword">if</span> (N[s[i]-<span class="string">'a'</span>].ch[j]==s[i+<span class="number">1</span>]-<span class="string">'a'</span>) flag2 = <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">if</span> (flag2) <span class="keyword">continue</span>;</span><br><span class="line">            N[s[i]-<span class="string">'a'</span>].ch[++N[s[i]-<span class="string">'a'</span>].cnt] = s[i+<span class="number">1</span>]-<span class="string">'a'</span>;</span><br><span class="line">            N[s[i+<span class="number">1</span>]-<span class="string">'a'</span>].ch[++N[s[i+<span class="number">1</span>]-<span class="string">'a'</span>].cnt] = s[i]-<span class="string">'a'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span> (N[i].cnt&gt;<span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span> (N[i].cnt==<span class="number">0</span>) &#123;</span><br><span class="line">            root = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (N[i].cnt==<span class="number">1</span>) num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="number">-1</span>&amp;&amp;num&gt;<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = N[root].ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> la = root;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,root+<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">while</span>(N[nx].cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,nx+<span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">int</span> nxx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N[nx].cnt;i++)</span><br><span class="line">                <span class="keyword">if</span> (N[nx].ch[i]!=la) nxx = N[nx].ch[i];</span><br><span class="line">                la = nx;</span><br><span class="line">                nx = nxx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,nx+<span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span> (N[i].cnt==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>,<span class="string">'a'</span>+i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);    </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Fill-The-Bag"><a href="#D-Fill-The-Bag" class="headerlink" title="D. Fill The Bag"></a>D. Fill The Bag</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>用所给的一些货物，将给定的一个“背包”装满。具体来说，就是给一个数列，让你在这些数中找任意个数，使得他们相加为给定的n。规定这些数一定是2的幂次方，我们可以对这些数进行div操作，即将某数拆开，得到到两个这样的数，每个数都是原值的一半。问，能否凑满“背包”，如果能，输出最少需要几次div操作。</p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>因为一共也就六十几种数，开个权值数组记录每种数的数量然后对于目标数字从低位到高位去凑就好了。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++) num[i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&gt;(<span class="number">1l</span>l&lt;&lt;p)) p++;</span><br><span class="line">            num[p]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((n&amp;(<span class="number">1l</span>l&lt;&lt;cnt))==<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                num[cnt]+=num[cnt<span class="number">-1</span>]/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=cnt;i&lt;=<span class="number">62</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i]&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    n-=(<span class="number">1l</span>l&lt;&lt;cnt);</span><br><span class="line">                    ans+=i-cnt;</span><br><span class="line">                    num[i]--;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k=i<span class="number">-1</span>;k&gt;=cnt;k--)&#123;</span><br><span class="line">                        p&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num[cnt]+=p;</span><br><span class="line">                    num[cnt]--;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Codeforces-Round-619"><a href="#Codeforces-Round-619" class="headerlink" title="Codeforces Round 619"></a>Codeforces Round 619</h1><h2 id="A-Three-Strings"><a href="#A-Three-Strings" class="headerlink" title="A Three Strings"></a>A Three Strings</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给三个长度相等的字符串a,b,c,对于每一位，必须让c串与a串或者b串交换，问最后能否使得a串与b串相同。</p>
<h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>显然对于每一位必须满足c串与a串或者b串相同，O（n）扫一遍即可</p>
<h2 id="B-Motarack’s-Birthday"><a href="#B-Motarack’s-Birthday" class="headerlink" title="B Motarack’s Birthday"></a>B Motarack’s Birthday</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一组有空缺的数列，将所有的空缺都变成k,问k为多少时原数列相邻数字的差值的最大值最小，求这个k和差值。</p>
<h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>感性思考一下，肯定是个关于k的单峰函数，三分一下k就好了。<del>然而我只会写假三分QAQ</del></p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> nx = a[i];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> la = a[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx==<span class="number">-1</span>) nx = x;</span><br><span class="line">        <span class="keyword">if</span> (la==<span class="number">-1</span>) la = x;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">abs</span>(la-nx));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">   <span class="keyword">int</span> t;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">   <span class="keyword">while</span> (t--)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1e16</span>,ansid=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(r-l&gt;<span class="number">2</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">long</span> <span class="keyword">long</span> lmid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">long</span> <span class="keyword">long</span> rmid = (r+lmid)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">long</span> <span class="keyword">long</span> lans = check(lmid);</span><br><span class="line">           <span class="keyword">long</span> <span class="keyword">long</span> rans = check(rmid);</span><br><span class="line">           <span class="keyword">if</span> (lans&lt;=rans)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (lans&lt;ans)</span><br><span class="line">               &#123;</span><br><span class="line">                   ans = lans;</span><br><span class="line">                   ansid = lmid;</span><br><span class="line">               &#125;</span><br><span class="line">               r = rmid;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (rans&lt;ans)</span><br><span class="line">               &#123;</span><br><span class="line">                   ans = rans;</span><br><span class="line">                   ansid = rmid;</span><br><span class="line">               &#125;</span><br><span class="line">               l = lmid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> xx = check(i);</span><br><span class="line">            <span class="keyword">if</span> (xx&lt;ans)&#123;</span><br><span class="line">                ans = xx;</span><br><span class="line">                ansid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,ans,ansid);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Ayoub’s-function"><a href="#C-Ayoub’s-function" class="headerlink" title="C Ayoub’s function"></a>C Ayoub’s function</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>至今没读题2333，大概是有一个01串，给你其中1的个数m，然后让你去构造一个01串使得其中包含1的子区间的个数最多，输出这个数字。</p>
<h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>正向思考并不好像，只能感觉均分0是对的<del>而且并不怎么好调QAQwtcl</del>。所以我们反向思考，总的子区间数是固定的，我们只需要减去不符合条件的区间的个数，即只包含0的区间的个数。而这种区间一定出现在都是0的某个块内，假定有个0块有x个0，那么其中的非法子区间就是x/*(x-1)/2.这样我们发现，原题就等于在m+1个位置里加0,而且对于每个位置，加第一个0的时候贡献是1，第二个是2，第三个是3，以此类推，所以显然贪心的策略是使得各个位置的0的个数尽量均分。写起来也很愉快。。。。</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = (n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = (n-m)/(m+<span class="number">1</span>);</span><br><span class="line">        ans-=(t+<span class="number">1</span>)*t/<span class="number">2</span>*(m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num2 = (n-m)%(m+<span class="number">1</span>);</span><br><span class="line">        ans-=(t+<span class="number">1</span>)*num2;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Time-to-Run"><a href="#Time-to-Run" class="headerlink" title="Time to Run"></a>Time to Run</h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个n行m列的网格，每两个相邻方格之间有两条方向相反的单向道路，每个道路都只能走一次，问是否有办法移动k次(起点在左上角)，如果有，输出走的方案。<br><img src="https://espresso.codeforces.com/f35e95cc05e4660c150ae66f77e4a78e62a4e24b.png" alt="AA"></p>
<h3 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h3><p>由入度去看的话，并没有入度为奇数的点，所以根据欧拉路径的理论，一定有一笔画的方法，也就是有办法每条路径都经过一遍。所以随便试一试总能找到一种方法。。。我是一行一行往下来回扫着画，最后写下来跟个大模拟差不许多了QAQ,具体见代码。</p>
<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++) num[i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&gt;(<span class="number">1l</span>l&lt;&lt;p)) p++;</span><br><span class="line">            num[p]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((n&amp;(<span class="number">1l</span>l&lt;&lt;cnt))==<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                num[cnt]+=num[cnt<span class="number">-1</span>]/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=cnt;i&lt;=<span class="number">62</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i]&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    n-=(<span class="number">1l</span>l&lt;&lt;cnt);</span><br><span class="line">                    ans+=i-cnt;</span><br><span class="line">                    num[i]--;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k=i<span class="number">-1</span>;k&gt;=cnt;k--)&#123;</span><br><span class="line">                        p&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num[cnt]+=p;</span><br><span class="line">                    num[cnt]--;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 618(div2)</title>
    <url>/2020/02/10/Codeforces-Round-618-div2/</url>
    <content><![CDATA[<h1 id="A-Non-zero"><a href="#A-Non-zero" class="headerlink" title="A Non-zero"></a>A Non-zero</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个序列，你只可以做一种操作，使得某个序列中的数+1,问最少几次操作可以使得序列中每个数都不为0，所有数的和也不为0.<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>对于一开始等于0的数肯定要+1操作的，然后如果所有的0都处理完了之后，总和sum等于0，这时肯定数列中有正数，给这个正数+1,最后输出操作数即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            a[i]++;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125; </span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum==<span class="number">0</span>) ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Assigning-to-Classes"><a href="#B-Assigning-to-Classes" class="headerlink" title="B Assigning to Classes"></a>B Assigning to Classes</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长度为2n的序列，将其划分为两个奇数长度序列，取每个序列的中位数做差，问取一个合适的分法，使中位数之差绝对值最小，输出差值的绝对值。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>手模一一下下，首先发现最后取到的中位数一定是排序后序列左半部分有一个，右半部分有一个，然后两个数又至少有一个是<strong>a[n]</strong>或者<strong>a[n+1]</strong>,仔细一思考，肯定没有差值比<strong>a[n+1]-a[n]</strong>更小的了，所以排序号后输出答案即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+n+n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,a[n+<span class="number">1</span>]-a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Anu-Has-a-Function"><a href="#C-Anu-Has-a-Function" class="headerlink" title="C  Anu Has a Function"></a>C  Anu Has a Function</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>规定操作f: $f(x,y) = (x|y)-y$,给你一个序列$[a_1,a_2,a_3,a_4,…,a_n]$,最终让你给这个序列重新排序使得 </p>
<script type="math/tex; mode=display">f(f(...f(f(a_1,a_2),a_3),...a_{n-1}),a_n)</script><p>最小。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>因为是按位操作的，所以我们只是按每个数位去考虑，然后想到，<br>0|0 - 1 = 0，<br>0|1 - 1 = 0,<br>1|1 - 1 = 0,<br>1|0 - 0 = 1,<br>所以只有1与0进行运算才得1，所以显然只有当某一位上只有一个数有1,其他数都是0，且该数在第一个位置，才能使得结果对应位上为1。最后解法就显而易见，从最高位往后扫，第一个符合条件的数出现的时候就把他调到第一个，别的都不用管就行。<br>ps:经战神指点，还有个O(N)的做法，f操作可以写成f(a,b) = a&amp;(~b),所以结果就是求$a_1&amp;(~a_2)&amp;(~a_3)&amp;…&amp;(~a_n)$,记一个~a的前缀并和后缀并，然后O(N)枚举即可。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">32</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1l</span>l&lt;&lt;i;</span><br><span class="line">        <span class="keyword">int</span> tmpid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span> (tmp&amp;a[i]) </span><br><span class="line">        &#123;cnt++;</span><br><span class="line">        tmpid = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(a[<span class="number">1</span>],a[tmpid]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld "</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Aerodynamic"><a href="#D-Aerodynamic" class="headerlink" title="D Aerodynamic"></a>D Aerodynamic</h2><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一组点确定的多边形P，移动P使得点（0,0）在多边形内部或者边缘，所有合法的移动的P覆盖的区域为T,问T是否与P相似。</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p><del> 真就试胆题白QAQ </del><br>模一下最后一组样例<del>太明显了</del>,就是判断原图是否对边平行且相等。<br>过了之后从结论出发感性分析一下，对于多边形的任意一条线段，想象（0,0）在该线段上移动，然后留下的图形中，离该线段最远的点留下的一定是个线段，这个线段也一定是最终图形的一条边，而如果只是一个点的话，那么一定不合法，因为P在这个方向上是一个点，而产生的图形在这个方向上是个边。由此我们知道原图形这条线段的对面也一定是条平行线，又因为产生的图形在这两个方向上的平行线一定是相等的，所以原图形也一定对边相等（而且实际上一定是1:2的放大）。所以得出结论，对边平行相等。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x[<span class="number">100010</span>],y[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> chax[<span class="number">100010</span>],chay[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">  chax[<span class="number">0</span>] = x[<span class="number">1</span>]-x[n];</span><br><span class="line">  chay[<span class="number">0</span>] = y[<span class="number">1</span>]-y[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    chax[i] = x[i+<span class="number">1</span>]-x[i];</span><br><span class="line">    chay[i] = y[i+<span class="number">1</span>]-y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n%<span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  n/=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (chax[i]+chax[i+n]!=<span class="number">0</span>||chay[i]+chay[i+n]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Water-Balance"><a href="#E-Water-Balance" class="headerlink" title="E Water Balance"></a>E Water Balance</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个整数序列，你可以进行任意次操作，每次操作选定一个区间，使得该区间里的每个数都变为他们的平均值，问你经过若干次操作后得到的字符典序最小的序列是啥。</p>
<h2 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h2><p>字符典序小就是说要靠前的数尽量小，这样的话我们考虑一个暴力算法：</p>
<p>从后往前扫，扫到某一个位置，再从这个位置往后扫，记录当前扫过的和sum,与扫过的数的个数cnt,如果sum/cnt比扫到的这个数要打就继续往后扫并把这个数记录在sum和cnt里，否则停止(因为完成后的序列一定是单调不降的，所以后边的数也一定不能符合条件)。</p>
<p>最后得到的序列一定是答案，正确肯定是正确的，但是太慢了，$O(N^2)$的算法肯定过不了1e6;</p>
<p>我们考虑优化他：</p>
<p>可以想到我们在从某个位置向后扫的时候，后边的东西一定是一个又一个相同数字组成的块，这样的话我们把这些块合并成一个节点，这个节点记录块中的数的值和数量即可，这样用一个类似单调栈的写法，每次扫描栈顶的一个节点，该节点符合内部数字的值比当前sum/cnt要小，就从栈顶取这个节点，与新节点合并，并继续向下扫，否则就将该节点放在栈顶。</p>
<p>最后我们从栈顶往下把序列输出出来即可。</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">1000110</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1000110</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> sum,cnt;</span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">&#125;N[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> sta[<span class="number">1000110</span>],top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sta[++top] = <span class="number">1</span>;</span><br><span class="line">    N[<span class="number">1</span>].cnt = <span class="number">1</span>;</span><br><span class="line">    N[<span class="number">1</span>].sum = a[n];</span><br><span class="line">    N[<span class="number">1</span>].val = a[n];</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> cnt = <span class="number">1</span>;</span><br><span class="line">        sum = a[i];</span><br><span class="line">        <span class="keyword">while</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum/cnt&gt;N[sta[top]].val)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=N[sta[top]].sum;</span><br><span class="line">                cnt+=N[sta[top]].cnt;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;    </span><br><span class="line">        N[++ct].cnt = cnt;</span><br><span class="line">        N[ct].sum = sum;</span><br><span class="line">        sum=sum/cnt;</span><br><span class="line">        N[ct].val = sum;</span><br><span class="line">        sta[++top] = ct;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = sta[top];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N[x].cnt;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>,N[x].val);</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>我这种菜鸡竟然都能AK了QAQ</del></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>主席树入门总结</title>
    <url>/2020/02/05/%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h1><p>线段树,前缀和<br><a id="more"></a></p>
<h1 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h1><p>之所以叫主席树好像是因为发明他的大佬名字缩写是hjt，所以后来就叫主席树了2333</p>
<p>主席树其实就是可持久化线段树，通俗来讲，就是可以访问之前历史版本的线段树。比如你在线段树里插入了1,2,3,4,5，如果是普通的线段树，你只能对插入5之后的线段树进行操作，而主席树可以做到对之前任何一次操作时的线段树进行访问。</p>
<p>虽然听上去满牛的，但是如果只是实现这个可持久化的功能的话其实思路也只有一个，就是在每次操作前都将当前的线段树保存下来，然后再复制出一棵新树，再进行操作就是了。</p>
<p>然而肯定是不能暴力去做这个的，时空复杂度爆炸，主席树就是对于这个过程进行的一种优化。</p>
<p>可以想象得到，在普通的线段树上，每次进行修改操作时，收影响的其实只是一条从根节点到对应叶结点的那一条路径而已。举个栗子，对于这么长度为4的[1,4]区间的线段树，我们去修改3时，修改的点实际只有三个，如下图：<br><img src="/2020/02/05/%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/A.png" alt="A"><br>所以我们能否只针对受影响的几个点去操作呢？当然可以，动态开点就好了，对于受影响的点都动态开一遍，不变的点就原封不动的接过来即可。这样我们每一个版本的线段树都会有一个对应的根，我们根据特定的根，就可以去访问对应版本的线段树了，所以主席树修改就类似于下面这样：<br><img src="/2020/02/05/%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/B.jpg" alt="B"><br>这样我们顺着黑色[1,4]节点可以访问修改前版本的线段树，顺着蓝色[1,4]节点则可以访问修改后版本的线段树，多次修改同理。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>如果是前缀和的话，两个不同位置的前缀和相减，我们就可以得到这两个位置之间的所有数的和，而主席树也有类似的特点。</p>
<p>假如我们现在有一个主席树，我们取x操作时的线段树，在取y操作时的线段树，我们将两棵树同时向下查询，那么两树每个对应节点的差值，就是只进行x到y操作时的线段树状态。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">洛谷模板题</a><br>给一段序列，为序列中指定区间第k小的数。<br>此题结合主席树与权值线段树可做。</p>
<p>首先考虑，如果是问整段序列第k小的数~我知道可以sort，我又不傻QAQ~,我们用权值线段树去做怎么做？</p>
<p>我们把每个数在数值对应的位置插入，线段树的叶子节点存对应权值的数的个数，这样我们查询第k大的时候只要在线段树上查找就好了，如果左区间的数的个数sum大于k，那就去左区间找，否则就去右区间找k-sum小的数。这样很快就找到了。</p>
<p>但是有个问题，如果权值过大，线段树存不下怎么办?离散化一下就好了。</p>
<p>好的，我们回到原题，对应区间怎么做？用主席树先把对应的区间扣出来再按上边的方法做就好了。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> rt[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;N[NN&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R=++sz;   </span><br><span class="line">    N[R].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span> R;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    N[R].l=build(l,mid);</span><br><span class="line">    N[R].r=build(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rr = ++sz;</span><br><span class="line">    N[rr].sum = N[R].sum+<span class="number">1</span>;</span><br><span class="line">    N[rr].l = N[R].l;</span><br><span class="line">    N[rr].r = N[R].r;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span> rr;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;=mid)</span><br><span class="line">    N[rr].l = update(N[R].l,l,mid,p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    N[rr].r = update(N[R].r,mid+<span class="number">1</span>,r,p);</span><br><span class="line">    <span class="keyword">return</span> rr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> sum = N[N[rr].l].sum-N[N[ll].l].sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=sum)</span><br><span class="line">    <span class="keyword">return</span> query(N[ll].l,N[rr].l,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> query(N[ll].r,N[rr].r,mid+<span class="number">1</span>,r,k-sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]=a[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len_p = unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">    rt[<span class="number">0</span>]=build(<span class="number">1</span>,len_p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(b+<span class="number">1</span>,b+len_p+<span class="number">1</span>,a[i])-b;</span><br><span class="line">        rt[i] = update(rt[i<span class="number">-1</span>],<span class="number">1</span>,len_p,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l,r,k;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> p = query(rt[l<span class="number">-1</span>],rt[r],<span class="number">1</span>,len_p,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>进阶题目：<br><a href="https://www.luogu.com.cn/problem/P2633" target="_blank" rel="noopener">Count on a tree</a><br>序列搬到了树上，树上差分可做。</p>
<p>树上差分：<br>对每个点记一个sum[i],作为从根节点到该节点的路径的前缀和，这样对于任意两个点u，v，两点之间路径上的东西就是：</p>
<script type="math/tex; mode=display">sum\[u\]+sum\[v\]-sum\[lca(u,v)\]-sum\[fa\[lca(u,v)\]\]</script><p>因为主席树也有类似前缀和的性质，所以把上边的前缀和改成主席树就好了。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">&#125;E[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;N[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> rt[maxn],sz=<span class="number">0</span>,len_p;</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> val[maxn],f[maxn][<span class="number">20</span>],dep[maxn];</span><br><span class="line"><span class="keyword">int</span> mt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;R,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R = ++sz;</span><br><span class="line">    N[R].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(N[R].l,l,mid);</span><br><span class="line">    build(N[R].r,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = ++sz;</span><br><span class="line">    N[R].l = N[pre].l;</span><br><span class="line">    N[R].r = N[pre].r;</span><br><span class="line">    N[R].sum = N[pre].sum+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> R;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;=mid) N[R].l = update(N[R].l,l,mid,p);</span><br><span class="line">    <span class="keyword">else</span> N[R].r = update(N[R].r,mid+<span class="number">1</span>,r,p);</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    E[++cnt].nxt = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = fa;</span><br><span class="line">    dep[x] = dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[y]&gt;dep[x]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]]&gt;=dep[y])</span><br><span class="line">        x = f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x==y) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x][i]==f[y][i]) <span class="keyword">continue</span>;</span><br><span class="line">        x = f[x][i];y=f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = lower_bound(mt+<span class="number">1</span>,mt+len_p+<span class="number">1</span>,val[x])-mt;</span><br><span class="line">    rt[x] = update(rt[fa],<span class="number">1</span>,len_p,p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> Lca,<span class="keyword">int</span> fa,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = N[N[u].l].sum+N[N[v].l].sum-N[N[Lca].l].sum-N[N[fa].l].sum;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=sum) <span class="keyword">return</span> query(N[u].l,N[v].l,N[Lca].l,N[fa].l,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  query(N[u].r,N[v].r,N[Lca].r,N[fa].r,mid+<span class="number">1</span>,r,k-sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) mt[i] = val[i];</span><br><span class="line">    sort(mt+<span class="number">1</span>,mt+n+<span class="number">1</span>);</span><br><span class="line">    len_p = unique(mt+<span class="number">1</span>,mt+n+<span class="number">1</span>)-mt<span class="number">-1</span>;</span><br><span class="line">    build(rt[<span class="number">0</span>],<span class="number">1</span>,len_p);</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    f[j][i] = f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> u,v,k,last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;k);</span><br><span class="line">        u^=last;</span><br><span class="line">        <span class="keyword">int</span> Lca = lca(u,v);</span><br><span class="line">        <span class="keyword">int</span> fa = f[Lca][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = query(rt[u],rt[v],rt[Lca],rt[fa],<span class="number">1</span>,len_p,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mt[ans]);</span><br><span class="line">        last = mt[ans];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>~lca板子我竟然还记得QAQ~</p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeforcesRound 616(Div2)</title>
    <url>/2020/02/03/CodeforcesRound-616-Div2/</url>
    <content><![CDATA[<h1 id="A-Even-But-Not-Even"><a href="#A-Even-But-Not-Even" class="headerlink" title="A Even But Not Even"></a>A Even But Not Even</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一串数字字符串，代表一个大数字，你可以删除其中的一些数字，也可以不删，但是不能全删。问能否通过删除得到一个数字满足：</p>
<ul>
<li>是奇数</li>
<li>各数位和不是奇数</li>
</ul>
<a id="more"></a>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>仔细思考，决定他是不是奇数的是他的最后一位，决定他数位和是不是奇数的是各个数位的奇数的个数(显然一个数加减一个偶数不会影响他的奇偶性)，最终我们需要的就是末尾是奇数，总共个数位有偶数个奇数的数，然后暴力去构造就好了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        sum+=s[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span> ((s[i]-<span class="string">'0'</span>)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span> ((s[i]-<span class="string">'0'</span>)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i] = <span class="string">'#'</span>; </span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">                    <span class="keyword">if</span> (s[i]==<span class="string">'0'</span>) &#123;</span><br><span class="line">                        s[i]=<span class="string">'#'</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;flag = <span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);   </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Array-Sharpening"><a href="#B-Array-Sharpening" class="headerlink" title="B Array Sharpening"></a>B Array Sharpening</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个序列，你可以对序列中的每个数做减法操作，减掉任意数(结果不能为负数)，问你能否构造出一个序列满足————存在一个k(1\&lt;=k\&lt;=n),使得 $a_1\<a_2\<...\<a_k\>…>a_{n-1}>a_n$</a_2\<...\<a_k\></p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>题目具体来说，就是存在某个数左边是严格递增序列，右边是严格递减序列。这样的话我们每次只考虑一边，设dpl[i]代表$a_1$到$a_i$能否形成严格递增序列，dpr[i]代表$a_n$到$a_i$能否形成严格递增序列。我们考虑状态转移(仅以左边为例，右边同理)：</p>
<ul>
<li>如果1~i-1不能形成严格递增序列，那么1~i显然也不能</li>
<li>如果1~i-1能形成严格递增序列，但是$a_i$\&lt;i-1，则也不可能符合条件</li>
</ul>
<p>最后O(n)扫一遍，看是否有左右两边都符合条件的位置即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dpl[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> dpr[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        dpl[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dpl[i<span class="number">-1</span>]==<span class="number">-1</span>) dpl[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i]&gt;=i<span class="number">-1</span>) dpl[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dpl[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        dpr[n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dpr[i+<span class="number">1</span>]==<span class="number">-1</span>) dpr[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i]&gt;=n-i) dpr[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dpr[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span> (dpl[i]==<span class="number">1</span>&amp;&amp;dpr[i]==<span class="number">1</span>) &#123;flag = <span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Mind-Control"><a href="#C-Mind-Control" class="headerlink" title="C Mind Control"></a>C Mind Control</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>有n个数，有n-1个人，n-1个人排成一队，每次队首选择最左边或者最右边一个数字拿走。主角排在第m个位置，他可以控制k个人说服他们去选择左边或者右边，其他人则无法控制，他们可以选择任意某一边（他们不会考虑数字的大小），现在问你，主角在合理劝说k个人之后，能拿到的最大的x是多少（x指在最优策略下他能拿到的最小的数）</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>~怎么感觉我把它翻译得更饶了QAQ~其实就是轮到主角时，主角会有一个数对去选，他一定选大的，如何安排k个人，使得在所有主角可能能选到的数对中，最小的（数对最大值）最大。<br>首先可以想到，m之后的人如何选不会影响到主角，所以前k个都安排在m之前(当然最多安排m-1个人)，然后就枚举所有前k个的选择情况，对于每种情况下的最差情况取一个值，所有取值取一个最大值即可，暴力O(mk)枚举就好。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        k = <span class="built_in">min</span>(m<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> l = k+<span class="number">1</span>,r=n;</span><br><span class="line">        <span class="keyword">int</span> tt = m-k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;tt&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span> (;l&gt;=<span class="number">1</span>;l--,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp = inf;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=l+tt;i++)&#123;</span><br><span class="line">            tmp = <span class="built_in">min</span>(tmp,<span class="built_in">max</span>(a[i],a[r-tt+(i-l)]));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Irreducible-Anagrams"><a href="#D-Irreducible-Anagrams" class="headerlink" title="D Irreducible Anagrams"></a>D Irreducible Anagrams</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个大串，给出q个询问，每次问大串的一个子串，问这个子串是否存在一个<strong>irreducible</strong>的变幻串，该条件指：<br>能否将原串拆分为两个以上的部分，变幻串按相同的方法拆分，使得每一个对应分串所包含的每个字母的数量相同。</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>昨晚想的头疼，这谁能会啊QAQ。结果是特判一下，如果该串符合一下条件之一，就一定<strong>irreducible</strong>:</p>
<ul>
<li>长度为1</li>
<li>首尾字符相同</li>
<li>有三个及以上不同的字符<br>意会一下他是对的。。。具体证明就不写了QAQ</li>
</ul>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">400000</span>][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      num[i+<span class="number">1</span>][j] = num[i][j];</span><br><span class="line">      <span class="keyword">if</span> (j==s[i]-<span class="string">'a'</span>) num[i+<span class="number">1</span>][j]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">int</span> q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> l,r,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">      <span class="keyword">if</span> (num[r][i]-num[l<span class="number">-1</span>][i]&gt;<span class="number">0</span>) cnt++;</span><br><span class="line">    <span class="keyword">if</span> (s[l<span class="number">-1</span>]!=s[r<span class="number">-1</span>]||cnt&gt;=<span class="number">3</span>||l==r) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署报错及修理过程</title>
    <url>/2020/02/02/hexo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99%E5%8F%8A%E4%BF%AE%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><a id="more"></a>
<p>这天，俺一如既往得颓废，然后战某神说他刚建了个博客，让我康康…..然后对比之下俺惊奇得发现俺的博客有点瑕疵，所以随手改了下，之后hexo g&amp;&amp;hexo d…..结果出错了！？人有点傻，只得快马加鞭，推掉对面~然后团灭被一波了QAQ~</p>
<h1 id="修理过程"><a href="#修理过程" class="headerlink" title="修理过程"></a>修理过程</h1><p>随后啥都不会的俺开始慌了，但是俺觉得俺有度年俺怕谁，定准了错误信息Spawn fail，然后到处乱翻。。。。</p>
<p>有说是因为上次上传中途突然中断，导致仓库和本地不同步的。好，俺仓库也没个星星俺怕啥，分分钟重新建了个仓库，没用mad。</p>
<p>有说是ssh过期不匹配的~这玩意咋能过期？？~。好，俺重新设了三遍ssh，没用mad。</p>
<blockquote>
<p>ssh,一种信息安全协议，这里用公钥和私钥两个，公钥谁都能看，私钥只有自己有，登录的时候服务器用公钥去匹配私钥，匹配成功了就可以为所欲为。</p>
</blockquote>
<p>最后饶了一大圈，终于发现真正的错误信息在上边一行~我真是个ZZmad~实际上是time out啥的，访问github请求超时的意思。最后在google找到了解决方案~lj百度QAQ~</p>
<h1 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h1><p>大概是冠状病毒太猖狂侵入了github的各大地区服务器了？怎么感觉全都瘫痪了？？最后终于在加拿大找到了一个好用的服务器，贼鸡儿快，改了一下host就解决问题了~原来是网卡了o(╥﹏╥)o~</p>
<blockquote>
<p>host本地一个优先寻找ip地址的目录，电脑会现在host上查询一波你想去的网址，找不到再去DNS上找。。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>杂学</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeforcesER81</title>
    <url>/2020/01/30/CodeforcesER81/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>用给定数目的灯管(类似计算器上的数字显示屏，一个数字由7根灯管亮灭组成)，显示尽可能大的数。<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>~题面很唬人，然而只是判断奇偶数~显然位数越多数字越大，尽可能往高位组，所以尽可能使用1(2根灯管),偶数就刚好，奇数多余的一根就让最高位的1变成7。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"7"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个01串作为循环节，得到一个无限长的01串，求该串有多少前缀满足0的个数-1的个数等于所期望的值。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>首先如果循环节的01数相等，特判掉：</p>
<ul>
<li>如果存在循环节中某个前缀01差符合期望值则输出-1</li>
<li>如果没有就是0</li>
</ul>
<p>特判掉以上情况之后，显然每个位置至多贡献1，记录原始循环节每个位置作为前缀末尾得到的01个数差在数组num中，求整个循环节的01个数差极为tt。对于每一个位置看$x-num_i$(x为期望差值)是否是tt的非负倍数，是则贡献答案否则继续找。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">400010</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,sum=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]==<span class="string">'0'</span>) sum++;</span><br><span class="line">            <span class="keyword">else</span> sum--;</span><br><span class="line">            num[i+<span class="number">1</span>] = sum; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tt = num[n];</span><br><span class="line">        <span class="keyword">if</span> (tt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span> (num[i]==x) &#123;flag = <span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">0</span>) ans++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x-num[i])%tt==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((x-num[i])/tt&gt;=<span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定a串,t串以及空串z,每次操作可以取一个a串的任意子序列连接在z串后边，问最少需要操作几次使z串变为t串</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>一定正确的做法，贪心，使用两个指针在a串和t串两边一起扫，不断地循环扫a串找t串当前指针所指字符，找到就继续扫，找不到就输出-1,最后都找完了答案就是扫过的a串的遍历数。显然暴力扫很慢，优化一下：</p>
<ul>
<li>法一，使用lower_bound(大概是可以，但是我写炸了，某大仙好像是这么做的)</li>
<li>法二，建立一个26*n的跳表，预处理一遍，之后扫的时候O(N)扫一遍就行了。<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100010</span>],t[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">100010</span>][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line">        <span class="keyword">int</span> lens = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        lens++;</span><br><span class="line">        <span class="keyword">int</span> lent = <span class="built_in">strlen</span>(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">26</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            nxt[lens][k] = lens+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=lens<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i]==<span class="string">'a'</span>+k) nxt[i][k] = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> nxt[i][k] = nxt[i+<span class="number">1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">            nxt[<span class="number">0</span>][k] = nxt[<span class="number">1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> is = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lent;i++)&#123;</span><br><span class="line">            is = nxt[is][t[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (is==lens+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                is = <span class="number">0</span>;</span><br><span class="line">                is = nxt[is][t[i]-<span class="string">'a'</span>];</span><br><span class="line">                <span class="keyword">if</span> (is==lens+<span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    ans = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;is&lt;&lt;endl;</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// cout&lt;&lt;is&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2>给a,m,问有多少个x(0\&lt;=x\&lt;m)满足gcd(a,m)==gcd(a+x,m).<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2>在CFdiv2难得一见的数论题。。。<br>对于原题，首先显然gcd(a,m)是一个常数(记为d)，而对于gcd(a+x,m)，当a+x>=m时gcd(a+x,m)==gcd((a+x)\%m,m),(a+x)\%m$\in$[0,a),接上a+x小于m的部分，原题就是问有多少个小于m的正整数x满足gcd(x,m)=d;<br>写出来是这个：<script type="math/tex; mode=display">\sum_{i=0}^{m-1}[gcd(i,m)==d]</script>又因为gcd(0,m)=gcd(m,m),所以：<script type="math/tex; mode=display">\sum_{i=1}^{m}[gcd(i,m)==d]</script>之后整个式子除一个d:<script type="math/tex; mode=display">\sum_{i=1}^{\lfloor \frac {m} d \rfloor}[gcd(i,\lfloor \frac m d \rfloor)==1]</script>然后本质上就是m/d的欧拉函数，抄了个求欧拉函数的板子就能过了<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b%a,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> m = <span class="keyword">int</span>(<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>));</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">      ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d = gcd(a,m);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;euler_phi(m/d)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>map与unordered_map用法总结</title>
    <url>/2020/01/23/map%E4%B8%8Eunordered-map%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>map是一种底层基于红黑树的一种字典数据结构，可以做到key值与value值的对应,内部有序。<br>unordered_map是一种hash实现的字典数据结构，在查找方面效率比map高很多，但内部无序。<br><a id="more"></a></p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul>
<li>包含 &lt; map >和&lt; unordered_map ></li>
</ul>
<h2 id="内部用法"><a href="#内部用法" class="headerlink" title="内部用法"></a>内部用法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>map &lt; type,type > m;</p>
<h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><ul>
<li>m.insert(makepair(123,”JJH”));</li>
<li>m.insert(map<int,string>::value_type(123,”JJH”));</int,string></li>
<li>m[123] = “JJH”;</li>
</ul>
<p>注意第三种方式会覆盖原先的值，前两种则会返回一个pair<iterator,bool>,插入的位置和是否插入成功。</iterator,bool></p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><ul>
<li>iter=m.find(“123”);</li>
</ul>
<p>find函数返回指向key-value对的迭代器，如果找不到则返回m.end();</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li>iter = m.find(“123”)<br>m.erase(iter);</li>
<li>m.erase(“123”);</li>
<li>m.erase(m.begin(),map.end());</li>
</ul>
<p>成功返回值为1，否则为0.</p>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul>
<li>begin()       返回头部迭代器</li>
<li>clear()       删除所有元素</li>
<li>count()       返回指定元素出现次数</li>
<li>empty()       返回是否为空(bool)</li>
<li>end()         尾指针</li>
<li>lower_bound() 返回键值&gt;=给定元素的第一个位置(迭代器)</li>
<li>upper_bound() 返回键值&gt;给定元素的第一个位置(迭代器)</li>
</ul>
<h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><p>在结构体内部重载即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node <span class="keyword">const</span> &amp;A) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;A.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>用法基本一致，除了lower_bound和upper_bound.重载需要重载==。</p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流入门级总结</title>
    <url>/2020/01/23/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%85%A5%E9%97%A8%E7%BA%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我对网络流的理解，大概就是一种常用于解决一些玄学匹配问题的图论算法，其难度在建图方面远远大于背板子(毕竟板子就是普通的bfs+dfs)。大体上会涉及到的题目分支有:</p>
<ul>
<li>最大流</li>
<li>最小割</li>
<li>费用流</li>
</ul>
<a id="more"></a>
<h1 id="网络流算法"><a href="#网络流算法" class="headerlink" title="网络流算法"></a>网络流算法</h1><h2 id="网络流概念"><a href="#网络流概念" class="headerlink" title="网络流概念"></a>网络流概念</h2><p>假想有一个水库，可以从水库源源不断地通过管道输出自来水，管道通往各个户主，管道有粗有细，最终都会流向附近的一条河。我们将水库，想象成一个点，叫他源点;户主也想象成一个个点，管道是一条条的有向边,每个边的边权是管道的容量，河流也想象成一个点，我们叫他汇点。最后可能是类似这样的图：<br><img src="/2020/01/23/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%85%A5%E9%97%A8%E7%BA%A7%E6%80%BB%E7%BB%93/AA.png" alt="TU"><br>由此引出以下我们需要的这几个概念</p>
<ul>
<li>源点：出发点</li>
<li>汇点：终点</li>
<li>容量：每条边(管道)最多能流过的量</li>
<li>流量：每条边(管道)已经流过的量</li>
<li>流：一个从源点流向汇点的合法的解的总流量</li>
<li>割：一个边集的边权和。这个边集满足，原图去掉这些边之后，源点与汇点将无法连通。</li>
</ul>
<p>最终要求解的问题：从源点到汇点最大的流是多少。</p>
<h2 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h2><p>建图时，不仅要建需要的边，还要建每条边的反向边，正向边的边权为容量，反向边边权为0，反向边的边权意义是该条边已经流过的流量，那么显然该条边还能够流的流量大小就是容量减去反向边的流量。至于为啥要建立反向边，下边会解释。</p>
<ul>
<li>每次都从源点进行广搜(仅搜索还有容量剩余的边)，搜索过程中保存搜索的路径，在搜到汇点之后停止。</li>
<li>这时我们得到一条从源点到汇点的路径(我们称之为增广路)，我们取路径中最小的边权x，将所有路径中的边的边权减去x，在其对应的反向边的边权上加上x,并在最终答案上加x。</li>
<li>如此往复，直到找不到一条增广路，此时得到的答案就是最大流。</li>
</ul>
<p>用手模拟一下的话会发现反向边的作用就是给了程序反悔的机会，在增广的过程中流过正向边就是水正向的流向汇点，流过反向边，就是逆向的流回源点。具体他为啥是对的。。。俺也弄不太清楚QAQ。<br>板子类似这样。。。~懒得在敲了。。。大部分时候用Dinic就挺好的。。。~<br>复杂度O($n^2m$)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pre[i]=edg[i]=<span class="number">-1</span>,flow[i]=INF;</span><br><span class="line">    pre[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(u==t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w&gt;<span class="number">0</span>&amp;&amp;pre[v]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[v]=u;</span><br><span class="line">                edg[v]=i;</span><br><span class="line">                flow[v]=<span class="built_in">min</span>(flow[u],e[i].w);</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[t]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=t;</span><br><span class="line">        <span class="keyword">while</span>(x!=s)&#123;</span><br><span class="line">            e[edg[x]].w-=flow[t];</span><br><span class="line">            e[edg[x]^<span class="number">1</span>].w+=flow[t];</span><br><span class="line">            x=pre[x];</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=flow[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h2><p>EK算法进行优化，实际上每bfs一次，在最短路没有变化之前，可以用dfs进行多次增广(也就是同时对几条相同长度的最短路增广)，思想是差不多的，大部分情况下比EK快一些。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=S;i&lt;=T;i++) dis[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[to]==<span class="number">-1</span>&amp;&amp;E[i].f)&#123;</span><br><span class="line">                dis[to] = dis[x]+<span class="number">1</span>;</span><br><span class="line">                q.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> used = <span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (E[i].f&amp;&amp;dis[to]==dis[x]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = dfs(to,<span class="built_in">min</span>(E[i].f,flow-used));</span><br><span class="line">            used+=tmp;</span><br><span class="line">            E[i].f-=tmp;</span><br><span class="line">            E[i^<span class="number">1</span>].f+=tmp;</span><br><span class="line">            <span class="keyword">if</span> (used==flow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!used) dis[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) ans+=dfs(S,INF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><p>意思就是每条边令有一个边权表示没流过单位流量花费的费用，要求在保证最大流的情况下使得总费用最小。<br>~虽然我并不知道他为啥是对的~一般的板子就是EK算法里bfs的部分改成SPFA或者dijkstra，最后求贡献时每次加<strong>增广路径上费用和*路径上最小容量</strong>,很好理解，所有的流都要经过每一条管道。<br>处理到后面可能会出现负环，用spfa会好写一点，dijkstra的费用流后边有时间补。<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1533" target="_blank" rel="noopener">hdu 1533</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;H[<span class="number">10010</span>],m[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,f,c;</span><br><span class="line">&#125;E[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,head[<span class="number">10000</span>],num[<span class="number">10000</span>],vis[<span class="number">10000</span>],S,T,ans,dis[<span class="number">10000</span>],pree[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> preV[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    E[++cnt].f = f;</span><br><span class="line">    E[cnt].c = c;</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    E[cnt].nxt = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=S;i&lt;=T;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">        vis[i] = <span class="number">0</span>;num[i]=<span class="number">0</span>;</span><br><span class="line">        preV[i] = pree[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    vis[S] = <span class="number">1</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">            <span class="keyword">if</span> (E[i].f&amp;&amp;dis[to]&gt;E[i].c+dis[x])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[x]+E[i].c;</span><br><span class="line">                pree[to] = i;</span><br><span class="line">                preV[to] = x;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[to] = <span class="number">1</span>;</span><br><span class="line">                    q.push(to);</span><br><span class="line">                    num[to]++;</span><br><span class="line">                    <span class="keyword">if</span> (num[to]&gt;=T) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preV[T]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_flow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(SPFA())&#123;</span><br><span class="line">        <span class="keyword">int</span> f = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=preV[i])</span><br><span class="line">            f = <span class="built_in">min</span>(f,E[pree[i]].f);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=preV[i])&#123;</span><br><span class="line">            E[pree[i]].f-=f;</span><br><span class="line">            E[pree[i]^<span class="number">1</span>].f+=f;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=f*dis[T];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">        <span class="keyword">if</span> (N==<span class="number">0</span>&amp;&amp;M==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) head[i] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> a[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j]==<span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[j]==<span class="string">'H'</span>)&#123;</span><br><span class="line">                    H[++cnt1].x = i;</span><br><span class="line">                    H[cnt1].y = j+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    m[++cnt2].x = i;</span><br><span class="line">                    m[cnt2].y = j+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> D = <span class="built_in">abs</span>(H[i].x-m[j].x)+<span class="built_in">abs</span>(H[i].y-m[j].y);</span><br><span class="line">                add(i,cnt1+j,<span class="number">1</span>,D);</span><br><span class="line">                add(cnt1+j,i,<span class="number">0</span>,-D);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        S = <span class="number">0</span>;T = cnt1+cnt2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;i++) &#123;</span><br><span class="line">            add(S,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            add(i,S,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=cnt1+<span class="number">1</span>;j&lt;=cnt1+cnt2;j++)&#123;</span><br><span class="line">            add(j,T,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            add(T,j,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        min_flow();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P2774" target="_blank" rel="noopener"><strong>方格取数</strong></a><br>将方格按横纵坐标和的奇偶性二分出两个点集，一个点集全部连向源点，另一个全部连向汇点，边权为点权。两个点集之间将冲突的点连一条边权为inf的边。求一个最小割(最大流等于最小割)，用总点权和减去最小割即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,f;</span><br><span class="line">&#125;E[<span class="number">500000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,head[<span class="number">100000</span>],S,T,ans,dis[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    E[++cnt].f = f;</span><br><span class="line">    E[cnt].nxt = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=S;i&lt;=T;i++) dis[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[to]==<span class="number">-1</span>&amp;&amp;E[i].f)&#123;</span><br><span class="line">                dis[to] = dis[x]+<span class="number">1</span>;</span><br><span class="line">                q.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> used = <span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (E[i].f&amp;&amp;dis[to]==dis[x]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = dfs(to,<span class="built_in">min</span>(E[i].f,flow-used));</span><br><span class="line">            used+=tmp;</span><br><span class="line">            E[i].f-=tmp;</span><br><span class="line">            E[i^<span class="number">1</span>].f+=tmp;</span><br><span class="line">            <span class="keyword">if</span> (used==flow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!used) dis[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) ans+=dfs(S,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    S = <span class="number">0</span>;T = m*n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">            sum+=a;</span><br><span class="line">            <span class="keyword">if</span> ((i+j)%<span class="number">2</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                add(S,(i<span class="number">-1</span>)*n+j,a);</span><br><span class="line">                add((i<span class="number">-1</span>)*n+j,S,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> xx = i+dx[k];</span><br><span class="line">                    <span class="keyword">int</span> yy = j+dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=m&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        add((i<span class="number">-1</span>)*n+j,(xx<span class="number">-1</span>)*n+yy,INF);</span><br><span class="line">                        add((xx<span class="number">-1</span>)*n+yy,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                add((i<span class="number">-1</span>)*n+j,T,a);</span><br><span class="line">                add(T,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    Dinic();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum-ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC152&amp;&amp;Codeforces614(div2)</title>
    <url>/2020/01/20/ABC152-Codeforces614-div2/</url>
    <content><![CDATA[<p><strong><del>因为会做的题太少</del>一晚上的两场比赛放一起了</strong><br><a id="more"></a></p>
<h1 id="AtCoder"><a href="#AtCoder" class="headerlink" title="AtCoder"></a>AtCoder</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>M=N输出Yes,否则No</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>给出a,b,如果b小输出a个b,否则输出b个a</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个全排列，求出符合一下条件的位置i的个数：</p>
<ul>
<li>对于任意的$j(1\leq j\leq i)$,$a_i\leq a_j$</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>其实就是使当前位置为最小值的位置的数，维护一个前i项的最小值，每扫一个位置比一下大小，当前位置等于前i项最小值则答案+1</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>就不放我丑陋的代码了。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定N,求正整数数对(A,B)的个数满足：</p>
<ul>
<li>$A \leq N,B \leq N$</li>
<li>A的最左边的数字和B的最右边的数字相同，A的最右边的数字和B的最左边的数字相同，如{1,1}，{21,12}，{123,3401}</li>
</ul>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>记一个数组c[i][j],表示以i开头以j结尾的满足条件的数的个数，可以很快预处理出来。然后答案ans = $\sum_{i=1}^9\sum_{j=1}^9c[i][j]*c[j][i]$</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i==j&amp;&amp;i&lt;=N) c[i][j]++;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (i*tmp+j&lt;=N)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==N/tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j]+=N%tmp/<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;N%<span class="number">10</span>) c[i][j]--;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        c[i][j]+=tmp/<span class="number">10</span>;     </span><br><span class="line">        tmp*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">    ans+=c[i][j]*c[j][i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Codeforces"><a href="#Codeforces" class="headerlink" title="Codeforces"></a>Codeforces</h1><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个有n层的高楼，主角在第s层，每层都有餐厅，但是有k层关门了，现在把关门的k层的编号给你，问主角至少走几层才能到达餐厅吃饭。</p>
<h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>数据范围很小，将给定的k层排个序找s附近有多少关门的餐厅就行(或者不排序每次都暴力找也行$N^2$一样过)</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2001</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">int</span> n,s,k;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;s,&amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> is=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s==a[i])&#123;</span><br><span class="line">                is = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s-ans&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (is-ans&lt;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (s-ans!=a[is-ans]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s+ans&lt;=n)&#123;</span><br><span class="line">                <span class="keyword">if</span> (is+ans&gt;k) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (s+ans!=a[is+ans])<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>战无不败的JOE参加一个答题比赛，一开始他有n个对手，每轮题目答错的人会被淘汰,每轮题目过后，假设有s个JOE的对手在场上，JOE总能答对，然而对手会有t个人答错,这时JOE会得到$\frac t s$的赏金，一直进行到只剩JOE一人。问JOE最多能得到多少赏金。</p>
<h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>猜也应该是$\frac 1 n +\frac 1 {n-1}+\frac 1 {n-2}…+1$这样的结果，严谨的证明就不做了~其实是我不会QAQ~,感性思考一下，应该是场上的对手越少的时候没淘汰一位能得到的平均钱数就越多，然后每次都只淘汰一个人，就能保证含金量高的场次能进行得更多…..如果某一场淘汰了两人或者更多，那么就相当于这两人贡献了同样含金量场次只淘汰一人的两个赏金，而显然分开淘汰的话其中一些人的人均赏金是会更高的。</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a&lt;<span class="number">0</span>) <span class="keyword">return</span> -a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">0.0000001</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> i=n;<span class="built_in">abs</span>(i)&gt;eps;i--)&#123;</span><br><span class="line">        ans+=(<span class="keyword">double</span>)<span class="number">1</span>/i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个两行n列的网格，主角在(1,1),终点在(2,n),主角可以在水平和竖直方向上移动。然而某些网格有时会变化成laya,从而不能通过。一共有q个时刻，每个时刻都会变化一个网格，如果本来是普通网格，则变为laya;如果本来是laya，则变为普通网格;询问每个时刻，是否有路线可以让主角到达终点。</p>
<h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>分析题目，怎么才会导致无法通过呢？可以得出，当某一行的laya位置相对行的正对三个位置也有laya存在时，一定无法通过。所以我们得出只要维护对面三个格子也有laya的laya网格个数就好了，为0是一定可以通过，大于0则不能。</p>
<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">3</span>][<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r,c;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;r,&amp;c);</span><br><span class="line">        <span class="keyword">int</span> zz=(r==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[r][c]==<span class="number">0</span>)&#123;</span><br><span class="line">            a[r][c]=<span class="number">1</span>;</span><br><span class="line">            num[r][c] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,c<span class="number">-1</span>);j&lt;=<span class="built_in">min</span>(n,c+<span class="number">1</span>);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[zz][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num[zz][j]==<span class="number">0</span>) ans++;</span><br><span class="line">                    num[zz][j]++;</span><br><span class="line">                    num[r][c]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[r][c])ans++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           a[r][c]=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (num[r][c]) ans--;</span><br><span class="line">           num[r][c] = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,c<span class="number">-1</span>);j&lt;=<span class="built_in">min</span>(n,c+<span class="number">1</span>);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[zz][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    num[zz][j]--;</span><br><span class="line">                    <span class="keyword">if</span> (num[zz][j]==<span class="number">0</span>) ans--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>在一个平面系中，有一些特殊的点，他们满足：</p>
<ul>
<li>第0号点在(x0,y0).</li>
<li>对于第i号节点，他的位置为($a_x·x_{i-1}+b_x,a_y·y_{i-1}+b_y$)</li>
</ul>
<p>主角一开始在$(x_s,y_s)$,每秒他都可以向上下左右某个方向移动一个单位，问t秒内他最多能到达几个点</p>
<h3 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h3><p>乍一看以为是个普通的方格搜索题，一看数据范围$10^{16}$,直接告辞。再一观察，不对阿。。。这些特殊点分布有规律的，仔细想想应该是从左下向右上分布，而且左下相对密集一些。再考虑$a_x,a_y$，发现按照这个方法递增产生的点即使在1e16的范围内也就不到一百个而已.所以我们暴力去枚举每一个点，使得主角从起点到达这个点，然后再向左下方去找下一个点，期间记录他们的曼哈顿距离和，大于t的时候就跳出，最后从所有的答案里面取一个最大值即可。</p>
<h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> y[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxn = <span class="number">1e16</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x0,y0,ax,ay,bx,by;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> xs,ys,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>,&amp;x0,&amp;y0,&amp;ax,&amp;ay,&amp;bx,&amp;by);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;xs,&amp;ys,&amp;t);</span><br><span class="line">    x[<span class="number">0</span>]=x0;y[<span class="number">0</span>]=y0;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dis=<span class="number">0</span>;</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    maxn = <span class="built_in">min</span>(t+xs,t+ys)+t;</span><br><span class="line">    <span class="keyword">while</span>(x[i]&lt;=maxn&amp;&amp;y[i]&lt;=maxn)&#123; </span><br><span class="line">        i++;</span><br><span class="line">        x[i] = ax*x[i<span class="number">-1</span>]+bx;</span><br><span class="line">        y[i] = ay*y[i<span class="number">-1</span>]+by;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+<span class="built_in">abs</span>(x[i]-x[i<span class="number">-1</span>])+<span class="built_in">abs</span>(y[i]-y[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">        dis=<span class="built_in">abs</span>(x[j]-xs)+<span class="built_in">abs</span>(y[j]-ys);</span><br><span class="line">        <span class="keyword">int</span> k = j;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> xl = x[j],yl = y[j];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dis&lt;=t)&#123;</span><br><span class="line">            tmp++;</span><br><span class="line">            <span class="keyword">if</span> (k==<span class="number">0</span>) &#123;k=j;flag=<span class="literal">false</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) k--;<span class="keyword">else</span> k++;</span><br><span class="line">            <span class="keyword">if</span> (k&gt;i) <span class="keyword">break</span>;</span><br><span class="line">            dis+=<span class="built_in">abs</span>(x[k]-xl)+<span class="built_in">abs</span>(y[k]-yl);</span><br><span class="line">            xl = x[k];yl = y[k];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="QAQ两边一起掉分是真的快乐…-透"><a href="#QAQ两边一起掉分是真的快乐…-透" class="headerlink" title="QAQ两边一起掉分是真的快乐…~透~"></a>QAQ两边一起掉分是真的快乐…~透~</h2>]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>数论粗略扫盲(扫不完QAQ)</title>
    <url>/2020/01/19/%E6%95%B0%E8%AE%BA%E7%B2%97%E7%95%A5%E6%89%AB%E7%9B%B2-%E6%89%AB%E4%B8%8D%E5%AE%8CQAQ/</url>
    <content><![CDATA[<h1 id="裴-pei-蜀定理"><a href="#裴-pei-蜀定理" class="headerlink" title="裴(pei)蜀定理"></a>裴(pei)蜀定理</h1><a id="more"></a>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>设a,b是不全为零的整数，则存在整数x,y,使得ax+by=gcd(a,b).<br>代数几何中的一个定理，可以为其他的数论理论的论证做基础。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>其实贼显然。。。设g=gcd(a,b),显然有g|a,g|b,也肯定有g|ax,g|by,所以等式两边都同时除以g,得到</p>
<script type="math/tex; mode=display">\frac a g x +\frac b g y  = 1</script><p>$\frac a g$与$\frac b g$互质，一定能互相线性运算得到1，实际上是另一个定理，属于两数互质的充分必要条件,证明类似辗转相处法？，不继续证了就QAQ</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>推广到n个数是一样的，对于n个数$a_1,a_2,a_3…a_n$存在$x_1,x_2,x_3…x_n$使得<script type="math/tex">a_1x_1+a_2x_2+...+a_nx_n=gcd(a_1,a_2,...,a_n)</script></p>
<h2 id="应用n遍裴蜀定理即可"><a href="#应用n遍裴蜀定理即可" class="headerlink" title="应用n遍裴蜀定理即可"></a>应用n遍裴蜀定理即可</h2><h1 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>形如$ax\equiv b \pmod c$的方程称为线性同余方程(求x).</p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>定理基础</p>
<blockquote>
<p>定理1：求解$ax\equiv b \pmod c$与求解$ax + by = c$中的x是等价的。</p>
<p>定理2：若$gcd(a,b)=1$,且$x_0,y_0$为方程$ax+by=c$的一组解，则方程的任意解可以表示为$x = x_0+bt,y = y_0-at$,t取任意整数.</p>
</blockquote>
<p>根据定理1,我们只需要对$ax + by = c$进行求解。<br>由裴蜀定理得，一定存在在整数解x,y,满足ax+by=gcd(a,b),我们试着求解其中的x,y.<br>由欧几里得算法我们有gcd(a,b)=gcd(b,a%b),所以有：<br>$ax_1+by_1 = gcd(a,b)$<br>b$x_2$+(a%b)$y_2$ = gcd(b,a%b)<br>变幻  a%b  为  $a-\lfloor \frac a b \rfloor b$<br>b$x_2$+($a-\lfloor \frac a b \rfloor b$)$y_2$ = gcd(b,a%b)<br>即：<br>a$y_2$+b($x_2$-$\lfloor \frac a b \rfloor$) = gcd(b,a%b) = gcd(a,b) = a$x_1$+b$y_1$<br>所以有：<br>$x_1=y_2$ , $y_1=x_2-\lfloor \frac a b \rfloor$<br>递归求解下去，直到变为gcd(a,0)<br>这时我们直到ax+0*y=gcd(a,0) = a<br>取x=1,y=0向上回代即可.<br>求出一组特解$x_0,y_0$之后，我们得到了<script type="math/tex">ax_0+by_0=gcd(a,b)</script><br>设g = gcd(a,b)我们使等式两边同除以gcd(a,b),变为</p>
<script type="math/tex; mode=display">\frac a g x_0 +\frac b g y_0  = 1</script><p>此时使$a_2 =\frac a g$,$b_2=\frac b g$,变为</p>
<script type="math/tex; mode=display">a_2x_0 +b_2y_0 = 1</script><p>此时$a_2,b_2$互质，符合定理2原方程的特解为$x=(x_0/g)*c$,所以原同余方程的通解形式为:</p>
<script type="math/tex; mode=display">x+b_2t</script><p>(t取任意整数)<br>最小整数解为:<br>(x%$b_2$+$b_2$)%$b_2$</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://loj.ac/problem/2605" target="_blank" rel="noopener">同余方程</a></p>
<h2 id><a href="#" class="headerlink" title></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = x;</span><br><span class="line">    x = y;y = temp-(a/b)*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;b);</span><br><span class="line">    exgcd(a,b);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = b/gcd(a,b)*<span class="number">1</span>;<span class="comment">//此时c=1;</span></span><br><span class="line">    x/=gcd(a,b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(x%t+t)%t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><h2 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h2><p>求解如下形式的一元线性同余方程组：<br><img src="/2020/01/19/%E6%95%B0%E8%AE%BA%E7%B2%97%E7%95%A5%E6%89%AB%E7%9B%B2-%E6%89%AB%E4%B8%8D%E5%AE%8CQAQ/中国剩余定理.png" alt="中国剩余定理"><br>保证模数两两互质。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>留坑。。。</p>
<h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><p>如果模数不互质，则不能用一开始的方法直接去求，而改为求解n-1次同余方程(即使用n-1次拓展欧几里得算法)。<br>考虑求解两方程：<br>$x\equiv a_1 \pmod m_1$,$x\equiv a_2 \pmod m_2$<br>所以有x=$m_1p+a_1$=$m_2q+a_2$,<br>$m_1p-m_2q=a_2-a_1$<br>就是一个普通的线性同余方程，根据裴蜀定理有$a_2-a_1$一定能被$gcd(m_1,m_2)$整除，否则无解。<br>然后用拓展欧几里得算法解出来一组可行解(p,q).随便带入上边某个式子求出一个可行的x,使得A=x，M=$lcm(m_1,m_2)$,合并得到新的同余方程：<br>$x\equiv A \pmod M$<br>如此往复，将每一个方程合并，即可最终求解出A.</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4777" target="_blank" rel="noopener">洛谷模板题</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;g,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        g = a;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b,g,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);   </span></span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> nn,a,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;nn;</span><br><span class="line">    nn--;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a;</span><br><span class="line">    ll A = a,N=n;</span><br><span class="line">    x=a%n;</span><br><span class="line">    <span class="keyword">while</span>(nn--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a;</span><br><span class="line">        ll c = a-A;</span><br><span class="line">        ll g;</span><br><span class="line">        ll t;</span><br><span class="line">        exgcd(N,n,g,x,y);</span><br><span class="line">        x = x*c/g;</span><br><span class="line">        t = n/g;</span><br><span class="line">        x = (x%t+t)%t;</span><br><span class="line">        A +=x*N;</span><br><span class="line">        N = N*n/g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">long</span>)A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>~__int128是抄题解的。。。要不然真的过不了QAQ~</p>
<hr>
<h1 id="BSGS算法"><a href="#BSGS算法" class="headerlink" title="BSGS算法"></a>BSGS算法</h1><h2 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h2><p>用于求解形如$a^x \equiv b \pmod p$的方程。</p>
<h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><h3 id="普通的BSGS"><a href="#普通的BSGS" class="headerlink" title="普通的BSGS"></a>普通的BSGS</h3><p>在保证a与p互质的情况下，由费马小定理$a^{p-1} \equiv a \pmod p$,$a^0\equiv a \pmod p$,可知循环节小于等于p,所以令x从0~p-1依次查看是否靠谱即可，BSGS算法就是对此步骤进行的优化，类似于分块的思想。<br>具体来说，<br>我们使$x=A*\lceil\sqrt p\rceil - B$,<br>这样我们使$A \in [1,\lceil\sqrt p\rceil]$,$B \in [0,\lceil\sqrt p\rceil]$,<br>这样我们就可以通过变幻A与B取遍所有值。</p>
<p>原方程变为</p>
<script type="math/tex; mode=display">a^{A\*\lceil\sqrt p\rceil - B} \equiv b \pmod p</script><p>将带B的幂次方乘到右边,得到：</p>
<script type="math/tex; mode=display">a^{A\*\lceil\sqrt p\rceil } \equiv a^Bb \pmod p</script><p>这种形式的话我们将右边取值不同的B,将结果都塞进一个hash或者map里(unordered_map比map在这方面快一个logQAQ),然后左边依次枚举A，查看是否有相等的右边，这样就可以在$O(\sqrt p)$的复杂度里面将结果算出。</p>
<h3 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h3><p>有时候a与p并不互质，这时直接套用普通BSGS模板是不靠谱的。</p>
<p>我们设$g_1=gcd(a,p)$,将整个方程同时除以g,得到：</p>
<script type="math/tex; mode=display">\frac a {g_1} a^{x-1} = \frac b {g_1} \pmod {\frac p {g_1}}</script><p>如果还是不能满足$gcd(a,\frac p g)=1$,就可以继续除，使得$g_2 = gcd(a,\frac p g)$,然后得到:</p>
<script type="math/tex; mode=display">\frac a {g_1g_2} a^{x-2} = \frac b {g_1g_2} \pmod {\frac p {g_1g_2}}</script><p>一直除到满足互质条件即可,过程中应保重同余等式右边一定是个整数,如果不能整除则无解,记$D = \prod_{i=1}^n g_i$,得到最终式子：</p>
<script type="math/tex; mode=display">\frac a D a^{x-n} = \frac b D \pmod {\frac p D}</script><p>此时把左边$\frac a D$扔到右边(用逆元，或者不用扔过去也可以，一样算)。就变成了普通的BSGS模型了。最后求得x-k的值，加上k即可，要注意有可能0~k-1也有符合的值，所以需要特判一下。</p>
<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4195" target="_blank" rel="noopener">洛谷模板/Spoj3105</a><br>洛谷的数据会卡map，Spoj数据水一点。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll x,ll mod,ll m)</span><span class="comment">//用快速幂只是能快一点点，理论上不用也影响不大。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    ll temp = x;</span><br><span class="line">    <span class="keyword">while</span>(m)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m&amp;<span class="number">1</span>) ans = ans*temp%mod;</span><br><span class="line">        temp = temp*temp%mod;</span><br><span class="line">        m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">     ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>),<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,z,k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;z,&amp;k);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">0</span>&amp;&amp;z==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> g;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> D = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            g = gcd(x,z);</span><br><span class="line">            <span class="keyword">if</span> (g==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (k%g)&#123;<span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);flag = <span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            z/=g;</span><br><span class="line">            k/=g;</span><br><span class="line">            D=D*x/g;</span><br><span class="line">            D%=z;</span><br><span class="line">            tt++;</span><br><span class="line">            <span class="keyword">if</span> (D==k)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;tt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        m.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="built_in">sqrt</span>(z)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line">            m[a] = i;</span><br><span class="line">            a*=x;</span><br><span class="line">            a%=z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = mul(x,z,p);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> A = temp*D%z;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(A)!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans = i*p-m[A]+tt;</span><br><span class="line">                <span class="keyword">if</span> (ans&gt;=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            A*=temp;</span><br><span class="line">            A%=z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans&gt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ Monthly 2020.1</title>
    <url>/2020/01/17/EOJ-Monthly-2020-1/</url>
    <content><![CDATA[<h1 id="A-回文时间"><a href="#A-回文时间" class="headerlink" title="A.回文时间"></a>A.回文时间</h1><a id="more"></a>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定初始的由年月日组成和回文串， 2020 年 1 月 22 日的 10:02:02，即20200122100202，问之后第k个回文时间串是什么。时是0~23，个位数自动补0。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>因为是回文串，所以只构造左半边就能行，暴力模拟即可，不过注意右半边对左半边的限制，比如日份只有11和22，月只有01，02,10,11,12等等。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">10</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    ss[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">'0'</span>;ss[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">    ss[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">'0'</span>;ss[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">'2'</span>;</span><br><span class="line">    ss[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'1'</span>;ss[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">    ss[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">'1'</span>;ss[<span class="number">3</span>][<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">    ss[<span class="number">4</span>][<span class="number">0</span>] = <span class="string">'1'</span>;ss[<span class="number">4</span>][<span class="number">1</span>] = <span class="string">'2'</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> a1=<span class="number">2</span>,a2=<span class="number">0</span>,a3=<span class="number">2</span>,a4=<span class="number">0</span>,b = <span class="number">0</span>,c=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">if</span> (c&gt;<span class="number">2</span>) &#123;c=<span class="number">1</span>;b++;&#125;</span><br><span class="line">        <span class="keyword">if</span> (b&gt;<span class="number">4</span>) &#123;b=<span class="number">0</span>;a4++;&#125;</span><br><span class="line">        <span class="keyword">if</span> (a4&gt;<span class="number">5</span>) &#123;a3++;a4=<span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (a3&gt;<span class="number">9</span>) &#123;a2++;a3=<span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (a2&gt;<span class="number">5</span>) &#123;a1++;a2=<span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a1&lt;&lt;a2&lt;&lt;a3&lt;&lt;a4&lt;&lt;ss[b][<span class="number">0</span>]&lt;&lt;ss[b][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ss[b][<span class="number">1</span>]&lt;&lt;ss[b][<span class="number">0</span>]&lt;&lt;a4&lt;&lt;a3&lt;&lt;a2&lt;&lt;a1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-数的变换"><a href="#E-数的变换" class="headerlink" title="E.数的变换"></a>E.数的变换</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于一个数x，我们按照固定的规则对他进行变换:</p>
<ul>
<li>如果x是奇数，则变幻成x-1;</li>
<li>如果x是偶数，则除以2。</li>
</ul>
<p>往复执行，知道x变为1.</p>
<p>我们在定义一个数x的序列为他变幻过程中会出现的数，比如 7 的变幻序列[7] = {7,6,3,2,1},10的变幻序列[10] = {10,5,4,2,1};<br>现在给定n,k。问在1到n的变幻序列中至少出现k次的最大的数是多少？</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>首先分析这个操作，在二进制的角度看就是把一个数的最右边从1变为0,在整体右移，类似这样的操作。然后很容易想到，如果给定一个数x，任何与他前缀相同的数都会对他产生贡献，比如1010的变幻序列一定会出现101。特别的，对于偶数其前缀不需要最右边第一位也相同，也可以产生贡献。<br>再考虑怎么求一个特定数x在1~n的序列里会出现几次，首先如果x \&lt; n,那么他一定会出现一次，如果将x右移一位，依然小于n,那么应该会再出现两次，即前缀相同，最右边一位随便选0或1，再右移一位会出现4次，再右移一位会出现8次。。。。。以此类推，特别的，如果右移到最后一位，而且x与n的前缀相同，则贡献应该是n尾部的数字，而不是二的幂次方的形式。这样我们就可以在O(logn)级别的时间里求出一个数x的出现次数。<br>然后算算时间复杂度。。。不靠谱，不可能每个数都算一遍。所以？二分答案。感性理解一下，这个数字的出现次数应该是数字越小出现次数越多的，满足某种单调性质。。。然后手速一发,wa了QAQ….之后听大哥劝解，才明白。。。。如图：<br><img src="/2020/01/17/EOJ-Monthly-2020-1/EOJE.png" alt="打表"><br>答案在奇偶数附近疯狂波动，于是想到，分奇偶进行二分答案。</p>
<h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><p><del>写的巨丑的代码QAQ</del><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  k,n,maxbit;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> bit2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;temp*=<span class="number">2</span>;bit2++;&#125;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((x&amp;maxbit)==<span class="number">0</span>||(x&amp;(~(bit2)))&lt;(n&amp;(~(bit2))))&#123;</span><br><span class="line">        ans+=temp;</span><br><span class="line">        temp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=(n&amp;(bit2))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        bit2&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        bit2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">        maxbit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp1 = n;</span><br><span class="line">        <span class="keyword">while</span>(temp1) &#123;maxbit&lt;&lt;=<span class="number">1</span>;temp1&gt;&gt;=<span class="number">1</span>;&#125;</span><br><span class="line">        maxbit&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>,r=n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (judge(mid*<span class="number">2</span>))&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,mid*<span class="number">2</span>);</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        l  = <span class="number">0</span>;r = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (judge(mid*<span class="number">2</span>+<span class="number">1</span>))&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,mid*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="结言"><a href="#结言" class="headerlink" title="结言"></a>结言</h1><p>华师大的月赛日常蹂躏我,本菜鸡只能搞两题,感觉怎么跟我们学校的月赛一样码量惊人还难想？太不是人儿了QAQ,小年都不给我留打游戏的时间<br><del>果然还是我太菜了QAQ</del></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>EOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>splay入门总结</title>
    <url>/2020/01/17/splay%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Splay伸展树的本质"><a href="#Splay伸展树的本质" class="headerlink" title="Splay伸展树的本质"></a>Splay伸展树的本质</h1><a id="more"></a>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>所谓二叉搜索树，就是保证内部数据每个节点只有两个儿子，而且左儿子小于本节点小于右节点，用这种性质有很多问题都可以很好地利用这种数据结构来完成。然而他有一个致命的缺点，就是普通的搜索树在数据不随机的情况下很容易退化成链，变得毫无用处。</p>
<h2 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h2><p>伸展树，就是对二叉搜索树的一种优化，通过不时地Splay(x)操作(讲x变为树的根)，使树的结构能趋向于平衡，从而保证时间优越性(不过显然常数贼大)。</p>
<h1 id="Splay的一些基本操作"><a href="#Splay的一些基本操作" class="headerlink" title="Splay的一些基本操作"></a>Splay的一些基本操作</h1><h2 id="基本操作需要的一些数据"><a href="#基本操作需要的一些数据" class="headerlink" title="基本操作需要的一些数据"></a>基本操作需要的一些数据</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> recy;<span class="comment">//在该节点的值的重复个数</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//以该节点为根的子树的元素的个数(包含该节点，不是节点数，因为一个节点可能包含多个元素)</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];<span class="comment">//左右儿子，左为0，右为1</span></span><br><span class="line">    <span class="keyword">int</span> fa;<span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">int</span> v;<span class="comment">//值</span></span><br><span class="line">&#125;A[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>,root=<span class="number">0</span>,SUM=<span class="number">0</span>;<span class="comment">//cnt使用的序号个数，root根节点序号，SUM一共使用的节点个数。</span></span><br></pre></td></tr></table></figure>
<h2 id="get-which-int-x"><a href="#get-which-int-x" class="headerlink" title="get_which(int x)"></a>get_which(int x)</h2><p>查询x是父亲的哪个儿子(左为0，右为1)，贼短，不单独写个函数也影响不大。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_which</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[A[x].fa].ch[<span class="number">1</span>]==x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="update-int-x"><a href="#update-int-x" class="headerlink" title="update(int x)"></a>update(int x)</h2><p>更新该节点下的元素个数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">    A[x].sum = A[x].recy;</span><br><span class="line">    <span class="keyword">if</span> (A[x].ch[<span class="number">1</span>]) A[x].sum+=A[A[x].ch[<span class="number">1</span>]].sum;</span><br><span class="line">    <span class="keyword">if</span> (A[x].ch[<span class="number">0</span>]) A[x].sum+=A[A[x].ch[<span class="number">0</span>]].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="rotate-int-x"><a href="#rotate-int-x" class="headerlink" title="rotate(int x)"></a>rotate(int x)</h2><p>作用是旋转自己与父节点，使得x的层数减1，也就是与根节点更靠近一些。具体需要改变三条关系，分别是自己与父亲，父亲与爷爷，自己与自己的左(或者右)儿子。</p>
<ul>
<li>使得父亲的左(右)儿子与自己的右(左)儿子连边(即自己的  自己与父亲关系相反的  那个儿子)</li>
<li>使自己与爷爷连边</li>
<li>使自己被父亲抢走的那个儿子变成父亲</li>
</ul>
<p>形象一点的如图：<br><img src="/2020/01/17/splay%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/rotate.jpg" alt="rotate"><br>当然还有其他情况，都符合以上三条，可以自己尝试画一画。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = A[x].fa,g_fa = A[fa].fa,ww = get_which(x),w2=get_which(fa);</span><br><span class="line">    A[fa].ch[ww] = A[x].ch[ww^<span class="number">1</span>];</span><br><span class="line">    A[A[x].ch[ww^<span class="number">1</span>]].fa = fa;</span><br><span class="line">    A[fa].fa = x;</span><br><span class="line">    A[x].fa = g_fa;</span><br><span class="line">    A[x].ch[ww^<span class="number">1</span>] = fa;</span><br><span class="line">    <span class="keyword">if</span> (g_fa)</span><br><span class="line">    A[g_fa].ch[w2] = x;</span><br><span class="line">    update(fa);</span><br><span class="line">    update(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Splay-int-x"><a href="#Splay-int-x" class="headerlink" title="Splay(int x)"></a>Splay(int x)</h2><p>作用是使得x成为伸展树的根。<br>显然就。。。不断地对rotate(x)就能达到这个效果。然而需要特判一下自己与父亲，父亲与爷爷的关系是否一样(是否三点一线)，如果是这种情况就需要先旋转父节点，再旋转自己。。。。一开始我也并没有太懂，但是在黄某大仙的点拨下明白了些，就是说假如是一条链的话，你不断的rotate自己最终顶多也就是变成两条链，而特判之后splay会均衡很多。。。。其实感觉特判不特判都有可能使得结构变得不均衡，但是特判之后造呢种垃圾数据应该更难一些。<br>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa;fa=A[x].fa;rotate(x))</span><br><span class="line">    <span class="keyword">if</span> (A[fa].fa)</span><br><span class="line">    rotate((get_which(x)==get_which(fa))?fa:x);</span><br><span class="line">    root = x;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="insert-int-x"><a href="#insert-int-x" class="headerlink" title="insert(int x)"></a>insert(int x)</h2><p>插入一个节点x。<br>就是普通的在平衡树上插入一个节点，不断地向下找，比当前节点大就找右儿子，小就找左儿子，相等就返回,移动到空节点就造点，最后将x旋转到根节点即可。(理论上不splay(x)也不影响正确性，但是有事没事splay一下嘛，保证树总是均衡的)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        A[cnt].ch[<span class="number">0</span>]=A[cnt].ch[<span class="number">1</span>]=A[cnt].fa=<span class="number">0</span>;</span><br><span class="line">        A[cnt].v = x;</span><br><span class="line">        A[cnt].sum = A[cnt].recy = <span class="number">1</span>;</span><br><span class="line">        root = cnt;</span><br><span class="line">        SUM++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = root,fa=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[now].v==x)&#123;</span><br><span class="line">            A[now].recy++;</span><br><span class="line">            update(now);</span><br><span class="line">            update(fa);</span><br><span class="line">            splay(now);</span><br><span class="line">            SUM++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa = now;</span><br><span class="line">        now = A[now].ch[A[now].v&lt;x];</span><br><span class="line">        <span class="keyword">if</span> (!now)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            A[fa].ch[A[fa].v&lt;x] = cnt;</span><br><span class="line">            A[cnt].fa = fa;</span><br><span class="line">            A[cnt].ch[<span class="number">0</span>]=A[cnt].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            A[cnt].recy = A[cnt].sum = <span class="number">1</span>;</span><br><span class="line">            A[cnt].v = x;</span><br><span class="line">            splay(cnt);</span><br><span class="line">            SUM++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="find-rank-int-x"><a href="#find-rank-int-x" class="headerlink" title="find_rank(int x)"></a>find_rank(int x)</h2><p>找数字x的排名。<br>因为维护了子树和，所以这个还是容易实现的，每次根据当前节点与x的大小关系，比x大就去左儿子找，比x小就去右儿子找(答案加上左儿子的元素与该节点的重复元素的数)，相等就可以返回了。<br><strong>最后有事没事splay一下x</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_rank</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//查x的排名；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!now) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;A[now].v)&#123;</span><br><span class="line">            now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=A[A[now].ch[<span class="number">0</span>]].sum;</span><br><span class="line">            <span class="keyword">if</span> (x==A[now].v) &#123;</span><br><span class="line">                splay(now);</span><br><span class="line">                <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=A[now].recy;</span><br><span class="line">            now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="find-num-int-rank"><a href="#find-num-int-rank" class="headerlink" title="find_num(int rank)"></a>find_num(int rank)</h2><p>查找排名为rank的数字<br>与上一个相似，只是判断去左右儿子的条件改为rank与当前节点左子树的元素个数。具体见代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> rank)</span><span class="comment">//查排名为rank的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rank&gt;SUM) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[now].ch[<span class="number">0</span>]&amp;&amp;A[A[now].ch[<span class="number">0</span>]].sum&gt;=rank)</span><br><span class="line">        now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rank-=A[now].ch[<span class="number">0</span>]?A[A[now].ch[<span class="number">0</span>]].sum:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank&lt;=A[now].recy) <span class="keyword">return</span> A[now].v;</span><br><span class="line">            rank-=A[now].recy;</span><br><span class="line">            now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="find-pre"><a href="#find-pre" class="headerlink" title="find_pre()"></a>find_pre()</h2><p>查找根节点的前驱。<br>x的前驱就是比x小的最大的数，在平衡树上的体现就是左子树上最右边的数。代码很好写。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = A[root].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(A[now].ch[<span class="number">1</span>]) now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="find-last"><a href="#find-last" class="headerlink" title="find_last()"></a>find_last()</h2><p>查找根节点的后继。<br>x的后继就是比x大的最小的数，即右子树上最左边的数。代码与上一个相似。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = A[root].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(A[now].ch[<span class="number">0</span>]) now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="del-int-x"><a href="#del-int-x" class="headerlink" title="del(int x)"></a>del(int x)</h2><p>删除值x。<br>对于删除点的操作是有点麻烦的。。。</p>
<ul>
<li>首先我们把x对应的节点splay到根节点。</li>
<li>特判掉左右儿子有不存在的情况，左儿子不存在就直接以右儿子为根，右儿子不存在就直接以左儿子为根，或者左右儿子都不存在就把根归零，然后干脆利落的删掉就可以了。</li>
<li>大部分时候显然左右儿子都是有的，这时候我们在把x的前驱(就叫他pre吧)splay到根节点，这时候可以想象得到，pre为根，x会是他的右儿子，而且x的左儿子为空(因为前驱和x是最相近的两个数嘛)，这时候我们把pre的右儿子连向x的右儿子，然后删掉x即可，记得更新pre的节点数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!now) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[now].v==x) <span class="keyword">return</span> now;</span><br><span class="line">        now = A[now].ch[A[now].v&lt;x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    A[x].ch[<span class="number">0</span>] = A[x].ch[<span class="number">1</span>] = A[x].fa = <span class="number">0</span>;</span><br><span class="line">    A[x].recy = A[x].sum = <span class="number">0</span>;</span><br><span class="line">    A[x].v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//删除X</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> is = <span class="built_in">find</span>(x); </span><br><span class="line">    <span class="keyword">if</span> (is==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    SUM--;</span><br><span class="line">    splay(is);</span><br><span class="line">    <span class="keyword">if</span> (A[root].recy&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        A[root].recy--;</span><br><span class="line">        update(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">0</span>]&amp;&amp;!A[root].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        clean(root);</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> old_root = root;</span><br><span class="line">        root = A[root].ch[<span class="number">1</span>];</span><br><span class="line">        A[root].fa = <span class="number">0</span>;</span><br><span class="line">        clean(old_root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> old_root = root;</span><br><span class="line">        root = A[root].ch[<span class="number">0</span>];</span><br><span class="line">        A[root].fa = <span class="number">0</span>;</span><br><span class="line">        clean(old_root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre = find_pre();</span><br><span class="line">    splay(pre);</span><br><span class="line">    <span class="keyword">int</span> old_root = A[pre].ch[<span class="number">1</span>];</span><br><span class="line">    A[pre].ch[<span class="number">1</span>] = A[old_root].ch[<span class="number">1</span>];</span><br><span class="line">    A[A[old_root].ch[<span class="number">1</span>]].fa = pre;</span><br><span class="line">    clean(old_root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="留坑再补"><a href="#留坑再补" class="headerlink" title="留坑再补"></a>留坑再补</h2><h1 id="结言"><a href="#结言" class="headerlink" title="结言"></a>结言</h1>写完了高中的大恐惧splay之后才发现。。。这个也不难阿。。。。只是长而已。。。<br><a href="https://www.luogu.com.cn/problem/P3369" target="_blank" rel="noopener">模板题</a><br>附上我188行的垃圾代码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> recy;<span class="comment">//在该节点的值的重复个数</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//以该节点为根的子树的元素的个数(包含该节点，不是节点数，因为一个节点可能包含多个元素)</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];<span class="comment">//左右儿子，左为0，右为1</span></span><br><span class="line">    <span class="keyword">int</span> fa;<span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">int</span> v;<span class="comment">//值</span></span><br><span class="line">&#125;A[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>,root=<span class="number">0</span>,SUM=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_which</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[A[x].fa].ch[<span class="number">1</span>]==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">    A[x].sum = A[x].recy;</span><br><span class="line">    <span class="keyword">if</span> (A[x].ch[<span class="number">1</span>]) A[x].sum+=A[A[x].ch[<span class="number">1</span>]].sum;</span><br><span class="line">    <span class="keyword">if</span> (A[x].ch[<span class="number">0</span>]) A[x].sum+=A[A[x].ch[<span class="number">0</span>]].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = A[x].fa,g_fa = A[fa].fa,ww = get_which(x),w2=get_which(fa);</span><br><span class="line">    A[fa].ch[ww] = A[x].ch[ww^<span class="number">1</span>];</span><br><span class="line">    A[A[x].ch[ww^<span class="number">1</span>]].fa = fa;</span><br><span class="line">    A[fa].fa = x;</span><br><span class="line">    A[x].fa = g_fa;</span><br><span class="line">    A[x].ch[ww^<span class="number">1</span>] = fa;</span><br><span class="line">    <span class="keyword">if</span> (g_fa)</span><br><span class="line">    A[g_fa].ch[w2] = x;</span><br><span class="line">    update(fa);</span><br><span class="line">    update(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa;fa=A[x].fa;rotate(x))</span><br><span class="line">    <span class="keyword">if</span> (A[fa].fa)</span><br><span class="line">    rotate((get_which(x)==get_which(fa))?fa:x);</span><br><span class="line">    root = x;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        A[cnt].ch[<span class="number">0</span>]=A[cnt].ch[<span class="number">1</span>]=A[cnt].fa=<span class="number">0</span>;</span><br><span class="line">        A[cnt].v = x;</span><br><span class="line">        A[cnt].sum = A[cnt].recy = <span class="number">1</span>;</span><br><span class="line">        root = cnt;</span><br><span class="line">        SUM++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = root,fa=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[now].v==x)&#123;</span><br><span class="line">            A[now].recy++;</span><br><span class="line">            update(now);</span><br><span class="line">            update(fa);</span><br><span class="line">            splay(now);</span><br><span class="line">            SUM++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa = now;</span><br><span class="line">        now = A[now].ch[A[now].v&lt;x];</span><br><span class="line">        <span class="keyword">if</span> (!now)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            A[fa].ch[A[fa].v&lt;x] = cnt;</span><br><span class="line">            A[cnt].fa = fa;</span><br><span class="line">            A[cnt].ch[<span class="number">0</span>]=A[cnt].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            A[cnt].recy = A[cnt].sum = <span class="number">1</span>;</span><br><span class="line">            A[cnt].v = x;</span><br><span class="line">            splay(cnt);</span><br><span class="line">            SUM++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_rank</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//查x的排名；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!now) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;A[now].v)&#123;</span><br><span class="line">            now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=A[A[now].ch[<span class="number">0</span>]].sum;</span><br><span class="line">            <span class="keyword">if</span> (x==A[now].v) &#123;</span><br><span class="line">                splay(now);</span><br><span class="line">                <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=A[now].recy;</span><br><span class="line">            now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> rank)</span><span class="comment">//查排名为rank的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rank&gt;SUM) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[now].ch[<span class="number">0</span>]&amp;&amp;A[A[now].ch[<span class="number">0</span>]].sum&gt;=rank)</span><br><span class="line">        now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rank-=A[now].ch[<span class="number">0</span>]?A[A[now].ch[<span class="number">0</span>]].sum:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank&lt;=A[now].recy) <span class="keyword">return</span> A[now].v;</span><br><span class="line">            rank-=A[now].recy;</span><br><span class="line">            now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!now) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[now].v==x) <span class="keyword">return</span> now;</span><br><span class="line">        now = A[now].ch[A[now].v&lt;x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = A[root].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(A[now].ch[<span class="number">1</span>]) now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = A[root].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(A[now].ch[<span class="number">0</span>]) now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    A[x].ch[<span class="number">0</span>] = A[x].ch[<span class="number">1</span>] = A[x].fa = <span class="number">0</span>;</span><br><span class="line">    A[x].recy = A[x].sum = <span class="number">0</span>;</span><br><span class="line">    A[x].v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//删除X</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> is = <span class="built_in">find</span>(x); </span><br><span class="line">    <span class="keyword">if</span> (is==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    SUM--;</span><br><span class="line">    splay(is);</span><br><span class="line">    <span class="keyword">if</span> (A[root].recy&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        A[root].recy--;</span><br><span class="line">        update(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">0</span>]&amp;&amp;!A[root].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        clean(root);</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> old_root = root;</span><br><span class="line">        root = A[root].ch[<span class="number">1</span>];</span><br><span class="line">        A[root].fa = <span class="number">0</span>;</span><br><span class="line">        clean(old_root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> old_root = root;</span><br><span class="line">        root = A[root].ch[<span class="number">0</span>];</span><br><span class="line">        A[root].fa = <span class="number">0</span>;</span><br><span class="line">        clean(old_root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre = find_pre();</span><br><span class="line">    splay(pre);</span><br><span class="line">    <span class="keyword">int</span> old_root = A[pre].ch[<span class="number">1</span>];</span><br><span class="line">    A[pre].ch[<span class="number">1</span>] = A[old_root].ch[<span class="number">1</span>];</span><br><span class="line">    A[A[old_root].ch[<span class="number">1</span>]].fa = pre;</span><br><span class="line">    clean(old_root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,opt,num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;opt,&amp;num);</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">1</span>) &#123;insert(num);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">2</span>) &#123;del(num);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">3</span>) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find_rank(num));<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">4</span>) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find_num(num));<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">5</span>) &#123;insert(num);<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,A[find_pre()].v);del(num);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">6</span>) &#123;insert(num);<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,A[find_last()].v);del(num);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机相关总结</title>
    <url>/2020/01/15/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h1><ul>
<li>Trie树</li>
<li>KMP<a id="more"></a>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1>给定多个模式串和文本串，求模式串在文本串中的出线次数记相关问题。<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="trie树上的匹配"><a href="#trie树上的匹配" class="headerlink" title="trie树上的匹配"></a>trie树上的匹配</h2>所谓AC自动机，其实就是trie树在KMP的思想下进行优化。对于多个模式串的匹配问题可以想到只用trie树显然也是可以做对的，只是复杂度是$N^2$级别的，不可接受。<br>具体来说，比如我们给出模式串acbc,bc,c.然后建树如下：<br><img src="/2020/01/15/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/AC1.jpg" alt="AC1"><br>我们去匹配文本串acbc，假设我们只是单纯的trie树匹配，那么方法就是先匹配a开头的串，再匹配c开头的串，再匹配b开头的串，再匹配c开头的串，就与普通的单串暴力匹配子串有些类似，这样就效率有些慢，而我们发现如果我们匹配第一个串ac碰到c的时候，完全可能将第三个模式串的贡献算一遍，在匹配到acbc的时候，也可以把bc和c的贡献都去算一遍，这样实际只需要匹配一遍就可，每匹配一个字符都可以把他们可能产生的贡献都去记录一遍。这样我们可以构建一个失配指针fail去实现这个。<h2 id="构建fail指针"><a href="#构建fail指针" class="headerlink" title="构建fail指针"></a>构建fail指针</h2>fail指针具体来说是什么呢？<br>（其实严格来将并不一定是失配了才需要用到fail指针，只是一个名字而已）他的作用就是每匹配到一个字符，都去找他可能产生的其他串的贡献。一个i节点字符串是从root到i路径上的节点构成的，我们让i的fail指针指向一个深度最深的，其前缀与i串的后缀相同的节点j即可构建出来的fail指正大概长这样——<br><img src="/2020/01/15/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/AC2.png" alt="AC2"><br>显然在跳fail指针的过程中深度一定是递减的(因为是后缀嘛。。跳过去深度只能小于等于原来的，但是如果等于那不就是原串了嘛，所以一定是递减的)，所以每次最多跳(深度)次,每一个字符都跳的话是n,总复杂度大概n*(模式串最长长度)这个样子。<br>构建过程是采用bfs的形式，首先构建出来trie树，然后在trie树上做bfs,遍历某个节点的所有子节点:</li>
<li>如果子节点存在，则使子节点入队，并让子节点的fail指针指向该节点的fail指针指向的节点的对应子节点；</li>
<li>如果子节点不存在，则使得该子节点指向其fail指针所指向节点的对应子节点。</li>
<li>初始条件是root节点的所有子节点的fail指针都指向root(显然)。</li>
</ul>
<p>(具体想不太明白也没啥，这个地方背板子就行)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">       <span class="keyword">if</span> (AC[<span class="number">0</span>].vis[i]) </span><br><span class="line">       &#123;</span><br><span class="line">           AC[AC[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">            Q.push(AC[<span class="number">0</span>].vis[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    AC[<span class="number">0</span>].fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (AC[x].vis[i])&#123;</span><br><span class="line">                AC[AC[x].vis[i]].fail = AC[AC[x].fail].vis[i];</span><br><span class="line">                Q.push(AC[x].vis[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            AC[x].vis[i] = AC[AC[x].fail].vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>在trie树上每匹配一个字符，就把相应的贡献通过跳fail指针算一遍，因为处理过不存在的子节点，所以每次匹配都会到他应该有的位置。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AC_Query</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        now = AC[now].vis[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = now;t&amp;&amp;AC[t].<span class="built_in">end</span>!=<span class="number">-1</span>;t=AC[t].fail)&#123;</span><br><span class="line">            ans+= AC[t].<span class="built_in">end</span>;</span><br><span class="line">            AC[t].<span class="built_in">end</span> = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><a href="https://www.luogu.com.cn/problem/P3808" target="_blank" rel="noopener"><strong>洛谷P3808 AC自动机</strong></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">&#125;AC[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (AC[now].vis[id]==<span class="number">0</span>)&#123;</span><br><span class="line">            AC[now].vis[id] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = AC[now].vis[id];</span><br><span class="line">    &#125;</span><br><span class="line">    AC[now].<span class="built_in">end</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">       <span class="keyword">if</span> (AC[<span class="number">0</span>].vis[i]) </span><br><span class="line">       &#123;</span><br><span class="line">           AC[AC[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">            Q.push(AC[<span class="number">0</span>].vis[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    AC[<span class="number">0</span>].fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (AC[x].vis[i])&#123;</span><br><span class="line">                AC[AC[x].vis[i]].fail = AC[AC[x].fail].vis[i];</span><br><span class="line">                Q.push(AC[x].vis[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            AC[x].vis[i] = AC[AC[x].fail].vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AC_Query</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        now = AC[now].vis[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = now;t&amp;&amp;AC[t].<span class="built_in">end</span>!=<span class="number">-1</span>;t=AC[t].fail)&#123;</span><br><span class="line">            ans+= AC[t].<span class="built_in">end</span>;</span><br><span class="line">            AC[t].<span class="built_in">end</span> = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        build(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Get_fail();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;AC_Query(s)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="https://www.luogu.com.cn/problem/P3796" target="_blank" rel="noopener">加强版</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">&#125;AC[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (AC[now].vis[id]==<span class="number">0</span>)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) AC[cnt].vis[i] = <span class="number">0</span>;</span><br><span class="line">            AC[cnt].<span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">            AC[cnt].fail = <span class="number">0</span>;</span><br><span class="line">            AC[now].vis[id] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = AC[now].vis[id];</span><br><span class="line">    &#125;</span><br><span class="line">    AC[now].<span class="built_in">end</span>=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">       <span class="keyword">if</span> (AC[<span class="number">0</span>].vis[i]) </span><br><span class="line">       &#123;</span><br><span class="line">           AC[AC[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">            Q.push(AC[<span class="number">0</span>].vis[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    AC[<span class="number">0</span>].fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (AC[x].vis[i])&#123;</span><br><span class="line">                AC[AC[x].vis[i]].fail = AC[AC[x].fail].vis[i];</span><br><span class="line">                Q.push(AC[x].vis[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            AC[x].vis[i] = AC[AC[x].fail].vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AC_Query</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        now = AC[now].vis[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = now;t;t=AC[t].fail)&#123;</span><br><span class="line">            num[AC[t].<span class="built_in">end</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> ss[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) AC[<span class="number">0</span>].vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ss[i];</span><br><span class="line">        build(ss[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    Get_fail();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) num[i]=<span class="number">0</span>;</span><br><span class="line">    AC_Query(s);</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (temp&lt;num[i]) temp = num[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (temp==num[i]) <span class="built_in">cout</span>&lt;&lt;ss[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="https://www.luogu.com.cn/problem/P5357" target="_blank" rel="noopener"><strong>二次加强版</strong></a><br>实际上fail指针满足拓扑结构，所以可以在fail指针上做拓扑DP<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">&#125;AC[<span class="number">2000001</span>];</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">2000051</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">2000001</span>];</span><br><span class="line"><span class="keyword">int</span> anss[<span class="number">200051</span>];</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">2000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (AC[now].vis[id]==<span class="number">0</span>)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            AC[now].vis[id] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = AC[now].vis[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!AC[now].<span class="built_in">end</span>)AC[now].<span class="built_in">end</span> = v;</span><br><span class="line">    Map[v] = AC[now].<span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">       <span class="keyword">if</span> (AC[<span class="number">0</span>].vis[i]) </span><br><span class="line">       &#123;</span><br><span class="line">           AC[AC[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">            Q.push(AC[<span class="number">0</span>].vis[i]);</span><br><span class="line">            in[<span class="number">0</span>]++;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (AC[x].vis[i])&#123;</span><br><span class="line">                AC[AC[x].vis[i]].fail = AC[AC[x].fail].vis[i];</span><br><span class="line">                in[AC[AC[x].vis[i]].fail]++;</span><br><span class="line">                Q.push(AC[x].vis[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            AC[x].vis[i] = AC[AC[x].fail].vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AC_Query</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        now = AC[now].vis[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        anss[now]++;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> ss[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        build(s,i);</span><br><span class="line">    &#125;</span><br><span class="line">    Get_fail();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    AC_Query(s);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span> (in[i]==<span class="number">0</span>) Q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();     </span><br><span class="line">        num[AC[x].<span class="built_in">end</span>] = anss[x]; </span><br><span class="line">        Q.pop();</span><br><span class="line">        in[AC[x].fail]--;</span><br><span class="line">        anss[AC[x].fail]+=anss[x];</span><br><span class="line">        <span class="keyword">if</span> (in[AC[x].fail]==<span class="number">0</span>) Q.push(AC[x].fail);</span><br><span class="line">     </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;num[Map[i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="然而我只会敲板子QAQAQAQ"><a href="#然而我只会敲板子QAQAQAQ" class="headerlink" title="然而我只会敲板子QAQAQAQ"></a>然而我只会敲板子QAQAQAQ</h1>]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Educational Round 80</title>
    <url>/2020/01/15/Codeforces-Educational-Round-80/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定d,n,求x+$\lceil\frac d {x+1}\rceil$的值能否小于等于n<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>实际上没啥好纠结的，对号函数嘛，一定在x取$\sqrt d$附近的时候取最小，所以就在呢个点附近求一下就好了。~为这道水题纠结半天真的不值得QAQ~</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,d;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (d%(x+<span class="number">1</span>)) ans++;</span><br><span class="line">    ans+=d/(x+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;d);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ss = <span class="built_in">sqrt</span>(d);</span><br><span class="line">        <span class="comment">// long long ss = 0;</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l = <span class="built_in">max</span>(ss<span class="number">-100</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">0</span>);l&lt;=<span class="built_in">min</span>(ss+<span class="number">100</span>,n<span class="number">-1</span>);l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;l&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (l+f(l)&lt;=n) flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定范围A,B，问有多少个数对(a,b)  (1\&lt;=a\&lt;=A,1\&lt;=b\&lt;=B),满足a*b+a+b=conc(a,b)。conc(a,b)即将两个数当字符串连接起来，比如conc(12,34)=1234.</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>后边的连接显然就是a乘上一个10的幂加b的形式，等式两边同时-b，然后左边可以合并同类项，等号两边再约去a，结果就是b+1=$10^?$的形式。显然可以发现，最后符合条件的数对，b一定是个$10^?-1$,即9,99,999….而a可以取任意值。所以就。。。。随便做了。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=temp)&#123;</span><br><span class="line">    temp = temp*<span class="number">10</span>+<span class="number">9</span>;</span><br><span class="line">    ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> A,B;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;A,&amp;B);</span><br><span class="line">        cout&lt;&lt;A*bit(B)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>emmmmm,感觉已经够简练了，没啥好概括的，直接上题面趴。。。。。<br><a href="http://codeforces.com/contest/1288/problem/C" target="_blank" rel="noopener"><strong>Two Arrays</strong></a></p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>注意到a,b一定是两个有序序列，而且a的末尾一定小于等于b的末尾。因此显然有dp做法——dp[i][j]代表长度为i以j结尾的序列有多少种,转移方程为——<script type="math/tex">dp[i][j] = \sum_{k=1}^ndp[i-1][k]</script>边界条件dp[1][?] = 1。处理之后再用长度为m的dp数据再算一遍即可(因为对a,b序列的处理几乎是一样的，所以算一遍dp数组正反着用就可以了).复杂度O($n^2m$)….某黄姓大仙还有O(mn)的算法，太顶了%%%%</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">11</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> k=<span class="number">1</span>;k&lt;=j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">            dp[i][j]+=dp[i<span class="number">-1</span>][k];</span><br><span class="line">            dp[i][j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">            temp += dp[m][j];</span><br><span class="line">            temp %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=dp[m][i]*temp;</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定n个长度为m的数列，你可以将两个数列合并为一个长度同为m的新数列，从而使得新数列的对应位置的数字为两原数列对应数字的最大值，问合并哪两个数列可以使的合并后得到的数列的最小值最大。</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>在看到最小值最大这种条件的时候就应该反应出来这道题大概率是个二分答案了，事实上也就是个二分答案。如何验证一个答案是否可行呢，因为m特别小，所以可以考虑每次都状态压缩一下每一个数列。假设验证的是x，则如果数列的某个数大于等于x,则在对应位赋值1,否则为0,这样一来枚举每一个数列的子集，看他的补集是否存在即可验证答案正确性，也许会有答案为不存在的数，但是继续二分最终答案一定是某一个x等于某个数列值的答案，因此正确性可以保证。<br>复杂度O($2^m*n\log n$)</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">300010</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> vis[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Map[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,ansl,ansr;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">if</span> (a[i][j]&gt;=x) temp|=(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>));</span><br><span class="line">        vis[temp] = i;</span><br><span class="line">        Map[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> zz = (<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;j++)</span><br><span class="line">        <span class="keyword">if</span> ((j|Map[i])&lt;=Map[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[(~j)&amp;zz]!=<span class="number">0</span>)&#123;</span><br><span class="line">                ansl = i,ansr = vis[(~j)&amp;zz];</span><br><span class="line">                flag = <span class="literal">true</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (judge(mid))&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ansl&lt;&lt;<span class="string">" "</span>&lt;&lt;ansr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定n,你得到一个1,2,3,4,5,6,7…n-1,n的序列，再给定m，有m次操作，每次指定一个数，将该数移动到队首，该数字前面的数字顺次前移，后面的数字不变，比如一开始为[1,2,3,4,5]，指定3，得到[3,1,2,4,5],再指定4，得到[4,3,1,2,5],以此类推。。。问，所有操作结束后每个数字最靠前和最靠后的位置分别是多少。</p>
<h2 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h2><p>题目很唬人，让人联想到一堆恐怖的数据结构，然而实际上树状数组就可以做。</p>
<ul>
<li>先来考虑最靠前的位置，显然每次对x操作都只会影响x以及其之前的数的位置，而且只有x的位置会变小，也就是说，每次操作只需要维护x的最小位置即可(实际上最小位置只有他的原位置和1这两种情况)。</li>
<li>对于最靠后的位置，对于数x操作的时候查一下他前面有几个数，从而维护一下x的最靠后位置，其他受影响的数并不需要去每次都维护，只需要最后所有操作结束后再维护一遍即可，查找前面有几个数可以用树状数组维护。</li>
<li>对于树状数组的使用，可以一开始对1~m留空，使用m+1~m+n，每个点赋值1表示每一个数，这样在求某个元素的位置就是取他的前缀和。然后每次操作对该数对应的位置-1，在前面的新位置+1,每个数对应的位置额外开个数组维护一下即可。</li>
</ul>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T[<span class="number">600100</span>],Map[<span class="number">300100</span>],A[<span class="number">300100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=sum)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x]+=v;</span><br><span class="line">        x+=x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=T[x];</span><br><span class="line">        x-=x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    sum = n+m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;insert(m+i,<span class="number">1</span>);Map[i] = m+i;&#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)A[i][<span class="number">1</span>]=A[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=m,x;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        A[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> is = query(Map[x]);</span><br><span class="line">        A[x][<span class="number">1</span>] = <span class="built_in">max</span>(A[x][<span class="number">1</span>],is);</span><br><span class="line">        insert(Map[x],<span class="number">-1</span>);</span><br><span class="line">        insert(i,<span class="number">1</span>);</span><br><span class="line">        Map[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> is = query(Map[i]);</span><br><span class="line">        A[i][<span class="number">1</span>] = <span class="built_in">max</span>(A[i][<span class="number">1</span>],is);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,A[i][<span class="number">0</span>],A[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数相关总结</title>
    <url>/2020/01/13/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>欧拉函数$\phi(n)$表示小于等于n的正整数中与n互质的数的数目<br><a id="more"></a></p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ul>
<li>积性函数~虽然我不会证~</li>
<li>$\phi(1)=1$</li>
<li>对于质数n,$\phi(n)=n-1$</li>
<li>对于质数的幂次方，$n=p^k$,则有$\phi(n)=p^{k-1}*(p-1)$</li>
</ul>
<p>对于性质4,k=1是显然是成立的，那么我们假设在性质4在k-1的条件下成立，对于1~$p^k$,每一个数都可以表示成$a*p^{k-1}+b$的形式，($0&lt;=a&lt;=p-1$,$1&lt;=b&lt;=p^k$),因为符合欧拉函数定义的数一定其中的b一定不存在因子p,所以对于每一轮b在1到$p^k$的过程中，有贡献的次数刚好是$\phi(p^{k-1})$,一共p轮，所以有$\phi(p^k)$=$p*\phi(p^{k-1})$=$p*p^{k-2}*(p-1)$</p>
<h1 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h1><p>根据唯一分解定理，n=$p_1^{k_1}p_2^{k_2}p_3^{k_3}…p_s^{k_s}$,然后可以根据积性函数的性质有n=$\phi(p_1^{k_1})\phi(p_2^{k_2})\phi(p_3^{k_3}…$<br>然后带入性质4可得$\phi(n)$=$n*\prod_{i=1}^s{\frac{p_i-1}{p_i}}$<br>然后就可以根据这条性质去求了——</p>
<ul>
<li>只求一个或者几个<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i*i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p%i) <span class="keyword">continue</span>;</span><br><span class="line">        ans = ans/i*(i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(p%i==<span class="number">0</span>) p/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p&gt;<span class="number">1</span>) ans = ans/p*(p<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线性筛法<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> E[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++) E[i] = <span class="number">0</span>;</span><br><span class="line">    E[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!E[i])&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&lt;=maxn;j+=i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!E[j])E[j] = j;</span><br><span class="line">            E[j]=E[j]/i*(i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些反演性质"><a href="#一些反演性质" class="headerlink" title="一些反演性质"></a>一些反演性质</h1></li>
<li>n = $\sum_{d|n}^n\phi(d)$</li>
<li>$\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)==1]$=$2(\sum_{i=1}^n\phi(i))-1$<br><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4804" target="_blank" rel="noopener"><strong>BZOJ4804 欧拉心算</strong></a><br>求$\sum_{x=1}^n\sum_{y=1}^n/phi(gcd(x,y))$<br>原式=$\sum_{d=1}^n\phi(d)\sum_{x=1}^{n \over d}\sum_{y=1}^{n \over d} [gcd(x,y)==1]$=$\sum_{d=1}^n\phi(d)(2(\sum_{i=1}^{n \over d}\phi(i))-1)$<br>然后做一个前缀和预处理和整除分块就OJBK了</li>
<li>分块部分<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>;l&lt;=N;l++)&#123;</span><br><span class="line">         <span class="keyword">long</span> <span class="keyword">long</span> r = N/(N/l);</span><br><span class="line">         <span class="comment">//do something (块的左端点是N/l,右端点是r)</span></span><br><span class="line">         l = r;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
<li>Code<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> E[<span class="number">10000010</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> maxn = <span class="number">10000000</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++) E[i] = <span class="number">0</span>;</span><br><span class="line">    E[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;=maxn;j+=i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (E[j]==<span class="number">0</span>) E[j] = j;</span><br><span class="line">            E[j] = E[j]/i*(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    init();</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++) sum[i] = sum[i<span class="number">-1</span>]+E[i];</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>;l&lt;=N;l++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> r = N/(N/l);</span><br><span class="line">            ans2+=(sum[r]-sum[l<span class="number">-1</span>])*(<span class="number">2</span>*sum[N/l]<span class="number">-1</span>);</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1>若gcd(a,m)=1,$a^{\phi(m)} \equiv 1\pmod m$ <h1 id="拓展欧拉定理"><a href="#拓展欧拉定理" class="headerlink" title="拓展欧拉定理"></a>拓展欧拉定理</h1><img src="/2020/01/13/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/拓展欧拉函数.jpg" alt="拓展欧拉函数"><br><a href="https://www.luogu.com.cn/problem/P5091" target="_blank" rel="noopener"><strong>洛谷模板 欧拉定理</strong></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b%a,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i*i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p%i) <span class="keyword">continue</span>;</span><br><span class="line">        ans = ans/i*(i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(p%i==<span class="number">0</span>) p/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p&gt;<span class="number">1</span>) ans = ans/p*(p<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,m,b;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> A,<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = A%m;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&amp;<span class="number">1</span>) ans=ans*temp%m;</span><br><span class="line">        temp = temp*temp%m;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ol = phi(m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">int</span> pp = <span class="number">0</span>;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;s[pp]!=<span class="string">'\0'</span>;pp++)</span><br><span class="line">    &#123;</span><br><span class="line">        b = b*<span class="number">10</span>+(s[pp]-<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span> (b&gt;=ol) flag = <span class="literal">true</span>;</span><br><span class="line">        b%=ol;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gcd(a,m)==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mi(a,b%ol)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="built_in">cout</span>&lt;&lt;mi(a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;mi(a,b%ol+ol)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher算法总结</title>
    <url>/2020/01/12/Manacher%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>O(n)复杂度计算一个字符串的回文子串的算法<br><a id="more"></a></p>
<h1 id="具体来说"><a href="#具体来说" class="headerlink" title="具体来说"></a>具体来说</h1><p>对于计算一个字符串的回文子串，暴力算法显然就是枚举每一个字符作为回文中心点，暴力去寻找他的边界，复杂度是O($n^2$)的。所以Manacher算法是极为优秀的，只不过适用范围有点小（大概）。具体实现的话这样做——</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul>
<li>在每两个字符之间插入一个不会出现的字符，如’#’或’$’,使得所有偶长度回文串都变为奇长度的</li>
<li>定义p[i]为第i个字符的回文半径，mx为已经处理过的回文串能达到的最远的位置，id为对应最远回文子串的回文中心，j为当前正在处理的回文中心的关于id的对称点;<br><img src="/2020/01/12/Manacher%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/A.png" alt="AA"><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2>当扫到第i个的时候，对其对称点j为回文中心的回文子串进行判断，</li>
<li>如果该回文串包含在id回文串的内部，则p[i]=p[j];</li>
<li>如果该回文串超出了id回文串，则以i为中心的回文串的右边界显然不会超过mx,所以有p[i]=mx-i;</li>
<li>如果该回文子串的左边界与id串的左边界刚好重合，则不确定后面是否还有可以继续匹配的串，这时候继续从mx向后暴力匹配，并更新mx和id即可。<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>Poj3974 回文串板子题<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">" "</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">3000010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3000010</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">3000100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ss);</span><br><span class="line">        <span class="keyword">if</span> (ss[<span class="number">0</span>]==<span class="string">'E'</span>&amp;&amp;ss[<span class="number">1</span>]==<span class="string">'N'</span>&amp;&amp;ss[<span class="number">2</span>]==<span class="string">'D'</span>&amp;&amp;ss[<span class="number">3</span>]==<span class="string">'\0'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ss);</span><br><span class="line">        s[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            s[<span class="number">2</span>*i+<span class="number">1</span>] = ss[i];</span><br><span class="line">            s[<span class="number">2</span>*i+<span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[<span class="number">2</span>*len+<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;len&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            p[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=mx) &#123;</span><br><span class="line">                id = i;</span><br><span class="line">                <span class="keyword">while</span>(id-p[i]&gt;=<span class="number">0</span>&amp;&amp;id+p[i]&lt;len&amp;&amp;s[id+p[i]]==s[id-p[i]])p[i]++;</span><br><span class="line">                p[i]--;</span><br><span class="line">                mx = id+p[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = id*<span class="number">2</span>-i;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">2</span>*id-mx;</span><br><span class="line">            <span class="comment">// debug(i);debug(j);debug(id);debug(l);debug(mx);cout&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;id&lt;&lt;" "&lt;&lt;l&lt;&lt;" "&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span> (j-p[j]==l)&#123;</span><br><span class="line">                  p[i] = p[j];</span><br><span class="line">                id = i;</span><br><span class="line">                <span class="keyword">while</span>(id-p[i]&gt;=<span class="number">0</span>&amp;&amp;id+p[i]&lt;len&amp;&amp;s[id+p[i]]==s[id-p[i]]) p[i]++;</span><br><span class="line">                p[i]--;</span><br><span class="line">                mx = id+p[i];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (j-p[j]&gt;l) p[i] = p[j];</span><br><span class="line">            <span class="keyword">else</span>  p[i] = mx-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) </span><br><span class="line">            <span class="keyword">if</span> (p[i]&gt;ans) &#123;</span><br><span class="line">                ans = p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;cnt&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>AtcoderDwangoProgrammingContest6th</title>
    <url>/2020/01/12/AtcoderDwangoProgrammingContest6th/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>模拟题。。。看懂了就会做了，略<br><a id="more"></a></p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>~A都不知道怎么A的~</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>n个史莱姆排列在一条水平轴上(保证位置不同)，然后进行n-1次操作：</p>
<ul>
<li>除了最后一个史莱姆之外的其他任何一个史莱姆</li>
<li>将选中的史莱姆移动到他的右边一个史莱姆上</li>
<li>将该史莱姆与这个史莱姆合并<br>显然进行n-1次操作后会只剩下一个史莱姆，然后求所有选择顺序情况下(可以理解选择顺序是一个全排列)所有史莱姆移动距离的和，膜1e9+7.<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2>考虑计算每一段路需要计算的次数，那么显然对于第i段路，之后这段路之前的史莱姆可以贡献答案；然后再分别考虑每个史莱姆：</li>
<li>第i个史莱姆必然能贡献一次答案，贡献次数为(n-1)!</li>
<li>第i-1个史莱姆如果要走过第i段路，那么第i个史莱姆必定在他的前面，而在所有的选择顺序全排列里有一半的情况是第i个史莱姆选在第i-1个之前的，所以贡献次数是(n-1)!/2</li>
<li>第i-2个史莱姆如果要走过第i段路，那么第i,第i-1个史莱姆也应在他前面，而这种情况应该有1/3的情况会出现，即我们不考虑除了i,i-1,i-2之外的元素，只考虑这三个元素的排列情况，那么i-2在第三个位置的情况必然是1/3个总次数，所以贡献次数应该是(n-1)!/3</li>
<li>之后的情况以此类推，第i-j个(i-j>=1)史莱姆对第i段路的贡献次数应该是(n-1)!/j<br>然后综合一下——<br>$\sum_{i=1}^{n-1}dis_i\sum_{j=1}^i(n-1)!/j$<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mi[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">m</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = x;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = mod<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt&amp;<span class="number">1</span>) ans=ans*temp%mod;</span><br><span class="line">        temp = temp*temp%mod;</span><br><span class="line">        cnt&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N);</span><br><span class="line">    mi[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=N;i++) mi[i] = mi[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = mi[N<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> anss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tt = A[i]-A[i<span class="number">-1</span>];</span><br><span class="line">        t+=temp*m(i<span class="number">-1</span>);</span><br><span class="line">        t%=mod;</span><br><span class="line">        anss+=tt*t;</span><br><span class="line">        anss%=mod;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;anss&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces613(div2)</title>
    <url>/2020/01/11/Codeforces613-div2/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>签到题，输入n输出n+1.<br><a id="more"></a></p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个序列A,问是否有一个除了[1,n]的一个子区间使得其区间和比[1,n]的区间和要大或者相等，如果存在，则输出<strong>NO</strong>,否则输出<strong>YES</strong></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>显然直接去求它的最大区间和就好了，然后去判断这个最大区间是不是[1,n],即可输出答案。求最大区间，可以考虑先进行一遍前缀和预处理，然后对于每一个右端点r,右端点为r的区间的最大值就是sum[l-1]最小的时候的l,然后O(n)扫一遍就能都搞定了~然而连肝五个小时脑子都瓦特了，wa了五发QAQ~</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sans = <span class="number">-1e15</span>,ansl=<span class="number">0</span>,ansr=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> minl=<span class="number">1</span>,minn = <span class="number">1e11</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=n;r++)&#123; </span><br><span class="line">            <span class="keyword">if</span> (minn&gt;=sum[r<span class="number">-1</span>]) &#123;minn = sum[r<span class="number">-1</span>];minl = r;&#125;</span><br><span class="line">            <span class="keyword">if</span> (sans&lt;sum[r]-sum[minl<span class="number">-1</span>])&#123;</span><br><span class="line">                sans = sum[r]-sum[minl<span class="number">-1</span>];</span><br><span class="line">                ansl = minl;ansr = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ansl!=<span class="number">1</span>||ansr!=n) <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>求max(a,b)最小的a,b , 使得LCM(a,b) = X(X为输入值)</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>考虑，如果a,b不是互质的话，即gcd(a,b) = c(c&gt;0),那么应该存在LCM(a/c,b)=LCM(a,b)，或者LCM(a,b/c)=LCM(a,b),总之互质的a,b,总是可以得到最优答案的，具体怎么严谨得证还有待研究。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b%a,a);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/gcd(a,b)*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i,<span class="keyword">long</span> <span class="keyword">long</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;j) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> X;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;X);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> xx = <span class="built_in">sqrt</span>(X);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ansi=<span class="number">1</span>,ansj=X,anss = X;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=xx;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (X%i!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> j = X/i;</span><br><span class="line">        <span class="keyword">if</span> (gcd(i,j)==<span class="number">1</span>)&#123;   </span><br><span class="line">            <span class="keyword">if</span> (anss&gt; <span class="built_in">max</span> (i,j))&#123;</span><br><span class="line">                ansi = i;ansj = j;</span><br><span class="line">                anss = <span class="built_in">max</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ansi&lt;&lt;<span class="string">" "</span>&lt;&lt;ansj&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一组数A,设计一个数X,使得max(ai XOR X)的值最小。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>建立一课01树(trie树)，在树上做dp。</p>
<ul>
<li>如果该节点只有一个儿子或者没有儿子，那么显然这个位置可以抵消掉变成0。</li>
<li>如果这个节点有两个儿子，那么不论怎么变，这一位都一定是1，对应的值就是&amp;2^i&amp;的形式<br>最后dp解决即可<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2>写的有点乱，有些没用的东西懒得删了……<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> dep;</span><br><span class="line">&#125;N[<span class="number">3100010</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>,anss = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">3100010</span>]; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    N[x].dep=dep;</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]!=<span class="number">-1</span>) dfs(N[x].ch[<span class="number">0</span>],dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">1</span>]!=<span class="number">-1</span>) dfs(N[x].ch[<span class="number">1</span>],dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]!=<span class="number">-1</span>&amp;&amp;N[x].ch[<span class="number">1</span>]!=<span class="number">-1</span>) dp[x] = <span class="built_in">min</span>(dp[x],<span class="built_in">min</span>(dp[N[x].ch[<span class="number">0</span>]],dp[N[x].ch[<span class="number">1</span>]])+(<span class="number">1</span>&lt;&lt;(len-dep)));</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]==<span class="number">-1</span>&amp;&amp;N[x].ch[<span class="number">1</span>]!=<span class="number">-1</span>) dp[x] = <span class="built_in">min</span>(dp[x],dp[N[x].ch[<span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]!=<span class="number">-1</span>&amp;&amp;N[x].ch[<span class="number">1</span>]==<span class="number">-1</span>) dp[x] = <span class="built_in">min</span>(dp[x],dp[N[x].ch[<span class="number">0</span>]]);</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]==<span class="number">-1</span>&amp;&amp;N[x].ch[<span class="number">1</span>]==<span class="number">-1</span>) dp[x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[i]);</span><br><span class="line">        maxx = <span class="built_in">max</span>(maxx,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(maxx)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        maxx&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len--;</span><br><span class="line">    <span class="keyword">int</span> st=<span class="number">0</span>;</span><br><span class="line">    N[<span class="number">0</span>].<span class="built_in">size</span> = <span class="number">2</span>;</span><br><span class="line">    N[<span class="number">0</span>].col = <span class="number">0</span>;</span><br><span class="line">    N[<span class="number">0</span>].ch[<span class="number">1</span>] = N[<span class="number">0</span>].ch[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        st = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=len;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = (A[i]&gt;&gt;j)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (N[st].ch[x]==<span class="number">-1</span>)&#123;</span><br><span class="line">                N[st].ch[x]= ++cnt;</span><br><span class="line">                N[cnt].col = x;</span><br><span class="line">                N[cnt].ch[<span class="number">1</span>] = N[cnt].ch[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">                N[cnt].<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st = N[st].ch[x];</span><br><span class="line">            N[st].<span class="built_in">size</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;i++) dp[i] = (<span class="number">1</span>&lt;&lt;(len+<span class="number">1</span>))<span class="number">-1</span>;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoderBeginnerContest150</title>
    <url>/2020/01/11/AtCoderBeginnerContest150/</url>
    <content><![CDATA[<h1 id="zycdltxdy-喊破嗓子"><a href="#zycdltxdy-喊破嗓子" class="headerlink" title="zycdltxdy!!!!(喊破嗓子)"></a>zycdltxdy!!!!(喊破嗓子)</h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><a id="more"></a>
<p>签到题1，K*500>=X输出 <strong>YES</strong> ,K*500\&lt;X输出 <strong>NO</strong>.</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>签到题2，给一个长度为N的字符串S,问里面有几个子串‘ABC’,暴力匹配即可.</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定N,给定两个全排列P和Q,记他们在所有长度为N的字符典序的排序为a和b,求|a-b|</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>全排列的排列顺序有点类似进制数，在第i位上，Ai是第j个未出现的数字的话，那么该位的贡献就是(j-1)*(i-1)!(i是从左向右扫)。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> mi[<span class="number">10</span>],vis[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> anss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) vis[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        vis[A[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=A[i];j++) temp+=vis[j];</span><br><span class="line">        anss+=temp*mi[N-i];</span><br><span class="line">    &#125;</span><br><span class="line">    anss++;</span><br><span class="line">    <span class="keyword">return</span> anss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N);</span><br><span class="line">    mi[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) mi[i] = mi[i<span class="number">-1</span>]*i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    ans1 = solve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    ans2 = solve();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">abs</span>(ans1-ans2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一组长度为n的偶数数列A，求在0~M范围内有多少X满足：</p>
<ul>
<li>对于数列中的每一个数ai,存在一个非负整数p,使得X=ai*(p+0.5).<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2>由条件可知，对于任意一个ai(1&lt;=i&lt;=n),X是ai/2的奇数倍.<br>所以有：</li>
<li>X是所有数的最小公倍数的倍数</li>
<li>设所有数列的最小公倍数是Xmin,不能存在Xmin是ai/2的偶数倍，以为这样Xmin的所有倍数X都必然是ai/2的偶数倍<br>所以答案特别判断一下条件2,在条件2中的情况不处现时，答案就是M里Xmin的奇数倍数的个数<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd( b % a , a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        ret++;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N,M;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) A[i]/=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> tt = f(A[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tt!=f(A[i]))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> gcdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        gcdd = gcd(ans,A[i]);</span><br><span class="line">        ans = ans/gcdd; </span><br><span class="line">        ans*=A[i];</span><br><span class="line">        <span class="keyword">if</span> (ans&gt;M) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> anss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans&lt;=M)&#123;</span><br><span class="line">        M-=ans;</span><br><span class="line">        anss++;</span><br><span class="line">        <span class="keyword">if</span> (ans&gt;<span class="number">0</span>) anss+=M/(ans*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;anss&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ZYCDLTXDY"><a href="#ZYCDLTXDY" class="headerlink" title="ZYCDLTXDY!!!"></a>ZYCDLTXDY!!!</h1></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>set用法详解(雾)</title>
    <url>/2020/01/07/set%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%9B%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>set是一种基于红黑树的数据结构模板，其支持插入，删除，查找等操作。<br><a id="more"></a></p>
<ul>
<li>set中的元素是排序好的，默认从小到大</li>
<li>set中没有重复元素，multiset中可以有重复元素</li>
<li>set大部分的操作的复杂度都是log级别的<h1 id="set的常用用法"><a href="#set的常用用法" class="headerlink" title="set的常用用法"></a>set的常用用法</h1></li>
<li>begin()             返回set的第一个元素的迭代器</li>
<li>end()               返回set的最后一个元素的下一个位置的迭代器</li>
<li>clear()             删除set中所有的元素</li>
<li>empty()             判断set是否为空</li>
<li>size()              返回set中的元素个数</li>
<li>count(key_value)    返回对应元素的个数</li>
<li>erase(iterator)     删除迭代器iterator指向的值</li>
<li>erase(first,second) 删除迭代器first和second之间的值</li>
<li>erase(key_value)    删除key_value的值(erase返回值为删除的值的个数)</li>
<li>find(key_value)     返回对应值的迭代器，没有则返回end()</li>
<li>insert(key_value)   将key_value插入set，返回值是pair<set<int>::iterator,                            bool&gt;  bool是插入成功与否，iterator是插入的位置</set<int></li>
<li>insert(first,second)将定位器first与second之间的元素插入set</li>
<li>lower_bound(key_value)  返回第一个大于等于key_value的值的迭代器</li>
<li>upper_bound(key_value)  返回第一个大于key_value的值的迭代器<h1 id="改变set内部排序的方法"><a href="#改变set内部排序的方法" class="headerlink" title="改变set内部排序的方法"></a>改变set内部排序的方法</h1></li>
<li>自定义排序函数：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">camp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> struct Node &amp;a,<span class="keyword">const</span> struct Node &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------</span><br><span class="line">    <span class="built_in">set</span>&lt;struct Node,camp&gt; ss;</span><br></pre></td></tr></table></figure></li>
<li>重载结构体比较函数(&lt;)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&gt;a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeforcesHello2020</title>
    <url>/2020/01/04/CodeforcesHello2020/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><a id="more"></a>
<p>给出两组字符串，用类似天干地支纪年法的方法对应名字与年号，问某一年的名字是什么。<br><img src="/2020/01/04/CodeforcesHello2020/2345_image_file_copy_1.jpg" alt="A2"><br><img src="/2020/01/04/CodeforcesHello2020/1578154373(1" alt="A1">.jpg)</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>显然前缀名和后缀名的滚动是相互独立的，两边分别取膜即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>][<span class="number">20</span>],t[<span class="number">100</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,t[i]);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> nn = (x<span class="number">-1</span>)%n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mm = (x<span class="number">-1</span>)%m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s[nn]);i++)</span><br><span class="line">        <span class="built_in">putchar</span>(s[nn][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(t[mm]);i++)</span><br><span class="line">        <span class="built_in">putchar</span>(t[mm][i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出n组数组，随意连接任意两组数组(保持顺序不变，首尾相接)，一共有n^2种连接方法，如果一对数组中满足下述条件,则符合条件<strong>ascent</strong>:<br><img src="/2020/01/04/CodeforcesHello2020/1578154904(1" alt="B2">.jpg)<br>求符合条件的方案数。</p>
<p><img src="/2020/01/04/CodeforcesHello2020/1578155613(1" alt="B1">.jpg)</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>首先考虑，某一数组内部如果已经满足条件，那么与他连接的所有方案都满足，方案数贡献为<strong>2*(n-1)+1</strong>,然后会发现这么算会有重复，所以记temp为已经计算过的内部满足条件的数组数量，则每一个内部满足条件的数组贡献记为<strong>2*(n-temp-1)+1</strong>.</p>
<p>之后我们再考虑内部不满足条件的：对于每一个数组，记录其最大值与最小值。显然，所有最大值比本数组最小值大的数组，连接在本数组的后边一定可以贡献答案。于是我们可以扫一遍，将每组数组的最大值记录在树状数组里，再扫一遍总和答案即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mintr[<span class="number">1000100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chamin</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=<span class="number">1000010</span>)&#123;</span><br><span class="line">        mintr[x]++;</span><br><span class="line">        x+= (x&amp;(-x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;"OK"&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">querymin</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ans += mintr[x];</span><br><span class="line">        x-=x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxx,minn;</span><br><span class="line">&#125;A[<span class="number">100110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">memset</span>(mintr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mintr));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>,cnt=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,l;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;l);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tt;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> maxx=<span class="number">0</span>,minn = <span class="number">1000010</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=l;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tt);</span><br><span class="line">            tt++;</span><br><span class="line">            <span class="keyword">if</span> (tt&gt;minn&amp;&amp;minn!=<span class="number">0</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            maxx = <span class="built_in">max</span>(maxx,tt);</span><br><span class="line">            minn = <span class="built_in">min</span>(minn,tt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;ans+=<span class="number">2</span>*(n<span class="number">-1</span>-temp)+<span class="number">1</span>;temp++;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            chamin(minn);</span><br><span class="line">            A[++cnt].maxx = maxx;A[cnt].minn = minn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        ans+=querymin(A[i].maxx<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个规模n,求长度为n的所有全排列中，有多少个子序列，满足该子序列的最大值与最小值只差等于长度-1：<br><img src="/2020/01/04/CodeforcesHello2020/1578156001(1" alt="C1">.jpg)</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>数学题……~要不是打表失败了我才不会去刚他QAQ~答案就是排列组合，上过高中的都会————<br><img src="/2020/01/04/CodeforcesHello2020/gongshi1.png" alt="C2"></p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mi[<span class="number">250100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    mi[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++) mi[i] = (mi[i<span class="number">-1</span>]*i)%m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=(((i*mi[n-i+<span class="number">1</span>])%m)*mi[i])%m;</span><br><span class="line">        ans%=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出n个数据，每个数据包含两个区间段(暂且叫他们A区间与B区间)，要求任意两个数据的对应区间段，要么都重合要么都不重合，问是否符合条件，符合输出<strong>“YES”</strong>,不符输出<strong>“NO”</strong></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>N2两两判断是不可能过的，所以考虑优化。<br>首先以A的开始与结束时间作为事件发生的时间：</p>
<ul>
<li>在sa时向set插入sb与eb</li>
<li>在ea+1时消除sb与eb<br>这样只要在插入的时候查询，是否当前要插入的开始时间比所有set里的结束时间都早，是否当前要插入的结束时间比所有set里的开始时间都晚，即必须保证插入区间与set内的所有区间都冲突，才是合法的。<br>之后同理再处理一遍B区间对A区间的情况即可，复杂度nlogn.<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sa,ea,sb,eb;</span><br><span class="line">&#125;A[<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> loc,id;</span><br><span class="line">    <span class="keyword">int</span> se;</span><br><span class="line">    <span class="comment">// bool operator &lt; (const Node2&amp; b2) const&#123;</span></span><br><span class="line">    <span class="comment">//     if (loc!=b2.loc) return loc&lt;b2.loc;</span></span><br><span class="line">    <span class="comment">//     return se&lt;b2.se;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;B[<span class="number">300100</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">camp</span><span class="params">(struct Node2 a,struct Node2 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.loc==b.loc) <span class="keyword">return</span> a.se&lt;b.se;</span><br><span class="line">    <span class="keyword">return</span> a.loc&lt;b.loc;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; l;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> &gt; r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"aaa.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;A[i].sa,&amp;A[i].ea,&amp;A[i].sb,&amp;A[i].eb);</span><br><span class="line">        B[<span class="number">2</span>*i].loc = A[i].sa;B[<span class="number">2</span>*i].id = i;B[<span class="number">2</span>*i].se = <span class="number">1</span>;</span><br><span class="line">        B[<span class="number">2</span>*i+<span class="number">1</span>].loc = A[i].ea+<span class="number">1</span>;B[<span class="number">2</span>*i+<span class="number">1</span>].id = i;B[<span class="number">2</span>*i+<span class="number">1</span>].se = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(B,B+n*<span class="number">2</span>,camp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i].se==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!l.empty()&amp;&amp;!r.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span> (A[B[i].id].sb&gt;*r.<span class="built_in">begin</span>()||A[B[i].id].eb&lt;*l.<span class="built_in">begin</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            l.insert(A[B[i].id].sb);</span><br><span class="line">            r.insert(A[B[i].id].eb);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l.erase(l.<span class="built_in">find</span>(A[B[i].id].sb));</span><br><span class="line">            r.erase(r.<span class="built_in">find</span>(A[B[i].id].eb));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        B[<span class="number">2</span>*i].loc = A[i].sb;B[<span class="number">2</span>*i].id = i;B[<span class="number">2</span>*i].se = <span class="number">1</span>;</span><br><span class="line">        B[<span class="number">2</span>*i+<span class="number">1</span>].loc = A[i].eb+<span class="number">1</span>;B[<span class="number">2</span>*i+<span class="number">1</span>].id = i;B[<span class="number">2</span>*i+<span class="number">1</span>].se = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(B,B+n*<span class="number">2</span>,camp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i].se)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!l.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span> ((A[B[i].id].sa&gt;*r.<span class="built_in">begin</span>())||(A[B[i].id].ea&lt;*l.<span class="built_in">begin</span>()))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            l.insert(A[B[i].id].sa);</span><br><span class="line">            r.insert(A[B[i].id].ea);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l.erase(l.<span class="built_in">find</span>(A[B[i].id].sa));</span><br><span class="line">            r.erase(r.<span class="built_in">find</span>(A[B[i].id].ea));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>QAQAQ</title>
    <url>/2020/01/03/QAQAQ/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>内容</p>
<a id="more"></a>
<h1 id="一级标题2"><a href="#一级标题2" class="headerlink" title="一级标题2"></a>一级标题2</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul>
<li>列表1</li>
<li><p>列表2<br>  a 子列表<br>  b 子列表</p>
<hr>
<p>  普通字体</p>
<hr>
</li>
</ul>
<p><a href="sldjfl">超链接</a></p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1578657044&amp;di=e8d4f6cc7319c7b39a1c997b29aa2c81&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2Fc7c8b4a1780dc0cc40b7bd22cc52f180abf7254d1ee1c-jgx2yP_fw658" alt="QAQ"></p>
<p><em>斜体</em></p>
<p><strong>粗体</strong><br><code>单行代码块</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多行</span><br><span class="line">代码</span><br><span class="line">块</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>引用的</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
