<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BJTU寒训题组(2.18)</title>
    <url>/2020/02/18/BJTU%E5%AF%92%E8%AE%AD%E9%A2%98%E7%BB%84-2-18/</url>
    <content><![CDATA[<h1 id="C-CodeForces-740D-Alyona-and-a-tree"><a href="#C-CodeForces-740D-Alyona-and-a-tree" class="headerlink" title="C CodeForces 740D / Alyona and a tree"></a>C CodeForces 740D / Alyona and a tree</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一棵树，每条边有边权，每条点有点权，规定点u被点v控制指，点u是点v的子树中的点，且点u的点权大于等于u，v之间路径的边权和。问每一个点，有多少个被他控制的点。<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>仔细一想，这里的边权和，一定是某种纵深的形式存在的，所以我们可以用一个栈去存他的路径，而对于每一个u，他能影响到的点，或者说他能够为之贡献答案的点，一定是当前栈中路径上的后k个点，而这个k可以用二分的做法找到，这样我们直到了k就知道点u会影响他的几代父亲，这样在树上做个差分，在他的第k个父亲处-1，在当前位置+1,然后直接统计即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> nxt,to,len;</span><br><span class="line">&#125;E[<span class="number">400001</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">200000</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt].len = t;</span><br><span class="line">    E[cnt].nxt = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> val[<span class="number">200010</span>],dep[<span class="number">200010</span>],ans[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sta[<span class="number">200010</span>],top=<span class="number">0</span>,dp[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r=top;</span><br><span class="line">    <span class="keyword">int</span> anss = top<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dep[sta[top]]-dep[sta[mid]]&lt;=x)</span><br><span class="line">        &#123;</span><br><span class="line">            anss = mid<span class="number">-1</span>;</span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">    sta[++top] = x;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; </span><br><span class="line">    num = check(val[x]);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;x&lt;&lt;" "&lt;&lt;num&lt;&lt;" "&lt;&lt;sta[num]&lt;&lt;endl;</span></span><br><span class="line">    dp[x]++;</span><br><span class="line">    dp[sta[num]]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        dep[to] = dep[x]+E[i].len;</span><br><span class="line">        dfs(to);</span><br><span class="line">        dp[x]+=dp[to];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[x] = dp[x]<span class="number">-1</span>;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a,t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;t);</span><br><span class="line">        add(a,i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-CodeForces-586F-Lizard-Era-Beginning"><a href="#F-CodeForces-586F-Lizard-Era-Beginning" class="headerlink" title="F CodeForces 586F/ Lizard Era: Beginning"></a>F CodeForces 586F/ Lizard Era: Beginning</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给n个三元组，每次可以选择其中的两个，最后要求每一维选出的和在相等的前提下最大，输出方案。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>折半搜索。。。u1s1,俺也是第一次写，意思差不多是每次搜一半，将这一半的结果保存下来(坐标是第二维和第一维的差以及第三维和第一维的差，用map做个映射)，然后再去搜令一半，与前一半的结果对照，对凑出来的合法的结果进行记录并取最大值的方案即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">30</span>][<span class="number">3</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; , <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> now[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">700000</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">700000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==n/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = m[make_pair(y,z)];</span><br><span class="line">        <span class="keyword">if</span> (t&amp;&amp;val[t]&gt;=X) <span class="keyword">return</span> ;</span><br><span class="line">        ++cnt;</span><br><span class="line">        m[make_pair(y,z)] = cnt;</span><br><span class="line">        val[cnt] = X;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">        f[cnt][i] = now[i];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    now[x] = <span class="number">0</span>;<span class="comment">//1 2</span></span><br><span class="line">    dfs1(x+<span class="number">1</span>,y+a[x][<span class="number">1</span>]-a[x][<span class="number">0</span>],z-a[x][<span class="number">0</span>],X+a[x][<span class="number">0</span>]);</span><br><span class="line">    now[x] = <span class="number">1</span>;<span class="comment">//1 3</span></span><br><span class="line">    dfs1(x+<span class="number">1</span>,y-a[x][<span class="number">0</span>],z+a[x][<span class="number">2</span>]-a[x][<span class="number">0</span>],X+a[x][<span class="number">0</span>]);</span><br><span class="line">    now[x] = <span class="number">2</span>;<span class="comment">//2 3</span></span><br><span class="line">    dfs1(x+<span class="number">1</span>,y+a[x][<span class="number">1</span>],z+a[x][<span class="number">2</span>],X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = m[make_pair(-y,-z)];</span><br><span class="line">        <span class="keyword">if</span> (!t) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (ans[<span class="number">1</span>]!=<span class="number">-1</span>&amp;&amp;Max&gt;=X+val[t]) <span class="keyword">return</span>;</span><br><span class="line">        Max = X+val[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">        ans[i] = f[t][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n/<span class="number">2</span>+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans[i] = now[i];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    now[x] = <span class="number">0</span>;<span class="comment">//1 2</span></span><br><span class="line">    dfs2(x+<span class="number">1</span>,y+a[x][<span class="number">1</span>]-a[x][<span class="number">0</span>],z-a[x][<span class="number">0</span>],X+a[x][<span class="number">0</span>]);</span><br><span class="line">    now[x] = <span class="number">1</span>;<span class="comment">//1 3</span></span><br><span class="line">    dfs2(x+<span class="number">1</span>,y-a[x][<span class="number">0</span>],z+a[x][<span class="number">2</span>]-a[x][<span class="number">0</span>],X+a[x][<span class="number">0</span>]);</span><br><span class="line">    now[x] = <span class="number">2</span>;<span class="comment">//2 3</span></span><br><span class="line">    dfs2(x+<span class="number">1</span>,y+a[x][<span class="number">1</span>],z+a[x][<span class="number">2</span>],X);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a[i][<span class="number">0</span>],&amp;a[i][<span class="number">1</span>],&amp;a[i][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">    &#123;++cnt;</span><br><span class="line">    m[make_pair(<span class="number">0</span>,<span class="number">0</span>)]=cnt;</span><br><span class="line">    val[cnt] = <span class="number">0</span>;&#125;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(n/<span class="number">2</span>+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="number">1</span>]==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i]==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"LM\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans[i]==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"LW\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans[i]==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"MW\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别的题补不动了。。。<del>其实是我又菜又懒对⑧起!!QAQ</del></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>BJTU2020寒训题组(2.17)</title>
    <url>/2020/02/17/BJTU2020%E5%AF%92%E8%AE%AD%E9%A2%98%E7%BB%84/</url>
    <content><![CDATA[<h1 id="A-CodeForces-975B-Mancala"><a href="#A-CodeForces-975B-Mancala" class="headerlink" title="A CodeForces 975B / Mancala"></a>A CodeForces 975B / Mancala</h1><p>暴力模拟就好了，不谈<br><a id="more"></a></p>
<h1 id="B-CodeForces-898E-Squares-and-not-squares"><a href="#B-CodeForces-898E-Squares-and-not-squares" class="headerlink" title="B CodeForces 898E / Squares and not squares"></a>B CodeForces 898E / Squares and not squares</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给n个数(n为偶数)，你可以进行一种操作，每次可以使得某个数+1或-1,问最少要多少次操作，可以使得一半的是整数的平方，一半不是。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>对于每个数记录——</p>
<ul>
<li>如果他是平方数，最少操作几次变成非平方数</li>
<li>如果他是非平方数，最少操作几次变成平方数</li>
</ul>
<p>并记录平方数的个数。<br>最后根据记录数据与所差的平方数或者非平方数个数，优先选需要操作最少的几个数并统计答案即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">2000000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">2000000</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans2[<span class="number">2000000</span>],cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tt = <span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (tt*tt==a[i])&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (a[i]==<span class="number">0</span>) </span><br><span class="line">        ans2[++cnt2] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ans2[++cnt2] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t1 = a[i]-tt*tt;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t2 = (tt+<span class="number">1</span>)*(tt+<span class="number">1</span>)-a[i];</span><br><span class="line">            ans[++cnt] = <span class="built_in">min</span>(t1,t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num&gt;=n/<span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sort(ans2+<span class="number">1</span>,ans2+cnt2+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>,tt = num-n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;i++)</span><br><span class="line">        sum+=ans2[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sort(ans+<span class="number">1</span>,ans+cnt+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>,tt = n/<span class="number">2</span>-num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;i++)</span><br><span class="line">        sum+=ans[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-CodeForces-650B-Image-Preview"><a href="#C-CodeForces-650B-Image-Preview" class="headerlink" title="C CodeForces 650B / Image Preview"></a>C CodeForces 650B / Image Preview</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个环状的点，起点为1号，从1号可以向左到n号，n号想右可以到1号，达到一个点需要一些代价，切换到这个点需要a,在这个点本身需要b+1或者1,已经到达过的点再到达只需要花费a,问在所给代价范围内，能到达的点的个数最大是多少。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>尺取法，首先预处理只从1号向右的方向最远到达哪里，之后左端点每次向左移动一步，缩小右端点到可接受的范围内，以此类推，在所有合法区间中取最大的即可。<br>细节方面主要要仔细考虑清楚每个区间是先向左移动还是先向右移动。。。。具体见代码。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">600000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">600000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,a,b,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;n,&amp;a,&amp;b,&amp;T);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i]==<span class="string">'w'</span>) num[i] = b+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> num[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>]==<span class="string">'w'</span>) tmp+=b+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> tmp++;</span><br><span class="line">    <span class="keyword">if</span> (T&gt;=tmp) ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(tmp+a+num[r+<span class="number">1</span>]&lt;=T&amp;&amp;r+<span class="number">1</span>&lt;n) &#123;tmp+=a+num[r+<span class="number">1</span>];r++;&#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans,<span class="built_in">min</span>(n,r-l+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> kk = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans&gt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (r&lt;(n-i)) kk=<span class="number">1</span>;</span><br><span class="line">        tmp+=a*kk+num[i];</span><br><span class="line">        <span class="keyword">while</span>(tmp&gt;T&amp;&amp;r<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if (i==n-2) cout&lt;&lt;l-1&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">            tmp-=num[r];</span><br><span class="line">            <span class="keyword">if</span> (r&gt;(n-i)) tmp-=a;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (r&lt;=(n-i))</span><br><span class="line">                &#123;</span><br><span class="line">                    kk=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp-=<span class="number">2</span>*a;</span><br><span class="line">            &#125; </span><br><span class="line">            r--;</span><br><span class="line">        <span class="comment">//    if (i==n-2) cout&lt;&lt;l-1&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp&gt;T) <span class="keyword">break</span>;</span><br><span class="line">        l = i-n;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">min</span>(n,r-l+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="built_in">min</span>(n,ans));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-CodeForces-1278D-Segment-Tree"><a href="#D-CodeForces-1278D-Segment-Tree" class="headerlink" title="D CodeForces 1278D / Segment Tree"></a>D CodeForces 1278D / Segment Tree</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给n个节点，每个节点的属性为一个区间，区间相互重叠一部分的两个点之间连边(不是包含，也不是不重叠)，问最后的图是否是一个树。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>队长说的呢个离散化做的方法我给忘了QAQ,想起来再补。估计大同小异，我就说我做的….<del>背原题都背错了wtcl</del></p>
<p>首先把节点按左端点排序，然后挨个扫过去，每扫一个就把右端点放进一个set。在处理当前一个的时候，用set的lower_bound找到比当前节点左端点大或者相等的第一个点，从这个点往下找(因为set内是有序的)，每找一个点就连一下边，连边的时候用并查集稍微维护下，直到set中的值大于当前节点的右端点。</p>
<p>扫完一遍以后，检查并查集中的块的个数是不是一个，是不是连了n-1条边即可(在扫的过程中如果超过了n-1条边就可以直接跳出了，所以时间复杂度不会爆炸)。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> l,r;</span><br><span class="line">&#125;N[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct Node a,struct Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a.l==b.l)</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">	<span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> r,id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node2 A) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;r &lt; A.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;struct Node2&gt; s2;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);y=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x==y) <span class="keyword">return</span> ;</span><br><span class="line">	fa[x] = y;</span><br><span class="line">	sum--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i] = i;</span><br><span class="line">	sum=n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N[i].l,&amp;N[i].r);</span><br><span class="line">	sort(N+<span class="number">1</span>,N+n+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> <span class="title">tmp</span>;</span></span><br><span class="line">	tmp.r = N[<span class="number">1</span>].r;tmp.id = <span class="number">1</span>;</span><br><span class="line">	s2.insert(tmp);</span><br><span class="line">	<span class="built_in">set</span>&lt;struct Node2&gt;::iterator it;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		it = s2.<span class="built_in">end</span>();</span><br><span class="line">		it--;</span><br><span class="line">		<span class="keyword">if</span> ((*it).r&lt;N[i].l)&#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		tmp.r = N[i].l;</span><br><span class="line">		it = s2.lower_bound(tmp);</span><br><span class="line">		<span class="keyword">int</span> ttt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (;it!=s2.<span class="built_in">end</span>();it++)</span><br><span class="line">		<span class="keyword">if</span> ((*it).r&lt;=N[i].r) </span><br><span class="line">		&#123;</span><br><span class="line">			merge((*it).id,i);</span><br><span class="line">			ttt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		num+=ttt;</span><br><span class="line">		<span class="keyword">if</span> (num&gt;n<span class="number">-1</span>) &#123;flag = <span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">		tmp.r = N[i].r;</span><br><span class="line">		tmp.id = i;</span><br><span class="line">		s2.insert(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag&amp;&amp;num==n<span class="number">-1</span>&amp;&amp;sum==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-CodeForces-1037F-Maximum-Reduction"><a href="#E-CodeForces-1037F-Maximum-Reduction" class="headerlink" title="E CodeForces 1037F / Maximum Reduction"></a>E CodeForces 1037F / Maximum Reduction</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于下面的函数，给定初始数列a和整数k，问最后返回的答案是多少。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function z(array a, integer k):</span><br><span class="line">    if length(a) &lt; k:</span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        b &#x3D; empty array</span><br><span class="line">        ans &#x3D; 0</span><br><span class="line">        for i &#x3D; 0 .. (length(a) - k):</span><br><span class="line">            temp &#x3D; a[i]</span><br><span class="line">            for j &#x3D; i .. (i + k - 1):</span><br><span class="line">                temp &#x3D; max(temp, a[j])</span><br><span class="line">            append temp to the end of b</span><br><span class="line">            ans &#x3D; ans + temp</span><br><span class="line">        return ans + z(b, k)</span><br></pre></td></tr></table></figure>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>原函数的意思是每次都找所有的长度为k的子区间，将他们的最大值记录答案并再组成一个序列，不断递归，直到序列长度小于k.</p>
<p>题目都没咋看，直接听得吴队和蔡ls的题解，大概就是考虑每个数会对最终答案的贡献。</p>
<p>对于每个数，用单调栈取找包含他并且以他为最大值的最大的区间，这里听取蔡ls的建议，左边找大于等于的，右边找大于的，可以保证不重不漏。</p>
<p>这样我们知道了每个数统治的最大区间，我们还需要直到这个区间中会有多少个递归出的区间会包含这个数(显然包含这个数就是这个数最大)，这里我们可以用一个记忆化搜索的dp方法快速算出一个区间会递归出的所有的区间数，记为dp[len]。</p>
<p>记这个数统治的区间长度为len，其左边的长度为lenl,右边的长度为lenr,最终我们得到的就是<strong>dp[len]-dp[lenl]-dp[lenr]</strong>,即能贡献当前数的值的区间的个数，最后统计答案即可，注意取模。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">1000100</span>],r[<span class="number">1000100</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val,id;</span><br><span class="line">&#125;N[<span class="number">1000100</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000100</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">1000100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[x]&gt;<span class="number">0</span>) <span class="keyword">return</span> dp[x];</span><br><span class="line">    dp[x] = (dfs(x-k+<span class="number">1</span>)+x-k+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">return</span> dp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N[i].val);N[i].id=i;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;<span class="number">0</span>&amp;&amp;N[a[cnt]].val&lt;=N[i].val) cnt--;</span><br><span class="line">        <span class="keyword">if</span> (cnt==<span class="number">0</span>) l[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l[i] = N[a[cnt]].id+<span class="number">1</span>;</span><br><span class="line">        a[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;<span class="number">0</span>&amp;&amp;N[a[cnt]].val&lt;N[i].val) cnt--;</span><br><span class="line">        <span class="keyword">if</span> (cnt==<span class="number">0</span>) r[i] = n;</span><br><span class="line">        <span class="keyword">else</span> r[i] = N[a[cnt]].id<span class="number">-1</span>;</span><br><span class="line">        a[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = r[i]-l[i]+<span class="number">1</span>;</span><br><span class="line">        ans+=(dfs(len)-dfs(i-l[i])-dfs(r[i]-i))%mod*N[i].val%mod;</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 620(div2)</title>
    <url>/2020/02/16/Codeforces-Round-620-div2/</url>
    <content><![CDATA[<h1 id="A-Two-Rabbits"><a href="#A-Two-Rabbits" class="headerlink" title="A Two Rabbits"></a>A Two Rabbits</h1><p>签到题，不谈了</p>
<h1 id="B-Longest-Palindrome"><a href="#B-Longest-Palindrome" class="headerlink" title="B Longest Palindrome"></a>B Longest Palindrome</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给n个长度均为m的字符串，让你选取其中若干个，首尾相连组成一个回文串，输出最长的回文串长度以及对应的串.<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>因为数据范围很小，直接暴力两两配对，优先将一对对互相倒置的串记录下来（就是A串从左到右与B串从右到左看是一样的），显然这样的一对串只要放在任意回文串的两边依然是个回文串。然后如果某一串没有这样的匹配串，那我们要再检查一下他本身是不是个回文串，如果是的话我们就可以把它放在答案串的最中间(废物利用？笑~).</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">101</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1000</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][k]!=s[j][m-k<span class="number">-1</span>])&#123;flag = <span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                vis[i] = vis[j] = <span class="number">1</span>;</span><br><span class="line">                ans[++cnt] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">            <span class="keyword">if</span> (s[i][k]!=s[i][m<span class="number">-1</span>-k]) &#123;flag = <span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) ans[<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = cnt*m*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="number">0</span>]!=<span class="number">0</span>) len+=m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[ans[i]][j]);</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="number">0</span>]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[ans[<span class="number">0</span>]][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[ans[i]][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Air-Conditioner"><a href="#C-Air-Conditioner" class="headerlink" title="C Air Conditioner"></a>C Air Conditioner</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>餐馆老板贼牛，他奉行顾客至上的道理，连顾客喜欢的温度都要照顾到……老板有一个空调，他可以通过控制空调使得某一分钟之后室内温度+1，-1或者不变。有n个客人，每个客人有一个到来的时间以及其感到满意的温度区间，问老板能否通过控制空调，使得每个到来的顾客都感到满意?</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>输入已经对时间排好序了。我们考虑任意两个客人到来之间的时候，初始温度一定是第一个客人满意温度区间的一个子区间，就就为[l,r],再记两个客人到来的时间差为t,到第二个客人来的时候我们能控制温度到达的区间自然就是[l-t,r+t],用这个新区间与新客人的满意区间取一个交集，就是新的一个初始温度区间(当然如果没有交就是NO)。初始温度是m，则初始温度区间就是[m,m],然后按以上步骤扫一遍就好了。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lal,lar,lat;</span><br><span class="line">        lal = lar = m;</span><br><span class="line">        lat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>,t,l,r;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;t,&amp;l,&amp;r);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tt = t-lat;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ll = lal-tt;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> rr = lar+tt;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;ll&lt;&lt;" "&lt;&lt;rr&lt;&lt;endl;</span></span><br><span class="line">            lat = t;</span><br><span class="line">            <span class="keyword">if</span> (rr&lt;l||ll&gt;r) flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                lal = <span class="built_in">max</span>(ll,l);</span><br><span class="line">                lar = <span class="built_in">min</span>(rr,r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Shortest-and-Longest-LIS"><a href="#D-Shortest-and-Longest-LIS" class="headerlink" title="D Shortest and Longest LIS"></a>D Shortest and Longest LIS</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>让你构造一个全排列满足数据给的一个相邻元素的大小关系，并且要求最长上升子序列最长或者最短，输出相应的子序列。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>我是屁都不会的，听了章大佬的解法好不容易糊上的，就离谱。具体解法就是根据拓扑排序去填数(我写的是大数指向小数)，开一个优先度列，以左右位置序号为基准，从大到小挨个填数。用拓扑排序填出来的序列一定是合法的，至于为啥能使得LIS最大最小….咱是真的不懂QAQwtcl</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">3000005</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3000004</span>];</span><br><span class="line"><span class="keyword">int</span> to[<span class="number">400005</span>][<span class="number">3</span>],cnt[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">int</span> du[<span class="number">300005</span>];</span><br><span class="line"><span class="keyword">int</span> du2[<span class="number">300005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) du2[i]=du[i]=to[i][<span class="number">1</span>]=to[i][<span class="number">2</span>]=cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i<span class="number">-1</span>]==<span class="string">'&gt;'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				to[i][++cnt[i]] = i+<span class="number">1</span>;</span><br><span class="line">				du[i+<span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				to[i+<span class="number">1</span>][++cnt[i+<span class="number">1</span>]] = i;</span><br><span class="line">				du[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// cout&lt;&lt;s[i-1];</span></span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) du2[i] = du[i];</span><br><span class="line">		<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (du2[i]==<span class="number">0</span>) q.push(-i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = n;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x = -q.top();q.pop();</span><br><span class="line">			ans[x] = tmp;</span><br><span class="line">			tmp--;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt[x];j++)</span><br><span class="line">			&#123;</span><br><span class="line">			du2[to[x][j]]--;</span><br><span class="line">			<span class="keyword">if</span> (du2[to[x][j]]==<span class="number">0</span>) q.push(-to[x][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (du[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;to[2]&lt;&lt;endl;</span></span><br><span class="line">		tmp = n;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x = q.top();q.pop();</span><br><span class="line">			<span class="comment">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">			ans[x] = tmp;</span><br><span class="line">			tmp--;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt[x];j++)</span><br><span class="line">			&#123;</span><br><span class="line">			du[to[x][j]]--;</span><br><span class="line">			<span class="keyword">if</span> (du[to[x][j]]==<span class="number">0</span>) q.push(to[x][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-1-Trees-and-Queries"><a href="#E-1-Trees-and-Queries" class="headerlink" title="E 1-Trees and Queries"></a>E 1-Trees and Queries</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一棵树，每个询问在x,y两点之间加条边(下一次询问这条边就不在了),每条点和边可以经过任意次,问在a,b之间是否存在路线恰好经过k条边？</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>前置，树上差分，可以O(nlogn)预处理，然后每次在O(logn)的复杂度里查询任意两点间的距离。<br>然后我们回到这道题，因为每条边都可以经过任意次，所以如果a,b之间的某条路径长度与k奇偶性相同并且小于k,就一定可以在某一条边左右横跳，然后在到达终点的时候恰好经过k条边。</p>
<p>我们先不考虑加的一条边，那么原先的树上就一条路径，如果这条路径符合以上条件，就一定是可以的，如果不可以，那么我们考虑其他的路径，自然就是经过加过边而形成的那个环。假如原路径长度奇偶性与k不同，那么如果这个环是个奇环，就可以调整奇偶性了，或者原先的长度过长，经过环的一部分，可以使距离变短，也有可能使得答案合法。所以我们总共去检查三条路径：</p>
<ul>
<li>a,b之间的原本路径</li>
<li>a到x,x到y(就是1),y到b</li>
<li>a到y,y到x,x到b</li>
</ul>
<p>如果这三条路径都不靠谱，那就没有合法方案了。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;E[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> cnt,head[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[++cnt].nxt = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100005</span>][<span class="number">21</span>],dep[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = fa;dep[x] = dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]]&gt;=dep[y])</span><br><span class="line">        x = f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x][i]!=f[y][i])</span><br><span class="line">        x=f[x][i],y=f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        add(x,y);</span><br><span class="line">        add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    f[j][i] = f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// cout&lt;&lt;dep[5]&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,a,b,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;x,&amp;y,&amp;a,&amp;b,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> dis = dep[a]+dep[b]-dep[lca(a,b)]*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis&lt;=k&amp;&amp;(k-dis)%<span class="number">2</span>==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        dis = dep[a]+dep[x]-dep[lca(a,x)]*<span class="number">2</span>+<span class="number">1</span>+dep[b]+dep[y]-dep[lca(b,y)]*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis&lt;=k&amp;&amp;(k-dis)%<span class="number">2</span>==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        dis = dep[b]+dep[x]-dep[lca(b,x)]*<span class="number">2</span>+<span class="number">1</span>+dep[a]+dep[y]-dep[lca(a,y)]*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis&lt;=k&amp;&amp;(k-dis)%<span class="number">2</span>==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);<span class="keyword">continue</span>;&#125;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Codeforces Round619&amp;&amp;ECR82(div2)</title>
    <url>/2020/02/14/Codeforces-Round619-ECR82-div2/</url>
    <content><![CDATA[<p><strong>咕了一场，还有一场是太菜了掉分了，做的都不多，就挤一块趴QAQ</strong><br><a id="more"></a></p>
<h1 id="Educational-Codeforces-Round-82"><a href="#Educational-Codeforces-Round-82" class="headerlink" title="Educational Codeforces Round 82"></a>Educational Codeforces Round 82</h1><h2 id="A-Erasing-Zeroes"><a href="#A-Erasing-Zeroes" class="headerlink" title="A Erasing Zeroes"></a>A Erasing Zeroes</h2><p>问所给01串中1之间的所有0的个数，没啥好说的</p>
<h2 id="B-National-Project"><a href="#B-National-Project" class="headerlink" title="B National Project"></a>B National Project</h2><p>emmmmmm,普通的小学数学题，也没啥好说的</p>
<h2 id="C-Perfect-Keyboard"><a href="#C-Perfect-Keyboard" class="headerlink" title="C Perfect Keyboard"></a>C Perfect Keyboard</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>主角想构造一个懒人键盘，使得他在打某一串字符串的时候能够几乎不移动手指。输入一串小写英文字符串，如果有符合题意的键盘，就输出这个键盘(一定顺序的某个26英文字母全排列)，要求这个输入的串的任意两个相邻字符，在键盘上也相邻。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>将输入串的每两个相邻字母用链表连接起来，最后输出即可，注意一下几种非法键盘：</p>
<ul>
<li>某个字母和2个以上的其他种类字母相邻</li>
<li>所有的有关字母连接起来之后成环</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">1000110</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1000110</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> cnt;</span><br><span class="line">   <span class="keyword">int</span> ch[<span class="number">30</span>];</span><br><span class="line">   Node()&#123;</span><br><span class="line">       cnt = <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;N[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">   <span class="keyword">int</span> t;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">   <span class="keyword">while</span>(t--)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) N[i].cnt = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag2 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=N[s[i]-<span class="string">'a'</span>].cnt;j++)</span><br><span class="line">            <span class="keyword">if</span> (N[s[i]-<span class="string">'a'</span>].ch[j]==s[i+<span class="number">1</span>]-<span class="string">'a'</span>) flag2 = <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">if</span> (flag2) <span class="keyword">continue</span>;</span><br><span class="line">            N[s[i]-<span class="string">'a'</span>].ch[++N[s[i]-<span class="string">'a'</span>].cnt] = s[i+<span class="number">1</span>]-<span class="string">'a'</span>;</span><br><span class="line">            N[s[i+<span class="number">1</span>]-<span class="string">'a'</span>].ch[++N[s[i+<span class="number">1</span>]-<span class="string">'a'</span>].cnt] = s[i]-<span class="string">'a'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span> (N[i].cnt&gt;<span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span> (N[i].cnt==<span class="number">0</span>) &#123;</span><br><span class="line">            root = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (N[i].cnt==<span class="number">1</span>) num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="number">-1</span>&amp;&amp;num&gt;<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = N[root].ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> la = root;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,root+<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">while</span>(N[nx].cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,nx+<span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">int</span> nxx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N[nx].cnt;i++)</span><br><span class="line">                <span class="keyword">if</span> (N[nx].ch[i]!=la) nxx = N[nx].ch[i];</span><br><span class="line">                la = nx;</span><br><span class="line">                nx = nxx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,nx+<span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span> (N[i].cnt==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>,<span class="string">'a'</span>+i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);    </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Fill-The-Bag"><a href="#D-Fill-The-Bag" class="headerlink" title="D. Fill The Bag"></a>D. Fill The Bag</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>用所给的一些货物，将给定的一个“背包”装满。具体来说，就是给一个数列，让你在这些数中找任意个数，使得他们相加为给定的n。规定这些数一定是2的幂次方，我们可以对这些数进行div操作，即将某数拆开，得到到两个这样的数，每个数都是原值的一半。问，能否凑满“背包”，如果能，输出最少需要几次div操作。</p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>因为一共也就六十几种数，开个权值数组记录每种数的数量然后对于目标数字从低位到高位去凑就好了。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++) num[i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&gt;(<span class="number">1l</span>l&lt;&lt;p)) p++;</span><br><span class="line">            num[p]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((n&amp;(<span class="number">1l</span>l&lt;&lt;cnt))==<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                num[cnt]+=num[cnt<span class="number">-1</span>]/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=cnt;i&lt;=<span class="number">62</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i]&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    n-=(<span class="number">1l</span>l&lt;&lt;cnt);</span><br><span class="line">                    ans+=i-cnt;</span><br><span class="line">                    num[i]--;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k=i<span class="number">-1</span>;k&gt;=cnt;k--)&#123;</span><br><span class="line">                        p&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num[cnt]+=p;</span><br><span class="line">                    num[cnt]--;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Codeforces-Round-619"><a href="#Codeforces-Round-619" class="headerlink" title="Codeforces Round 619"></a>Codeforces Round 619</h1><h2 id="A-Three-Strings"><a href="#A-Three-Strings" class="headerlink" title="A Three Strings"></a>A Three Strings</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给三个长度相等的字符串a,b,c,对于每一位，必须让c串与a串或者b串交换，问最后能否使得a串与b串相同。</p>
<h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>显然对于每一位必须满足c串与a串或者b串相同，O（n）扫一遍即可</p>
<h2 id="B-Motarack’s-Birthday"><a href="#B-Motarack’s-Birthday" class="headerlink" title="B Motarack’s Birthday"></a>B Motarack’s Birthday</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一组有空缺的数列，将所有的空缺都变成k,问k为多少时原数列相邻数字的差值的最大值最小，求这个k和差值。</p>
<h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>感性思考一下，肯定是个关于k的单峰函数，三分一下k就好了。<del>然而我只会写假三分QAQ</del></p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> nx = a[i];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> la = a[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx==<span class="number">-1</span>) nx = x;</span><br><span class="line">        <span class="keyword">if</span> (la==<span class="number">-1</span>) la = x;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">abs</span>(la-nx));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">   <span class="keyword">int</span> t;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">   <span class="keyword">while</span> (t--)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1e16</span>,ansid=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(r-l&gt;<span class="number">2</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">long</span> <span class="keyword">long</span> lmid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">long</span> <span class="keyword">long</span> rmid = (r+lmid)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">long</span> <span class="keyword">long</span> lans = check(lmid);</span><br><span class="line">           <span class="keyword">long</span> <span class="keyword">long</span> rans = check(rmid);</span><br><span class="line">           <span class="keyword">if</span> (lans&lt;=rans)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (lans&lt;ans)</span><br><span class="line">               &#123;</span><br><span class="line">                   ans = lans;</span><br><span class="line">                   ansid = lmid;</span><br><span class="line">               &#125;</span><br><span class="line">               r = rmid;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (rans&lt;ans)</span><br><span class="line">               &#123;</span><br><span class="line">                   ans = rans;</span><br><span class="line">                   ansid = rmid;</span><br><span class="line">               &#125;</span><br><span class="line">               l = lmid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> xx = check(i);</span><br><span class="line">            <span class="keyword">if</span> (xx&lt;ans)&#123;</span><br><span class="line">                ans = xx;</span><br><span class="line">                ansid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,ans,ansid);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Ayoub’s-function"><a href="#C-Ayoub’s-function" class="headerlink" title="C Ayoub’s function"></a>C Ayoub’s function</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>至今没读题2333，大概是有一个01串，给你其中1的个数m，然后让你去构造一个01串使得其中包含1的子区间的个数最多，输出这个数字。</p>
<h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>正向思考并不好像，只能感觉均分0是对的<del>而且并不怎么好调QAQwtcl</del>。所以我们反向思考，总的子区间数是固定的，我们只需要减去不符合条件的区间的个数，即只包含0的区间的个数。而这种区间一定出现在都是0的某个块内，假定有个0块有x个0，那么其中的非法子区间就是x/*(x-1)/2.这样我们发现，原题就等于在m+1个位置里加0,而且对于每个位置，加第一个0的时候贡献是1，第二个是2，第三个是3，以此类推，所以显然贪心的策略是使得各个位置的0的个数尽量均分。写起来也很愉快。。。。</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = (n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = (n-m)/(m+<span class="number">1</span>);</span><br><span class="line">        ans-=(t+<span class="number">1</span>)*t/<span class="number">2</span>*(m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num2 = (n-m)%(m+<span class="number">1</span>);</span><br><span class="line">        ans-=(t+<span class="number">1</span>)*num2;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Time-to-Run"><a href="#Time-to-Run" class="headerlink" title="Time to Run"></a>Time to Run</h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个n行m列的网格，每两个相邻方格之间有两条方向相反的单向道路，每个道路都只能走一次，问是否有办法移动k次(起点在左上角)，如果有，输出走的方案。<br><img src="https://espresso.codeforces.com/f35e95cc05e4660c150ae66f77e4a78e62a4e24b.png" alt="AA"></p>
<h3 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h3><p>由入度去看的话，并没有入度为奇数的点，所以根据欧拉路径的理论，一定有一笔画的方法，也就是有办法每条路径都经过一遍。所以随便试一试总能找到一种方法。。。我是一行一行往下来回扫着画，最后写下来跟个大模拟差不许多了QAQ,具体见代码。</p>
<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++) num[i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&gt;(<span class="number">1l</span>l&lt;&lt;p)) p++;</span><br><span class="line">            num[p]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((n&amp;(<span class="number">1l</span>l&lt;&lt;cnt))==<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                num[cnt]+=num[cnt<span class="number">-1</span>]/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=cnt;i&lt;=<span class="number">62</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i]&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    n-=(<span class="number">1l</span>l&lt;&lt;cnt);</span><br><span class="line">                    ans+=i-cnt;</span><br><span class="line">                    num[i]--;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k=i<span class="number">-1</span>;k&gt;=cnt;k--)&#123;</span><br><span class="line">                        p&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num[cnt]+=p;</span><br><span class="line">                    num[cnt]--;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 618(div2)</title>
    <url>/2020/02/10/Codeforces-Round-618-div2/</url>
    <content><![CDATA[<h1 id="A-Non-zero"><a href="#A-Non-zero" class="headerlink" title="A Non-zero"></a>A Non-zero</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个序列，你只可以做一种操作，使得某个序列中的数+1,问最少几次操作可以使得序列中每个数都不为0，所有数的和也不为0.<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>对于一开始等于0的数肯定要+1操作的，然后如果所有的0都处理完了之后，总和sum等于0，这时肯定数列中有正数，给这个正数+1,最后输出操作数即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            a[i]++;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125; </span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum==<span class="number">0</span>) ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Assigning-to-Classes"><a href="#B-Assigning-to-Classes" class="headerlink" title="B Assigning to Classes"></a>B Assigning to Classes</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长度为2n的序列，将其划分为两个奇数长度序列，取每个序列的中位数做差，问取一个合适的分法，使中位数之差绝对值最小，输出差值的绝对值。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>手模一一下下，首先发现最后取到的中位数一定是排序后序列左半部分有一个，右半部分有一个，然后两个数又至少有一个是<strong>a[n]</strong>或者<strong>a[n+1]</strong>,仔细一思考，肯定没有差值比<strong>a[n+1]-a[n]</strong>更小的了，所以排序号后输出答案即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+n+n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,a[n+<span class="number">1</span>]-a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Anu-Has-a-Function"><a href="#C-Anu-Has-a-Function" class="headerlink" title="C  Anu Has a Function"></a>C  Anu Has a Function</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>规定操作f: $f(x,y) = (x|y)-y$,给你一个序列$[a_1,a_2,a_3,a_4,…,a_n]$,最终让你给这个序列重新排序使得 </p>
<script type="math/tex; mode=display">f(f(...f(f(a_1,a_2),a_3),...a_{n-1}),a_n)</script><p>最小。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>因为是按位操作的，所以我们只是按每个数位去考虑，然后想到，<br>0|0 - 1 = 0，<br>0|1 - 1 = 0,<br>1|1 - 1 = 0,<br>1|0 - 0 = 1,<br>所以只有1与0进行运算才得1，所以显然只有当某一位上只有一个数有1,其他数都是0，且该数在第一个位置，才能使得结果对应位上为1。最后解法就显而易见，从最高位往后扫，第一个符合条件的数出现的时候就把他调到第一个，别的都不用管就行。<br>ps:经战神指点，还有个O(N)的做法，f操作可以写成f(a,b) = a&amp;(~b),所以结果就是求$a_1&amp;(~a_2)&amp;(~a_3)&amp;…&amp;(~a_n)$,记一个~a的前缀并和后缀并，然后O(N)枚举即可。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">32</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1l</span>l&lt;&lt;i;</span><br><span class="line">        <span class="keyword">int</span> tmpid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span> (tmp&amp;a[i]) </span><br><span class="line">        &#123;cnt++;</span><br><span class="line">        tmpid = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(a[<span class="number">1</span>],a[tmpid]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld "</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Aerodynamic"><a href="#D-Aerodynamic" class="headerlink" title="D Aerodynamic"></a>D Aerodynamic</h2><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一组点确定的多边形P，移动P使得点（0,0）在多边形内部或者边缘，所有合法的移动的P覆盖的区域为T,问T是否与P相似。</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p><del> 真就试胆题白QAQ </del><br>模一下最后一组样例<del>太明显了</del>,就是判断原图是否对边平行且相等。<br>过了之后从结论出发感性分析一下，对于多边形的任意一条线段，想象（0,0）在该线段上移动，然后留下的图形中，离该线段最远的点留下的一定是个线段，这个线段也一定是最终图形的一条边，而如果只是一个点的话，那么一定不合法，因为P在这个方向上是一个点，而产生的图形在这个方向上是个边。由此我们知道原图形这条线段的对面也一定是条平行线，又因为产生的图形在这两个方向上的平行线一定是相等的，所以原图形也一定对边相等（而且实际上一定是1:2的放大）。所以得出结论，对边平行相等。</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x[<span class="number">100010</span>],y[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> chax[<span class="number">100010</span>],chay[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">  chax[<span class="number">0</span>] = x[<span class="number">1</span>]-x[n];</span><br><span class="line">  chay[<span class="number">0</span>] = y[<span class="number">1</span>]-y[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    chax[i] = x[i+<span class="number">1</span>]-x[i];</span><br><span class="line">    chay[i] = y[i+<span class="number">1</span>]-y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n%<span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  n/=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (chax[i]+chax[i+n]!=<span class="number">0</span>||chay[i]+chay[i+n]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-Water-Balance"><a href="#E-Water-Balance" class="headerlink" title="E Water Balance"></a>E Water Balance</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个整数序列，你可以进行任意次操作，每次操作选定一个区间，使得该区间里的每个数都变为他们的平均值，问你经过若干次操作后得到的字符典序最小的序列是啥。</p>
<h2 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h2><p>字符典序小就是说要靠前的数尽量小，这样的话我们考虑一个暴力算法：</p>
<p>从后往前扫，扫到某一个位置，再从这个位置往后扫，记录当前扫过的和sum,与扫过的数的个数cnt,如果sum/cnt比扫到的这个数要打就继续往后扫并把这个数记录在sum和cnt里，否则停止(因为完成后的序列一定是单调不降的，所以后边的数也一定不能符合条件)。</p>
<p>最后得到的序列一定是答案，正确肯定是正确的，但是太慢了，$O(N^2)$的算法肯定过不了1e6;</p>
<p>我们考虑优化他：</p>
<p>可以想到我们在从某个位置向后扫的时候，后边的东西一定是一个又一个相同数字组成的块，这样的话我们把这些块合并成一个节点，这个节点记录块中的数的值和数量即可，这样用一个类似单调栈的写法，每次扫描栈顶的一个节点，该节点符合内部数字的值比当前sum/cnt要小，就从栈顶取这个节点，与新节点合并，并继续向下扫，否则就将该节点放在栈顶。</p>
<p>最后我们从栈顶往下把序列输出出来即可。</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">1000110</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1000110</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> sum,cnt;</span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">&#125;N[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> sta[<span class="number">1000110</span>],top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sta[++top] = <span class="number">1</span>;</span><br><span class="line">    N[<span class="number">1</span>].cnt = <span class="number">1</span>;</span><br><span class="line">    N[<span class="number">1</span>].sum = a[n];</span><br><span class="line">    N[<span class="number">1</span>].val = a[n];</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> cnt = <span class="number">1</span>;</span><br><span class="line">        sum = a[i];</span><br><span class="line">        <span class="keyword">while</span>(top)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum/cnt&gt;N[sta[top]].val)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=N[sta[top]].sum;</span><br><span class="line">                cnt+=N[sta[top]].cnt;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;    </span><br><span class="line">        N[++ct].cnt = cnt;</span><br><span class="line">        N[ct].sum = sum;</span><br><span class="line">        sum=sum/cnt;</span><br><span class="line">        N[ct].val = sum;</span><br><span class="line">        sta[++top] = ct;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = sta[top];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N[x].cnt;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>,N[x].val);</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>我这种菜鸡竟然都能AK了QAQ</del></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>主席树入门总结</title>
    <url>/2020/02/05/%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h1><p>线段树,前缀和<br><a id="more"></a></p>
<h1 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h1><p>之所以叫主席树好像是因为发明他的大佬名字缩写是hjt，所以后来就叫主席树了2333</p>
<p>主席树其实就是可持久化线段树，通俗来讲，就是可以访问之前历史版本的线段树。比如你在线段树里插入了1,2,3,4,5，如果是普通的线段树，你只能对插入5之后的线段树进行操作，而主席树可以做到对之前任何一次操作时的线段树进行访问。</p>
<p>虽然听上去满牛的，但是如果只是实现这个可持久化的功能的话其实思路也只有一个，就是在每次操作前都将当前的线段树保存下来，然后再复制出一棵新树，再进行操作就是了。</p>
<p>然而肯定是不能暴力去做这个的，时空复杂度爆炸，主席树就是对于这个过程进行的一种优化。</p>
<p>可以想象得到，在普通的线段树上，每次进行修改操作时，收影响的其实只是一条从根节点到对应叶结点的那一条路径而已。举个栗子，对于这么长度为4的[1,4]区间的线段树，我们去修改3时，修改的点实际只有三个，如下图：<br><img src="/2020/02/05/%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/A.png" alt="A"><br>所以我们能否只针对受影响的几个点去操作呢？当然可以，动态开点就好了，对于受影响的点都动态开一遍，不变的点就原封不动的接过来即可。这样我们每一个版本的线段树都会有一个对应的根，我们根据特定的根，就可以去访问对应版本的线段树了，所以主席树修改就类似于下面这样：<br><img src="/2020/02/05/%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/B.jpg" alt="B"><br>这样我们顺着黑色[1,4]节点可以访问修改前版本的线段树，顺着蓝色[1,4]节点则可以访问修改后版本的线段树，多次修改同理。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>如果是前缀和的话，两个不同位置的前缀和相减，我们就可以得到这两个位置之间的所有数的和，而主席树也有类似的特点。</p>
<p>假如我们现在有一个主席树，我们取x操作时的线段树，在取y操作时的线段树，我们将两棵树同时向下查询，那么两树每个对应节点的差值，就是只进行x到y操作时的线段树状态。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">洛谷模板题</a><br>给一段序列，为序列中指定区间第k小的数。<br>此题结合主席树与权值线段树可做。</p>
<p>首先考虑，如果是问整段序列第k小的数~我知道可以sort，我又不傻QAQ~,我们用权值线段树去做怎么做？</p>
<p>我们把每个数在数值对应的位置插入，线段树的叶子节点存对应权值的数的个数，这样我们查询第k大的时候只要在线段树上查找就好了，如果左区间的数的个数sum大于k，那就去左区间找，否则就去右区间找k-sum小的数。这样很快就找到了。</p>
<p>但是有个问题，如果权值过大，线段树存不下怎么办?离散化一下就好了。</p>
<p>好的，我们回到原题，对应区间怎么做？用主席树先把对应的区间扣出来再按上边的方法做就好了。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> rt[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;N[NN&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R=++sz;   </span><br><span class="line">    N[R].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span> R;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    N[R].l=build(l,mid);</span><br><span class="line">    N[R].r=build(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rr = ++sz;</span><br><span class="line">    N[rr].sum = N[R].sum+<span class="number">1</span>;</span><br><span class="line">    N[rr].l = N[R].l;</span><br><span class="line">    N[rr].r = N[R].r;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span> rr;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;=mid)</span><br><span class="line">    N[rr].l = update(N[R].l,l,mid,p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    N[rr].r = update(N[R].r,mid+<span class="number">1</span>,r,p);</span><br><span class="line">    <span class="keyword">return</span> rr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> sum = N[N[rr].l].sum-N[N[ll].l].sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=sum)</span><br><span class="line">    <span class="keyword">return</span> query(N[ll].l,N[rr].l,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> query(N[ll].r,N[rr].r,mid+<span class="number">1</span>,r,k-sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]=a[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len_p = unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">    rt[<span class="number">0</span>]=build(<span class="number">1</span>,len_p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(b+<span class="number">1</span>,b+len_p+<span class="number">1</span>,a[i])-b;</span><br><span class="line">        rt[i] = update(rt[i<span class="number">-1</span>],<span class="number">1</span>,len_p,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l,r,k;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> p = query(rt[l<span class="number">-1</span>],rt[r],<span class="number">1</span>,len_p,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>进阶题目：<br><a href="https://www.luogu.com.cn/problem/P2633" target="_blank" rel="noopener">Count on a tree</a><br>序列搬到了树上，树上差分可做。</p>
<p>树上差分：<br>对每个点记一个sum[i],作为从根节点到该节点的路径的前缀和，这样对于任意两个点u，v，两点之间路径上的东西就是：</p>
<script type="math/tex; mode=display">sum\[u\]+sum\[v\]-sum\[lca(u,v)\]-sum\[fa\[lca(u,v)\]\]</script><p>因为主席树也有类似前缀和的性质，所以把上边的前缀和改成主席树就好了。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">&#125;E[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;N[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> rt[maxn],sz=<span class="number">0</span>,len_p;</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> val[maxn],f[maxn][<span class="number">20</span>],dep[maxn];</span><br><span class="line"><span class="keyword">int</span> mt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;R,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R = ++sz;</span><br><span class="line">    N[R].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(N[R].l,l,mid);</span><br><span class="line">    build(N[R].r,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = ++sz;</span><br><span class="line">    N[R].l = N[pre].l;</span><br><span class="line">    N[R].r = N[pre].r;</span><br><span class="line">    N[R].sum = N[pre].sum+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> R;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;=mid) N[R].l = update(N[R].l,l,mid,p);</span><br><span class="line">    <span class="keyword">else</span> N[R].r = update(N[R].r,mid+<span class="number">1</span>,r,p);</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    E[++cnt].nxt = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = fa;</span><br><span class="line">    dep[x] = dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[y]&gt;dep[x]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]]&gt;=dep[y])</span><br><span class="line">        x = f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x==y) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x][i]==f[y][i]) <span class="keyword">continue</span>;</span><br><span class="line">        x = f[x][i];y=f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = lower_bound(mt+<span class="number">1</span>,mt+len_p+<span class="number">1</span>,val[x])-mt;</span><br><span class="line">    rt[x] = update(rt[fa],<span class="number">1</span>,len_p,p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> Lca,<span class="keyword">int</span> fa,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = N[N[u].l].sum+N[N[v].l].sum-N[N[Lca].l].sum-N[N[fa].l].sum;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=sum) <span class="keyword">return</span> query(N[u].l,N[v].l,N[Lca].l,N[fa].l,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  query(N[u].r,N[v].r,N[Lca].r,N[fa].r,mid+<span class="number">1</span>,r,k-sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) mt[i] = val[i];</span><br><span class="line">    sort(mt+<span class="number">1</span>,mt+n+<span class="number">1</span>);</span><br><span class="line">    len_p = unique(mt+<span class="number">1</span>,mt+n+<span class="number">1</span>)-mt<span class="number">-1</span>;</span><br><span class="line">    build(rt[<span class="number">0</span>],<span class="number">1</span>,len_p);</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    f[j][i] = f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> u,v,k,last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;k);</span><br><span class="line">        u^=last;</span><br><span class="line">        <span class="keyword">int</span> Lca = lca(u,v);</span><br><span class="line">        <span class="keyword">int</span> fa = f[Lca][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = query(rt[u],rt[v],rt[Lca],rt[fa],<span class="number">1</span>,len_p,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mt[ans]);</span><br><span class="line">        last = mt[ans];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>~lca板子我竟然还记得QAQ~</p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeforcesRound 616(Div2)</title>
    <url>/2020/02/03/CodeforcesRound-616-Div2/</url>
    <content><![CDATA[<h1 id="A-Even-But-Not-Even"><a href="#A-Even-But-Not-Even" class="headerlink" title="A Even But Not Even"></a>A Even But Not Even</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一串数字字符串，代表一个大数字，你可以删除其中的一些数字，也可以不删，但是不能全删。问能否通过删除得到一个数字满足：</p>
<ul>
<li>是奇数</li>
<li>各数位和不是奇数</li>
</ul>
<a id="more"></a>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>仔细思考，决定他是不是奇数的是他的最后一位，决定他数位和是不是奇数的是各个数位的奇数的个数(显然一个数加减一个偶数不会影响他的奇偶性)，最终我们需要的就是末尾是奇数，总共个数位有偶数个奇数的数，然后暴力去构造就好了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        sum+=s[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span> ((s[i]-<span class="string">'0'</span>)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span> ((s[i]-<span class="string">'0'</span>)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i] = <span class="string">'#'</span>; </span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">                    <span class="keyword">if</span> (s[i]==<span class="string">'0'</span>) &#123;</span><br><span class="line">                        s[i]=<span class="string">'#'</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;flag = <span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);   </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-Array-Sharpening"><a href="#B-Array-Sharpening" class="headerlink" title="B Array Sharpening"></a>B Array Sharpening</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个序列，你可以对序列中的每个数做减法操作，减掉任意数(结果不能为负数)，问你能否构造出一个序列满足————存在一个k(1\&lt;=k\&lt;=n),使得 $a_1\<a_2\<...\<a_k\>…>a_{n-1}>a_n$</a_2\<...\<a_k\></p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>题目具体来说，就是存在某个数左边是严格递增序列，右边是严格递减序列。这样的话我们每次只考虑一边，设dpl[i]代表$a_1$到$a_i$能否形成严格递增序列，dpr[i]代表$a_n$到$a_i$能否形成严格递增序列。我们考虑状态转移(仅以左边为例，右边同理)：</p>
<ul>
<li>如果1~i-1不能形成严格递增序列，那么1~i显然也不能</li>
<li>如果1~i-1能形成严格递增序列，但是$a_i$\&lt;i-1，则也不可能符合条件</li>
</ul>
<p>最后O(n)扫一遍，看是否有左右两边都符合条件的位置即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dpl[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> dpr[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        dpl[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dpl[i<span class="number">-1</span>]==<span class="number">-1</span>) dpl[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i]&gt;=i<span class="number">-1</span>) dpl[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dpl[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        dpr[n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dpr[i+<span class="number">1</span>]==<span class="number">-1</span>) dpr[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i]&gt;=n-i) dpr[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dpr[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span> (dpl[i]==<span class="number">1</span>&amp;&amp;dpr[i]==<span class="number">1</span>) &#123;flag = <span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-Mind-Control"><a href="#C-Mind-Control" class="headerlink" title="C Mind Control"></a>C Mind Control</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>有n个数，有n-1个人，n-1个人排成一队，每次队首选择最左边或者最右边一个数字拿走。主角排在第m个位置，他可以控制k个人说服他们去选择左边或者右边，其他人则无法控制，他们可以选择任意某一边（他们不会考虑数字的大小），现在问你，主角在合理劝说k个人之后，能拿到的最大的x是多少（x指在最优策略下他能拿到的最小的数）</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>~怎么感觉我把它翻译得更饶了QAQ~其实就是轮到主角时，主角会有一个数对去选，他一定选大的，如何安排k个人，使得在所有主角可能能选到的数对中，最小的（数对最大值）最大。<br>首先可以想到，m之后的人如何选不会影响到主角，所以前k个都安排在m之前(当然最多安排m-1个人)，然后就枚举所有前k个的选择情况，对于每种情况下的最差情况取一个值，所有取值取一个最大值即可，暴力O(mk)枚举就好。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        k = <span class="built_in">min</span>(m<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> l = k+<span class="number">1</span>,r=n;</span><br><span class="line">        <span class="keyword">int</span> tt = m-k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;tt&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span> (;l&gt;=<span class="number">1</span>;l--,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp = inf;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=l+tt;i++)&#123;</span><br><span class="line">            tmp = <span class="built_in">min</span>(tmp,<span class="built_in">max</span>(a[i],a[r-tt+(i-l)]));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-Irreducible-Anagrams"><a href="#D-Irreducible-Anagrams" class="headerlink" title="D Irreducible Anagrams"></a>D Irreducible Anagrams</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个大串，给出q个询问，每次问大串的一个子串，问这个子串是否存在一个<strong>irreducible</strong>的变幻串，该条件指：<br>能否将原串拆分为两个以上的部分，变幻串按相同的方法拆分，使得每一个对应分串所包含的每个字母的数量相同。</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>昨晚想的头疼，这谁能会啊QAQ。结果是特判一下，如果该串符合一下条件之一，就一定<strong>irreducible</strong>:</p>
<ul>
<li>长度为1</li>
<li>首尾字符相同</li>
<li>有三个及以上不同的字符<br>意会一下他是对的。。。具体证明就不写了QAQ</li>
</ul>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">400000</span>][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      num[i+<span class="number">1</span>][j] = num[i][j];</span><br><span class="line">      <span class="keyword">if</span> (j==s[i]-<span class="string">'a'</span>) num[i+<span class="number">1</span>][j]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">int</span> q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> l,r,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">      <span class="keyword">if</span> (num[r][i]-num[l<span class="number">-1</span>][i]&gt;<span class="number">0</span>) cnt++;</span><br><span class="line">    <span class="keyword">if</span> (s[l<span class="number">-1</span>]!=s[r<span class="number">-1</span>]||cnt&gt;=<span class="number">3</span>||l==r) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署报错及修理过程</title>
    <url>/2020/02/02/hexo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99%E5%8F%8A%E4%BF%AE%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><a id="more"></a>
<p>这天，俺一如既往得颓废，然后战某神说他刚建了个博客，让我康康…..然后对比之下俺惊奇得发现俺的博客有点瑕疵，所以随手改了下，之后hexo g&amp;&amp;hexo d…..结果出错了！？人有点傻，只得快马加鞭，推掉对面~然后团灭被一波了QAQ~</p>
<h1 id="修理过程"><a href="#修理过程" class="headerlink" title="修理过程"></a>修理过程</h1><p>随后啥都不会的俺开始慌了，但是俺觉得俺有度年俺怕谁，定准了错误信息Spawn fail，然后到处乱翻。。。。</p>
<p>有说是因为上次上传中途突然中断，导致仓库和本地不同步的。好，俺仓库也没个星星俺怕啥，分分钟重新建了个仓库，没用mad。</p>
<p>有说是ssh过期不匹配的~这玩意咋能过期？？~。好，俺重新设了三遍ssh，没用mad。</p>
<blockquote>
<p>ssh,一种信息安全协议，这里用公钥和私钥两个，公钥谁都能看，私钥只有自己有，登录的时候服务器用公钥去匹配私钥，匹配成功了就可以为所欲为。</p>
</blockquote>
<p>最后饶了一大圈，终于发现真正的错误信息在上边一行~我真是个ZZmad~实际上是time out啥的，访问github请求超时的意思。最后在google找到了解决方案~lj百度QAQ~</p>
<h1 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h1><p>大概是冠状病毒太猖狂侵入了github的各大地区服务器了？怎么感觉全都瘫痪了？？最后终于在加拿大找到了一个好用的服务器，贼鸡儿快，改了一下host就解决问题了~原来是网卡了o(╥﹏╥)o~</p>
<blockquote>
<p>host本地一个优先寻找ip地址的目录，电脑会现在host上查询一波你想去的网址，找不到再去DNS上找。。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>杂学</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeforcesER81</title>
    <url>/2020/01/30/CodeforcesER81/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>用给定数目的灯管(类似计算器上的数字显示屏，一个数字由7根灯管亮灭组成)，显示尽可能大的数。<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>~题面很唬人，然而只是判断奇偶数~显然位数越多数字越大，尽可能往高位组，所以尽可能使用1(2根灯管),偶数就刚好，奇数多余的一根就让最高位的1变成7。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"7"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个01串作为循环节，得到一个无限长的01串，求该串有多少前缀满足0的个数-1的个数等于所期望的值。</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>首先如果循环节的01数相等，特判掉：</p>
<ul>
<li>如果存在循环节中某个前缀01差符合期望值则输出-1</li>
<li>如果没有就是0</li>
</ul>
<p>特判掉以上情况之后，显然每个位置至多贡献1，记录原始循环节每个位置作为前缀末尾得到的01个数差在数组num中，求整个循环节的01个数差极为tt。对于每一个位置看$x-num_i$(x为期望差值)是否是tt的非负倍数，是则贡献答案否则继续找。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">400010</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,sum=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]==<span class="string">'0'</span>) sum++;</span><br><span class="line">            <span class="keyword">else</span> sum--;</span><br><span class="line">            num[i+<span class="number">1</span>] = sum; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tt = num[n];</span><br><span class="line">        <span class="keyword">if</span> (tt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span> (num[i]==x) &#123;flag = <span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">0</span>) ans++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x-num[i])%tt==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((x-num[i])/tt&gt;=<span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定a串,t串以及空串z,每次操作可以取一个a串的任意子序列连接在z串后边，问最少需要操作几次使z串变为t串</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>一定正确的做法，贪心，使用两个指针在a串和t串两边一起扫，不断地循环扫a串找t串当前指针所指字符，找到就继续扫，找不到就输出-1,最后都找完了答案就是扫过的a串的遍历数。显然暴力扫很慢，优化一下：</p>
<ul>
<li>法一，使用lower_bound(大概是可以，但是我写炸了，某大仙好像是这么做的)</li>
<li>法二，建立一个26*n的跳表，预处理一遍，之后扫的时候O(N)扫一遍就行了。<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100010</span>],t[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">100010</span>][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line">        <span class="keyword">int</span> lens = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        lens++;</span><br><span class="line">        <span class="keyword">int</span> lent = <span class="built_in">strlen</span>(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">26</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            nxt[lens][k] = lens+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=lens<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i]==<span class="string">'a'</span>+k) nxt[i][k] = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> nxt[i][k] = nxt[i+<span class="number">1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">            nxt[<span class="number">0</span>][k] = nxt[<span class="number">1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> is = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lent;i++)&#123;</span><br><span class="line">            is = nxt[is][t[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (is==lens+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                is = <span class="number">0</span>;</span><br><span class="line">                is = nxt[is][t[i]-<span class="string">'a'</span>];</span><br><span class="line">                <span class="keyword">if</span> (is==lens+<span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    ans = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;is&lt;&lt;endl;</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// cout&lt;&lt;is&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2>给a,m,问有多少个x(0\&lt;=x\&lt;m)满足gcd(a,m)==gcd(a+x,m).<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2>在CFdiv2难得一见的数论题。。。<br>对于原题，首先显然gcd(a,m)是一个常数(记为d)，而对于gcd(a+x,m)，当a+x>=m时gcd(a+x,m)==gcd((a+x)\%m,m),(a+x)\%m$\in$[0,a),接上a+x小于m的部分，原题就是问有多少个小于m的正整数x满足gcd(x,m)=d;<br>写出来是这个：<script type="math/tex; mode=display">\sum_{i=0}^{m-1}[gcd(i,m)==d]</script>又因为gcd(0,m)=gcd(m,m),所以：<script type="math/tex; mode=display">\sum_{i=1}^{m}[gcd(i,m)==d]</script>之后整个式子除一个d:<script type="math/tex; mode=display">\sum_{i=1}^{\lfloor \frac {m} d \rfloor}[gcd(i,\lfloor \frac m d \rfloor)==1]</script>然后本质上就是m/d的欧拉函数，抄了个求欧拉函数的板子就能过了<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b%a,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> m = <span class="keyword">int</span>(<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>));</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">      ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d = gcd(a,m);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;euler_phi(m/d)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>map与unordered_map用法总结</title>
    <url>/2020/01/23/map%E4%B8%8Eunordered-map%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>map是一种底层基于红黑树的一种字典数据结构，可以做到key值与value值的对应,内部有序。<br>unordered_map是一种hash实现的字典数据结构，在查找方面效率比map高很多，但内部无序。<br><a id="more"></a></p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul>
<li>包含 &lt; map >和&lt; unordered_map ></li>
</ul>
<h2 id="内部用法"><a href="#内部用法" class="headerlink" title="内部用法"></a>内部用法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>map &lt; type,type > m;</p>
<h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><ul>
<li>m.insert(makepair(123,”JJH”));</li>
<li>m.insert(map<int,string>::value_type(123,”JJH”));</int,string></li>
<li>m[123] = “JJH”;</li>
</ul>
<p>注意第三种方式会覆盖原先的值，前两种则会返回一个pair<iterator,bool>,插入的位置和是否插入成功。</iterator,bool></p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><ul>
<li>iter=m.find(“123”);</li>
</ul>
<p>find函数返回指向key-value对的迭代器，如果找不到则返回m.end();</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li>iter = m.find(“123”)<br>m.erase(iter);</li>
<li>m.erase(“123”);</li>
<li>m.erase(m.begin(),map.end());</li>
</ul>
<p>成功返回值为1，否则为0.</p>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul>
<li>begin()       返回头部迭代器</li>
<li>clear()       删除所有元素</li>
<li>count()       返回指定元素出现次数</li>
<li>empty()       返回是否为空(bool)</li>
<li>end()         尾指针</li>
<li>lower_bound() 返回键值&gt;=给定元素的第一个位置(迭代器)</li>
<li>upper_bound() 返回键值&gt;给定元素的第一个位置(迭代器)</li>
</ul>
<h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><p>在结构体内部重载即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node <span class="keyword">const</span> &amp;A) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;A.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>用法基本一致，除了lower_bound和upper_bound.重载需要重载==。</p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流入门级总结</title>
    <url>/2020/01/23/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%85%A5%E9%97%A8%E7%BA%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我对网络流的理解，大概就是一种常用于解决一些玄学匹配问题的图论算法，其难度在建图方面远远大于背板子(毕竟板子就是普通的bfs+dfs)。大体上会涉及到的题目分支有:</p>
<ul>
<li>最大流</li>
<li>最小割</li>
<li>费用流</li>
</ul>
<a id="more"></a>
<h1 id="网络流算法"><a href="#网络流算法" class="headerlink" title="网络流算法"></a>网络流算法</h1><h2 id="网络流概念"><a href="#网络流概念" class="headerlink" title="网络流概念"></a>网络流概念</h2><p>假想有一个水库，可以从水库源源不断地通过管道输出自来水，管道通往各个户主，管道有粗有细，最终都会流向附近的一条河。我们将水库，想象成一个点，叫他源点;户主也想象成一个个点，管道是一条条的有向边,每个边的边权是管道的容量，河流也想象成一个点，我们叫他汇点。最后可能是类似这样的图：<br><img src="/2020/01/23/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%85%A5%E9%97%A8%E7%BA%A7%E6%80%BB%E7%BB%93/AA.png" alt="TU"><br>由此引出以下我们需要的这几个概念</p>
<ul>
<li>源点：出发点</li>
<li>汇点：终点</li>
<li>容量：每条边(管道)最多能流过的量</li>
<li>流量：每条边(管道)已经流过的量</li>
<li>流：一个从源点流向汇点的合法的解的总流量</li>
<li>割：一个边集的边权和。这个边集满足，原图去掉这些边之后，源点与汇点将无法连通。</li>
</ul>
<p>最终要求解的问题：从源点到汇点最大的流是多少。</p>
<h2 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h2><p>建图时，不仅要建需要的边，还要建每条边的反向边，正向边的边权为容量，反向边边权为0，反向边的边权意义是该条边已经流过的流量，那么显然该条边还能够流的流量大小就是容量减去反向边的流量。至于为啥要建立反向边，下边会解释。</p>
<ul>
<li>每次都从源点进行广搜(仅搜索还有容量剩余的边)，搜索过程中保存搜索的路径，在搜到汇点之后停止。</li>
<li>这时我们得到一条从源点到汇点的路径(我们称之为增广路)，我们取路径中最小的边权x，将所有路径中的边的边权减去x，在其对应的反向边的边权上加上x,并在最终答案上加x。</li>
<li>如此往复，直到找不到一条增广路，此时得到的答案就是最大流。</li>
</ul>
<p>用手模拟一下的话会发现反向边的作用就是给了程序反悔的机会，在增广的过程中流过正向边就是水正向的流向汇点，流过反向边，就是逆向的流回源点。具体他为啥是对的。。。俺也弄不太清楚QAQ。<br>板子类似这样。。。~懒得在敲了。。。大部分时候用Dinic就挺好的。。。~<br>复杂度O($n^2m$)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pre[i]=edg[i]=<span class="number">-1</span>,flow[i]=INF;</span><br><span class="line">    pre[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(u==t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w&gt;<span class="number">0</span>&amp;&amp;pre[v]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[v]=u;</span><br><span class="line">                edg[v]=i;</span><br><span class="line">                flow[v]=<span class="built_in">min</span>(flow[u],e[i].w);</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[t]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=t;</span><br><span class="line">        <span class="keyword">while</span>(x!=s)&#123;</span><br><span class="line">            e[edg[x]].w-=flow[t];</span><br><span class="line">            e[edg[x]^<span class="number">1</span>].w+=flow[t];</span><br><span class="line">            x=pre[x];</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=flow[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h2><p>EK算法进行优化，实际上每bfs一次，在最短路没有变化之前，可以用dfs进行多次增广(也就是同时对几条相同长度的最短路增广)，思想是差不多的，大部分情况下比EK快一些。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=S;i&lt;=T;i++) dis[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[to]==<span class="number">-1</span>&amp;&amp;E[i].f)&#123;</span><br><span class="line">                dis[to] = dis[x]+<span class="number">1</span>;</span><br><span class="line">                q.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> used = <span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (E[i].f&amp;&amp;dis[to]==dis[x]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = dfs(to,<span class="built_in">min</span>(E[i].f,flow-used));</span><br><span class="line">            used+=tmp;</span><br><span class="line">            E[i].f-=tmp;</span><br><span class="line">            E[i^<span class="number">1</span>].f+=tmp;</span><br><span class="line">            <span class="keyword">if</span> (used==flow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!used) dis[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) ans+=dfs(S,INF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><p>意思就是每条边令有一个边权表示没流过单位流量花费的费用，要求在保证最大流的情况下使得总费用最小。<br>~虽然我并不知道他为啥是对的~一般的板子就是EK算法里bfs的部分改成SPFA或者dijkstra，最后求贡献时每次加<strong>增广路径上费用和*路径上最小容量</strong>,很好理解，所有的流都要经过每一条管道。<br>处理到后面可能会出现负环，用spfa会好写一点，dijkstra的费用流后边有时间补。<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1533" target="_blank" rel="noopener">hdu 1533</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;H[<span class="number">10010</span>],m[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,f,c;</span><br><span class="line">&#125;E[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,head[<span class="number">10000</span>],num[<span class="number">10000</span>],vis[<span class="number">10000</span>],S,T,ans,dis[<span class="number">10000</span>],pree[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> preV[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    E[++cnt].f = f;</span><br><span class="line">    E[cnt].c = c;</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    E[cnt].nxt = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=S;i&lt;=T;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">        vis[i] = <span class="number">0</span>;num[i]=<span class="number">0</span>;</span><br><span class="line">        preV[i] = pree[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    vis[S] = <span class="number">1</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">            <span class="keyword">if</span> (E[i].f&amp;&amp;dis[to]&gt;E[i].c+dis[x])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[x]+E[i].c;</span><br><span class="line">                pree[to] = i;</span><br><span class="line">                preV[to] = x;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[to] = <span class="number">1</span>;</span><br><span class="line">                    q.push(to);</span><br><span class="line">                    num[to]++;</span><br><span class="line">                    <span class="keyword">if</span> (num[to]&gt;=T) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preV[T]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_flow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(SPFA())&#123;</span><br><span class="line">        <span class="keyword">int</span> f = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=preV[i])</span><br><span class="line">            f = <span class="built_in">min</span>(f,E[pree[i]].f);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=preV[i])&#123;</span><br><span class="line">            E[pree[i]].f-=f;</span><br><span class="line">            E[pree[i]^<span class="number">1</span>].f+=f;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=f*dis[T];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">        <span class="keyword">if</span> (N==<span class="number">0</span>&amp;&amp;M==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) head[i] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> a[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j]==<span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[j]==<span class="string">'H'</span>)&#123;</span><br><span class="line">                    H[++cnt1].x = i;</span><br><span class="line">                    H[cnt1].y = j+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    m[++cnt2].x = i;</span><br><span class="line">                    m[cnt2].y = j+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> D = <span class="built_in">abs</span>(H[i].x-m[j].x)+<span class="built_in">abs</span>(H[i].y-m[j].y);</span><br><span class="line">                add(i,cnt1+j,<span class="number">1</span>,D);</span><br><span class="line">                add(cnt1+j,i,<span class="number">0</span>,-D);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        S = <span class="number">0</span>;T = cnt1+cnt2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;i++) &#123;</span><br><span class="line">            add(S,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            add(i,S,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=cnt1+<span class="number">1</span>;j&lt;=cnt1+cnt2;j++)&#123;</span><br><span class="line">            add(j,T,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            add(T,j,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        min_flow();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P2774" target="_blank" rel="noopener"><strong>方格取数</strong></a><br>将方格按横纵坐标和的奇偶性二分出两个点集，一个点集全部连向源点，另一个全部连向汇点，边权为点权。两个点集之间将冲突的点连一条边权为inf的边。求一个最小割(最大流等于最小割)，用总点权和减去最小割即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,f;</span><br><span class="line">&#125;E[<span class="number">500000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,head[<span class="number">100000</span>],S,T,ans,dis[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    E[++cnt].f = f;</span><br><span class="line">    E[cnt].nxt = head[x];</span><br><span class="line">    E[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=S;i&lt;=T;i++) dis[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[to]==<span class="number">-1</span>&amp;&amp;E[i].f)&#123;</span><br><span class="line">                dis[to] = dis[x]+<span class="number">1</span>;</span><br><span class="line">                q.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> used = <span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=head[x];i;i=E[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (E[i].f&amp;&amp;dis[to]==dis[x]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = dfs(to,<span class="built_in">min</span>(E[i].f,flow-used));</span><br><span class="line">            used+=tmp;</span><br><span class="line">            E[i].f-=tmp;</span><br><span class="line">            E[i^<span class="number">1</span>].f+=tmp;</span><br><span class="line">            <span class="keyword">if</span> (used==flow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!used) dis[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) ans+=dfs(S,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    S = <span class="number">0</span>;T = m*n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">            sum+=a;</span><br><span class="line">            <span class="keyword">if</span> ((i+j)%<span class="number">2</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                add(S,(i<span class="number">-1</span>)*n+j,a);</span><br><span class="line">                add((i<span class="number">-1</span>)*n+j,S,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> xx = i+dx[k];</span><br><span class="line">                    <span class="keyword">int</span> yy = j+dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=m&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        add((i<span class="number">-1</span>)*n+j,(xx<span class="number">-1</span>)*n+yy,INF);</span><br><span class="line">                        add((xx<span class="number">-1</span>)*n+yy,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                add((i<span class="number">-1</span>)*n+j,T,a);</span><br><span class="line">                add(T,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    Dinic();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum-ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC152&amp;&amp;Codeforces614(div2)</title>
    <url>/2020/01/20/ABC152-Codeforces614-div2/</url>
    <content><![CDATA[<p><strong><del>因为会做的题太少</del>一晚上的两场比赛放一起了</strong><br><a id="more"></a></p>
<h1 id="AtCoder"><a href="#AtCoder" class="headerlink" title="AtCoder"></a>AtCoder</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>M=N输出Yes,否则No</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>给出a,b,如果b小输出a个b,否则输出b个a</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个全排列，求出符合一下条件的位置i的个数：</p>
<ul>
<li>对于任意的$j(1\leq j\leq i)$,$a_i\leq a_j$</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>其实就是使当前位置为最小值的位置的数，维护一个前i项的最小值，每扫一个位置比一下大小，当前位置等于前i项最小值则答案+1</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>就不放我丑陋的代码了。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定N,求正整数数对(A,B)的个数满足：</p>
<ul>
<li>$A \leq N,B \leq N$</li>
<li>A的最左边的数字和B的最右边的数字相同，A的最右边的数字和B的最左边的数字相同，如{1,1}，{21,12}，{123,3401}</li>
</ul>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>记一个数组c[i][j],表示以i开头以j结尾的满足条件的数的个数，可以很快预处理出来。然后答案ans = $\sum_{i=1}^9\sum_{j=1}^9c[i][j]*c[j][i]$</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i==j&amp;&amp;i&lt;=N) c[i][j]++;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (i*tmp+j&lt;=N)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==N/tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j]+=N%tmp/<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;N%<span class="number">10</span>) c[i][j]--;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        c[i][j]+=tmp/<span class="number">10</span>;     </span><br><span class="line">        tmp*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">    ans+=c[i][j]*c[j][i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Codeforces"><a href="#Codeforces" class="headerlink" title="Codeforces"></a>Codeforces</h1><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个有n层的高楼，主角在第s层，每层都有餐厅，但是有k层关门了，现在把关门的k层的编号给你，问主角至少走几层才能到达餐厅吃饭。</p>
<h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>数据范围很小，将给定的k层排个序找s附近有多少关门的餐厅就行(或者不排序每次都暴力找也行$N^2$一样过)</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2001</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">int</span> n,s,k;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;s,&amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> is=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s==a[i])&#123;</span><br><span class="line">                is = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s-ans&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (is-ans&lt;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (s-ans!=a[is-ans]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s+ans&lt;=n)&#123;</span><br><span class="line">                <span class="keyword">if</span> (is+ans&gt;k) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (s+ans!=a[is+ans])<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>战无不败的JOE参加一个答题比赛，一开始他有n个对手，每轮题目答错的人会被淘汰,每轮题目过后，假设有s个JOE的对手在场上，JOE总能答对，然而对手会有t个人答错,这时JOE会得到$\frac t s$的赏金，一直进行到只剩JOE一人。问JOE最多能得到多少赏金。</p>
<h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>猜也应该是$\frac 1 n +\frac 1 {n-1}+\frac 1 {n-2}…+1$这样的结果，严谨的证明就不做了~其实是我不会QAQ~,感性思考一下，应该是场上的对手越少的时候没淘汰一位能得到的平均钱数就越多，然后每次都只淘汰一个人，就能保证含金量高的场次能进行得更多…..如果某一场淘汰了两人或者更多，那么就相当于这两人贡献了同样含金量场次只淘汰一人的两个赏金，而显然分开淘汰的话其中一些人的人均赏金是会更高的。</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a&lt;<span class="number">0</span>) <span class="keyword">return</span> -a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">0.0000001</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> i=n;<span class="built_in">abs</span>(i)&gt;eps;i--)&#123;</span><br><span class="line">        ans+=(<span class="keyword">double</span>)<span class="number">1</span>/i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个两行n列的网格，主角在(1,1),终点在(2,n),主角可以在水平和竖直方向上移动。然而某些网格有时会变化成laya,从而不能通过。一共有q个时刻，每个时刻都会变化一个网格，如果本来是普通网格，则变为laya;如果本来是laya，则变为普通网格;询问每个时刻，是否有路线可以让主角到达终点。</p>
<h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>分析题目，怎么才会导致无法通过呢？可以得出，当某一行的laya位置相对行的正对三个位置也有laya存在时，一定无法通过。所以我们得出只要维护对面三个格子也有laya的laya网格个数就好了，为0是一定可以通过，大于0则不能。</p>
<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">3</span>][<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r,c;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;r,&amp;c);</span><br><span class="line">        <span class="keyword">int</span> zz=(r==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[r][c]==<span class="number">0</span>)&#123;</span><br><span class="line">            a[r][c]=<span class="number">1</span>;</span><br><span class="line">            num[r][c] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,c<span class="number">-1</span>);j&lt;=<span class="built_in">min</span>(n,c+<span class="number">1</span>);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[zz][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num[zz][j]==<span class="number">0</span>) ans++;</span><br><span class="line">                    num[zz][j]++;</span><br><span class="line">                    num[r][c]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[r][c])ans++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           a[r][c]=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (num[r][c]) ans--;</span><br><span class="line">           num[r][c] = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,c<span class="number">-1</span>);j&lt;=<span class="built_in">min</span>(n,c+<span class="number">1</span>);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[zz][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    num[zz][j]--;</span><br><span class="line">                    <span class="keyword">if</span> (num[zz][j]==<span class="number">0</span>) ans--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>在一个平面系中，有一些特殊的点，他们满足：</p>
<ul>
<li>第0号点在(x0,y0).</li>
<li>对于第i号节点，他的位置为($a_x·x_{i-1}+b_x,a_y·y_{i-1}+b_y$)</li>
</ul>
<p>主角一开始在$(x_s,y_s)$,每秒他都可以向上下左右某个方向移动一个单位，问t秒内他最多能到达几个点</p>
<h3 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h3><p>乍一看以为是个普通的方格搜索题，一看数据范围$10^{16}$,直接告辞。再一观察，不对阿。。。这些特殊点分布有规律的，仔细想想应该是从左下向右上分布，而且左下相对密集一些。再考虑$a_x,a_y$，发现按照这个方法递增产生的点即使在1e16的范围内也就不到一百个而已.所以我们暴力去枚举每一个点，使得主角从起点到达这个点，然后再向左下方去找下一个点，期间记录他们的曼哈顿距离和，大于t的时候就跳出，最后从所有的答案里面取一个最大值即可。</p>
<h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> y[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxn = <span class="number">1e16</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x0,y0,ax,ay,bx,by;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> xs,ys,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>,&amp;x0,&amp;y0,&amp;ax,&amp;ay,&amp;bx,&amp;by);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;xs,&amp;ys,&amp;t);</span><br><span class="line">    x[<span class="number">0</span>]=x0;y[<span class="number">0</span>]=y0;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dis=<span class="number">0</span>;</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    maxn = <span class="built_in">min</span>(t+xs,t+ys)+t;</span><br><span class="line">    <span class="keyword">while</span>(x[i]&lt;=maxn&amp;&amp;y[i]&lt;=maxn)&#123; </span><br><span class="line">        i++;</span><br><span class="line">        x[i] = ax*x[i<span class="number">-1</span>]+bx;</span><br><span class="line">        y[i] = ay*y[i<span class="number">-1</span>]+by;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+<span class="built_in">abs</span>(x[i]-x[i<span class="number">-1</span>])+<span class="built_in">abs</span>(y[i]-y[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">        dis=<span class="built_in">abs</span>(x[j]-xs)+<span class="built_in">abs</span>(y[j]-ys);</span><br><span class="line">        <span class="keyword">int</span> k = j;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> xl = x[j],yl = y[j];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dis&lt;=t)&#123;</span><br><span class="line">            tmp++;</span><br><span class="line">            <span class="keyword">if</span> (k==<span class="number">0</span>) &#123;k=j;flag=<span class="literal">false</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) k--;<span class="keyword">else</span> k++;</span><br><span class="line">            <span class="keyword">if</span> (k&gt;i) <span class="keyword">break</span>;</span><br><span class="line">            dis+=<span class="built_in">abs</span>(x[k]-xl)+<span class="built_in">abs</span>(y[k]-yl);</span><br><span class="line">            xl = x[k];yl = y[k];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="QAQ两边一起掉分是真的快乐…-透"><a href="#QAQ两边一起掉分是真的快乐…-透" class="headerlink" title="QAQ两边一起掉分是真的快乐…~透~"></a>QAQ两边一起掉分是真的快乐…~透~</h2>]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>数论粗略扫盲(扫不完QAQ)</title>
    <url>/2020/01/19/%E6%95%B0%E8%AE%BA%E7%B2%97%E7%95%A5%E6%89%AB%E7%9B%B2-%E6%89%AB%E4%B8%8D%E5%AE%8CQAQ/</url>
    <content><![CDATA[<h1 id="裴-pei-蜀定理"><a href="#裴-pei-蜀定理" class="headerlink" title="裴(pei)蜀定理"></a>裴(pei)蜀定理</h1><a id="more"></a>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>设a,b是不全为零的整数，则存在整数x,y,使得ax+by=gcd(a,b).<br>代数几何中的一个定理，可以为其他的数论理论的论证做基础。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>其实贼显然。。。设g=gcd(a,b),显然有g|a,g|b,也肯定有g|ax,g|by,所以等式两边都同时除以g,得到</p>
<script type="math/tex; mode=display">\frac a g x +\frac b g y  = 1</script><p>$\frac a g$与$\frac b g$互质，一定能互相线性运算得到1，实际上是另一个定理，属于两数互质的充分必要条件,证明类似辗转相处法？，不继续证了就QAQ</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>推广到n个数是一样的，对于n个数$a_1,a_2,a_3…a_n$存在$x_1,x_2,x_3…x_n$使得<script type="math/tex">a_1x_1+a_2x_2+...+a_nx_n=gcd(a_1,a_2,...,a_n)</script></p>
<h2 id="应用n遍裴蜀定理即可"><a href="#应用n遍裴蜀定理即可" class="headerlink" title="应用n遍裴蜀定理即可"></a>应用n遍裴蜀定理即可</h2><h1 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>形如$ax\equiv b \pmod c$的方程称为线性同余方程(求x).</p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>定理基础</p>
<blockquote>
<p>定理1：求解$ax\equiv b \pmod c$与求解$ax + by = c$中的x是等价的。</p>
<p>定理2：若$gcd(a,b)=1$,且$x_0,y_0$为方程$ax+by=c$的一组解，则方程的任意解可以表示为$x = x_0+bt,y = y_0-at$,t取任意整数.</p>
</blockquote>
<p>根据定理1,我们只需要对$ax + by = c$进行求解。<br>由裴蜀定理得，一定存在在整数解x,y,满足ax+by=gcd(a,b),我们试着求解其中的x,y.<br>由欧几里得算法我们有gcd(a,b)=gcd(b,a%b),所以有：<br>$ax_1+by_1 = gcd(a,b)$<br>b$x_2$+(a%b)$y_2$ = gcd(b,a%b)<br>变幻  a%b  为  $a-\lfloor \frac a b \rfloor b$<br>b$x_2$+($a-\lfloor \frac a b \rfloor b$)$y_2$ = gcd(b,a%b)<br>即：<br>a$y_2$+b($x_2$-$\lfloor \frac a b \rfloor$) = gcd(b,a%b) = gcd(a,b) = a$x_1$+b$y_1$<br>所以有：<br>$x_1=y_2$ , $y_1=x_2-\lfloor \frac a b \rfloor$<br>递归求解下去，直到变为gcd(a,0)<br>这时我们直到ax+0*y=gcd(a,0) = a<br>取x=1,y=0向上回代即可.<br>求出一组特解$x_0,y_0$之后，我们得到了<script type="math/tex">ax_0+by_0=gcd(a,b)</script><br>设g = gcd(a,b)我们使等式两边同除以gcd(a,b),变为</p>
<script type="math/tex; mode=display">\frac a g x_0 +\frac b g y_0  = 1</script><p>此时使$a_2 =\frac a g$,$b_2=\frac b g$,变为</p>
<script type="math/tex; mode=display">a_2x_0 +b_2y_0 = 1</script><p>此时$a_2,b_2$互质，符合定理2原方程的特解为$x=(x_0/g)*c$,所以原同余方程的通解形式为:</p>
<script type="math/tex; mode=display">x+b_2t</script><p>(t取任意整数)<br>最小整数解为:<br>(x%$b_2$+$b_2$)%$b_2$</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://loj.ac/problem/2605" target="_blank" rel="noopener">同余方程</a></p>
<h2 id><a href="#" class="headerlink" title></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = x;</span><br><span class="line">    x = y;y = temp-(a/b)*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;b);</span><br><span class="line">    exgcd(a,b);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = b/gcd(a,b)*<span class="number">1</span>;<span class="comment">//此时c=1;</span></span><br><span class="line">    x/=gcd(a,b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(x%t+t)%t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><h2 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h2><p>求解如下形式的一元线性同余方程组：<br><img src="/2020/01/19/%E6%95%B0%E8%AE%BA%E7%B2%97%E7%95%A5%E6%89%AB%E7%9B%B2-%E6%89%AB%E4%B8%8D%E5%AE%8CQAQ/中国剩余定理.png" alt="中国剩余定理"><br>保证模数两两互质。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>留坑。。。</p>
<h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><p>如果模数不互质，则不能用一开始的方法直接去求，而改为求解n-1次同余方程(即使用n-1次拓展欧几里得算法)。<br>考虑求解两方程：<br>$x\equiv a_1 \pmod m_1$,$x\equiv a_2 \pmod m_2$<br>所以有x=$m_1p+a_1$=$m_2q+a_2$,<br>$m_1p-m_2q=a_2-a_1$<br>就是一个普通的线性同余方程，根据裴蜀定理有$a_2-a_1$一定能被$gcd(m_1,m_2)$整除，否则无解。<br>然后用拓展欧几里得算法解出来一组可行解(p,q).随便带入上边某个式子求出一个可行的x,使得A=x，M=$lcm(m_1,m_2)$,合并得到新的同余方程：<br>$x\equiv A \pmod M$<br>如此往复，将每一个方程合并，即可最终求解出A.</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4777" target="_blank" rel="noopener">洛谷模板题</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;g,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        g = a;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b,g,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);   </span></span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> nn,a,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;nn;</span><br><span class="line">    nn--;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a;</span><br><span class="line">    ll A = a,N=n;</span><br><span class="line">    x=a%n;</span><br><span class="line">    <span class="keyword">while</span>(nn--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a;</span><br><span class="line">        ll c = a-A;</span><br><span class="line">        ll g;</span><br><span class="line">        ll t;</span><br><span class="line">        exgcd(N,n,g,x,y);</span><br><span class="line">        x = x*c/g;</span><br><span class="line">        t = n/g;</span><br><span class="line">        x = (x%t+t)%t;</span><br><span class="line">        A +=x*N;</span><br><span class="line">        N = N*n/g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">long</span>)A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>~__int128是抄题解的。。。要不然真的过不了QAQ~</p>
<hr>
<h1 id="BSGS算法"><a href="#BSGS算法" class="headerlink" title="BSGS算法"></a>BSGS算法</h1><h2 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h2><p>用于求解形如$a^x \equiv b \pmod p$的方程。</p>
<h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><h3 id="普通的BSGS"><a href="#普通的BSGS" class="headerlink" title="普通的BSGS"></a>普通的BSGS</h3><p>在保证a与p互质的情况下，由费马小定理$a^{p-1} \equiv a \pmod p$,$a^0\equiv a \pmod p$,可知循环节小于等于p,所以令x从0~p-1依次查看是否靠谱即可，BSGS算法就是对此步骤进行的优化，类似于分块的思想。<br>具体来说，<br>我们使$x=A*\lceil\sqrt p\rceil - B$,<br>这样我们使$A \in [1,\lceil\sqrt p\rceil]$,$B \in [0,\lceil\sqrt p\rceil]$,<br>这样我们就可以通过变幻A与B取遍所有值。</p>
<p>原方程变为</p>
<script type="math/tex; mode=display">a^{A\*\lceil\sqrt p\rceil - B} \equiv b \pmod p</script><p>将带B的幂次方乘到右边,得到：</p>
<script type="math/tex; mode=display">a^{A\*\lceil\sqrt p\rceil } \equiv a^Bb \pmod p</script><p>这种形式的话我们将右边取值不同的B,将结果都塞进一个hash或者map里(unordered_map比map在这方面快一个logQAQ),然后左边依次枚举A，查看是否有相等的右边，这样就可以在$O(\sqrt p)$的复杂度里面将结果算出。</p>
<h3 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h3><p>有时候a与p并不互质，这时直接套用普通BSGS模板是不靠谱的。</p>
<p>我们设$g_1=gcd(a,p)$,将整个方程同时除以g,得到：</p>
<script type="math/tex; mode=display">\frac a {g_1} a^{x-1} = \frac b {g_1} \pmod {\frac p {g_1}}</script><p>如果还是不能满足$gcd(a,\frac p g)=1$,就可以继续除，使得$g_2 = gcd(a,\frac p g)$,然后得到:</p>
<script type="math/tex; mode=display">\frac a {g_1g_2} a^{x-2} = \frac b {g_1g_2} \pmod {\frac p {g_1g_2}}</script><p>一直除到满足互质条件即可,过程中应保重同余等式右边一定是个整数,如果不能整除则无解,记$D = \prod_{i=1}^n g_i$,得到最终式子：</p>
<script type="math/tex; mode=display">\frac a D a^{x-n} = \frac b D \pmod {\frac p D}</script><p>此时把左边$\frac a D$扔到右边(用逆元，或者不用扔过去也可以，一样算)。就变成了普通的BSGS模型了。最后求得x-k的值，加上k即可，要注意有可能0~k-1也有符合的值，所以需要特判一下。</p>
<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4195" target="_blank" rel="noopener">洛谷模板/Spoj3105</a><br>洛谷的数据会卡map，Spoj数据水一点。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll x,ll mod,ll m)</span><span class="comment">//用快速幂只是能快一点点，理论上不用也影响不大。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    ll temp = x;</span><br><span class="line">    <span class="keyword">while</span>(m)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m&amp;<span class="number">1</span>) ans = ans*temp%mod;</span><br><span class="line">        temp = temp*temp%mod;</span><br><span class="line">        m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">     ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>),<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,z,k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;z,&amp;k);</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">0</span>&amp;&amp;z==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> g;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> D = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            g = gcd(x,z);</span><br><span class="line">            <span class="keyword">if</span> (g==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (k%g)&#123;<span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);flag = <span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            z/=g;</span><br><span class="line">            k/=g;</span><br><span class="line">            D=D*x/g;</span><br><span class="line">            D%=z;</span><br><span class="line">            tt++;</span><br><span class="line">            <span class="keyword">if</span> (D==k)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;tt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        m.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="built_in">sqrt</span>(z)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line">            m[a] = i;</span><br><span class="line">            a*=x;</span><br><span class="line">            a%=z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = mul(x,z,p);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> A = temp*D%z;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(A)!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans = i*p-m[A]+tt;</span><br><span class="line">                <span class="keyword">if</span> (ans&gt;=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            A*=temp;</span><br><span class="line">            A%=z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans&gt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ Monthly 2020.1</title>
    <url>/2020/01/17/EOJ-Monthly-2020-1/</url>
    <content><![CDATA[<h1 id="A-回文时间"><a href="#A-回文时间" class="headerlink" title="A.回文时间"></a>A.回文时间</h1><a id="more"></a>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定初始的由年月日组成和回文串， 2020 年 1 月 22 日的 10:02:02，即20200122100202，问之后第k个回文时间串是什么。时是0~23，个位数自动补0。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>因为是回文串，所以只构造左半边就能行，暴力模拟即可，不过注意右半边对左半边的限制，比如日份只有11和22，月只有01，02,10,11,12等等。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">10</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    ss[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">'0'</span>;ss[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">    ss[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">'0'</span>;ss[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">'2'</span>;</span><br><span class="line">    ss[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'1'</span>;ss[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">    ss[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">'1'</span>;ss[<span class="number">3</span>][<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">    ss[<span class="number">4</span>][<span class="number">0</span>] = <span class="string">'1'</span>;ss[<span class="number">4</span>][<span class="number">1</span>] = <span class="string">'2'</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> a1=<span class="number">2</span>,a2=<span class="number">0</span>,a3=<span class="number">2</span>,a4=<span class="number">0</span>,b = <span class="number">0</span>,c=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">if</span> (c&gt;<span class="number">2</span>) &#123;c=<span class="number">1</span>;b++;&#125;</span><br><span class="line">        <span class="keyword">if</span> (b&gt;<span class="number">4</span>) &#123;b=<span class="number">0</span>;a4++;&#125;</span><br><span class="line">        <span class="keyword">if</span> (a4&gt;<span class="number">5</span>) &#123;a3++;a4=<span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (a3&gt;<span class="number">9</span>) &#123;a2++;a3=<span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (a2&gt;<span class="number">5</span>) &#123;a1++;a2=<span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a1&lt;&lt;a2&lt;&lt;a3&lt;&lt;a4&lt;&lt;ss[b][<span class="number">0</span>]&lt;&lt;ss[b][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ss[b][<span class="number">1</span>]&lt;&lt;ss[b][<span class="number">0</span>]&lt;&lt;a4&lt;&lt;a3&lt;&lt;a2&lt;&lt;a1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-数的变换"><a href="#E-数的变换" class="headerlink" title="E.数的变换"></a>E.数的变换</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于一个数x，我们按照固定的规则对他进行变换:</p>
<ul>
<li>如果x是奇数，则变幻成x-1;</li>
<li>如果x是偶数，则除以2。</li>
</ul>
<p>往复执行，知道x变为1.</p>
<p>我们在定义一个数x的序列为他变幻过程中会出现的数，比如 7 的变幻序列[7] = {7,6,3,2,1},10的变幻序列[10] = {10,5,4,2,1};<br>现在给定n,k。问在1到n的变幻序列中至少出现k次的最大的数是多少？</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>首先分析这个操作，在二进制的角度看就是把一个数的最右边从1变为0,在整体右移，类似这样的操作。然后很容易想到，如果给定一个数x，任何与他前缀相同的数都会对他产生贡献，比如1010的变幻序列一定会出现101。特别的，对于偶数其前缀不需要最右边第一位也相同，也可以产生贡献。<br>再考虑怎么求一个特定数x在1~n的序列里会出现几次，首先如果x \&lt; n,那么他一定会出现一次，如果将x右移一位，依然小于n,那么应该会再出现两次，即前缀相同，最右边一位随便选0或1，再右移一位会出现4次，再右移一位会出现8次。。。。。以此类推，特别的，如果右移到最后一位，而且x与n的前缀相同，则贡献应该是n尾部的数字，而不是二的幂次方的形式。这样我们就可以在O(logn)级别的时间里求出一个数x的出现次数。<br>然后算算时间复杂度。。。不靠谱，不可能每个数都算一遍。所以？二分答案。感性理解一下，这个数字的出现次数应该是数字越小出现次数越多的，满足某种单调性质。。。然后手速一发,wa了QAQ….之后听大哥劝解，才明白。。。。如图：<br><img src="/2020/01/17/EOJ-Monthly-2020-1/EOJE.png" alt="打表"><br>答案在奇偶数附近疯狂波动，于是想到，分奇偶进行二分答案。</p>
<h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h1><p><del>写的巨丑的代码QAQ</del><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  k,n,maxbit;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> bit2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((x&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;temp*=<span class="number">2</span>;bit2++;&#125;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((x&amp;maxbit)==<span class="number">0</span>||(x&amp;(~(bit2)))&lt;(n&amp;(~(bit2))))&#123;</span><br><span class="line">        ans+=temp;</span><br><span class="line">        temp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=(n&amp;(bit2))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        bit2&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        bit2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">        maxbit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp1 = n;</span><br><span class="line">        <span class="keyword">while</span>(temp1) &#123;maxbit&lt;&lt;=<span class="number">1</span>;temp1&gt;&gt;=<span class="number">1</span>;&#125;</span><br><span class="line">        maxbit&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>,r=n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (judge(mid*<span class="number">2</span>))&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,mid*<span class="number">2</span>);</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        l  = <span class="number">0</span>;r = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (judge(mid*<span class="number">2</span>+<span class="number">1</span>))&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,mid*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="结言"><a href="#结言" class="headerlink" title="结言"></a>结言</h1><p>华师大的月赛日常蹂躏我,本菜鸡只能搞两题,感觉怎么跟我们学校的月赛一样码量惊人还难想？太不是人儿了QAQ,小年都不给我留打游戏的时间<br><del>果然还是我太菜了QAQ</del></p>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>EOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>splay入门总结</title>
    <url>/2020/01/17/splay%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Splay伸展树的本质"><a href="#Splay伸展树的本质" class="headerlink" title="Splay伸展树的本质"></a>Splay伸展树的本质</h1><a id="more"></a>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>所谓二叉搜索树，就是保证内部数据每个节点只有两个儿子，而且左儿子小于本节点小于右节点，用这种性质有很多问题都可以很好地利用这种数据结构来完成。然而他有一个致命的缺点，就是普通的搜索树在数据不随机的情况下很容易退化成链，变得毫无用处。</p>
<h2 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h2><p>伸展树，就是对二叉搜索树的一种优化，通过不时地Splay(x)操作(讲x变为树的根)，使树的结构能趋向于平衡，从而保证时间优越性(不过显然常数贼大)。</p>
<h1 id="Splay的一些基本操作"><a href="#Splay的一些基本操作" class="headerlink" title="Splay的一些基本操作"></a>Splay的一些基本操作</h1><h2 id="基本操作需要的一些数据"><a href="#基本操作需要的一些数据" class="headerlink" title="基本操作需要的一些数据"></a>基本操作需要的一些数据</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> recy;<span class="comment">//在该节点的值的重复个数</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//以该节点为根的子树的元素的个数(包含该节点，不是节点数，因为一个节点可能包含多个元素)</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];<span class="comment">//左右儿子，左为0，右为1</span></span><br><span class="line">    <span class="keyword">int</span> fa;<span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">int</span> v;<span class="comment">//值</span></span><br><span class="line">&#125;A[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>,root=<span class="number">0</span>,SUM=<span class="number">0</span>;<span class="comment">//cnt使用的序号个数，root根节点序号，SUM一共使用的节点个数。</span></span><br></pre></td></tr></table></figure>
<h2 id="get-which-int-x"><a href="#get-which-int-x" class="headerlink" title="get_which(int x)"></a>get_which(int x)</h2><p>查询x是父亲的哪个儿子(左为0，右为1)，贼短，不单独写个函数也影响不大。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_which</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[A[x].fa].ch[<span class="number">1</span>]==x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="update-int-x"><a href="#update-int-x" class="headerlink" title="update(int x)"></a>update(int x)</h2><p>更新该节点下的元素个数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">    A[x].sum = A[x].recy;</span><br><span class="line">    <span class="keyword">if</span> (A[x].ch[<span class="number">1</span>]) A[x].sum+=A[A[x].ch[<span class="number">1</span>]].sum;</span><br><span class="line">    <span class="keyword">if</span> (A[x].ch[<span class="number">0</span>]) A[x].sum+=A[A[x].ch[<span class="number">0</span>]].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="rotate-int-x"><a href="#rotate-int-x" class="headerlink" title="rotate(int x)"></a>rotate(int x)</h2><p>作用是旋转自己与父节点，使得x的层数减1，也就是与根节点更靠近一些。具体需要改变三条关系，分别是自己与父亲，父亲与爷爷，自己与自己的左(或者右)儿子。</p>
<ul>
<li>使得父亲的左(右)儿子与自己的右(左)儿子连边(即自己的  自己与父亲关系相反的  那个儿子)</li>
<li>使自己与爷爷连边</li>
<li>使自己被父亲抢走的那个儿子变成父亲</li>
</ul>
<p>形象一点的如图：<br><img src="/2020/01/17/splay%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/rotate.jpg" alt="rotate"><br>当然还有其他情况，都符合以上三条，可以自己尝试画一画。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = A[x].fa,g_fa = A[fa].fa,ww = get_which(x),w2=get_which(fa);</span><br><span class="line">    A[fa].ch[ww] = A[x].ch[ww^<span class="number">1</span>];</span><br><span class="line">    A[A[x].ch[ww^<span class="number">1</span>]].fa = fa;</span><br><span class="line">    A[fa].fa = x;</span><br><span class="line">    A[x].fa = g_fa;</span><br><span class="line">    A[x].ch[ww^<span class="number">1</span>] = fa;</span><br><span class="line">    <span class="keyword">if</span> (g_fa)</span><br><span class="line">    A[g_fa].ch[w2] = x;</span><br><span class="line">    update(fa);</span><br><span class="line">    update(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Splay-int-x"><a href="#Splay-int-x" class="headerlink" title="Splay(int x)"></a>Splay(int x)</h2><p>作用是使得x成为伸展树的根。<br>显然就。。。不断地对rotate(x)就能达到这个效果。然而需要特判一下自己与父亲，父亲与爷爷的关系是否一样(是否三点一线)，如果是这种情况就需要先旋转父节点，再旋转自己。。。。一开始我也并没有太懂，但是在黄某大仙的点拨下明白了些，就是说假如是一条链的话，你不断的rotate自己最终顶多也就是变成两条链，而特判之后splay会均衡很多。。。。其实感觉特判不特判都有可能使得结构变得不均衡，但是特判之后造呢种垃圾数据应该更难一些。<br>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa;fa=A[x].fa;rotate(x))</span><br><span class="line">    <span class="keyword">if</span> (A[fa].fa)</span><br><span class="line">    rotate((get_which(x)==get_which(fa))?fa:x);</span><br><span class="line">    root = x;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="insert-int-x"><a href="#insert-int-x" class="headerlink" title="insert(int x)"></a>insert(int x)</h2><p>插入一个节点x。<br>就是普通的在平衡树上插入一个节点，不断地向下找，比当前节点大就找右儿子，小就找左儿子，相等就返回,移动到空节点就造点，最后将x旋转到根节点即可。(理论上不splay(x)也不影响正确性，但是有事没事splay一下嘛，保证树总是均衡的)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        A[cnt].ch[<span class="number">0</span>]=A[cnt].ch[<span class="number">1</span>]=A[cnt].fa=<span class="number">0</span>;</span><br><span class="line">        A[cnt].v = x;</span><br><span class="line">        A[cnt].sum = A[cnt].recy = <span class="number">1</span>;</span><br><span class="line">        root = cnt;</span><br><span class="line">        SUM++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = root,fa=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[now].v==x)&#123;</span><br><span class="line">            A[now].recy++;</span><br><span class="line">            update(now);</span><br><span class="line">            update(fa);</span><br><span class="line">            splay(now);</span><br><span class="line">            SUM++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa = now;</span><br><span class="line">        now = A[now].ch[A[now].v&lt;x];</span><br><span class="line">        <span class="keyword">if</span> (!now)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            A[fa].ch[A[fa].v&lt;x] = cnt;</span><br><span class="line">            A[cnt].fa = fa;</span><br><span class="line">            A[cnt].ch[<span class="number">0</span>]=A[cnt].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            A[cnt].recy = A[cnt].sum = <span class="number">1</span>;</span><br><span class="line">            A[cnt].v = x;</span><br><span class="line">            splay(cnt);</span><br><span class="line">            SUM++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="find-rank-int-x"><a href="#find-rank-int-x" class="headerlink" title="find_rank(int x)"></a>find_rank(int x)</h2><p>找数字x的排名。<br>因为维护了子树和，所以这个还是容易实现的，每次根据当前节点与x的大小关系，比x大就去左儿子找，比x小就去右儿子找(答案加上左儿子的元素与该节点的重复元素的数)，相等就可以返回了。<br><strong>最后有事没事splay一下x</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_rank</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//查x的排名；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!now) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;A[now].v)&#123;</span><br><span class="line">            now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=A[A[now].ch[<span class="number">0</span>]].sum;</span><br><span class="line">            <span class="keyword">if</span> (x==A[now].v) &#123;</span><br><span class="line">                splay(now);</span><br><span class="line">                <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=A[now].recy;</span><br><span class="line">            now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="find-num-int-rank"><a href="#find-num-int-rank" class="headerlink" title="find_num(int rank)"></a>find_num(int rank)</h2><p>查找排名为rank的数字<br>与上一个相似，只是判断去左右儿子的条件改为rank与当前节点左子树的元素个数。具体见代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> rank)</span><span class="comment">//查排名为rank的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rank&gt;SUM) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[now].ch[<span class="number">0</span>]&amp;&amp;A[A[now].ch[<span class="number">0</span>]].sum&gt;=rank)</span><br><span class="line">        now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rank-=A[now].ch[<span class="number">0</span>]?A[A[now].ch[<span class="number">0</span>]].sum:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank&lt;=A[now].recy) <span class="keyword">return</span> A[now].v;</span><br><span class="line">            rank-=A[now].recy;</span><br><span class="line">            now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="find-pre"><a href="#find-pre" class="headerlink" title="find_pre()"></a>find_pre()</h2><p>查找根节点的前驱。<br>x的前驱就是比x小的最大的数，在平衡树上的体现就是左子树上最右边的数。代码很好写。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = A[root].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(A[now].ch[<span class="number">1</span>]) now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="find-last"><a href="#find-last" class="headerlink" title="find_last()"></a>find_last()</h2><p>查找根节点的后继。<br>x的后继就是比x大的最小的数，即右子树上最左边的数。代码与上一个相似。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = A[root].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(A[now].ch[<span class="number">0</span>]) now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="del-int-x"><a href="#del-int-x" class="headerlink" title="del(int x)"></a>del(int x)</h2><p>删除值x。<br>对于删除点的操作是有点麻烦的。。。</p>
<ul>
<li>首先我们把x对应的节点splay到根节点。</li>
<li>特判掉左右儿子有不存在的情况，左儿子不存在就直接以右儿子为根，右儿子不存在就直接以左儿子为根，或者左右儿子都不存在就把根归零，然后干脆利落的删掉就可以了。</li>
<li>大部分时候显然左右儿子都是有的，这时候我们在把x的前驱(就叫他pre吧)splay到根节点，这时候可以想象得到，pre为根，x会是他的右儿子，而且x的左儿子为空(因为前驱和x是最相近的两个数嘛)，这时候我们把pre的右儿子连向x的右儿子，然后删掉x即可，记得更新pre的节点数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!now) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[now].v==x) <span class="keyword">return</span> now;</span><br><span class="line">        now = A[now].ch[A[now].v&lt;x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    A[x].ch[<span class="number">0</span>] = A[x].ch[<span class="number">1</span>] = A[x].fa = <span class="number">0</span>;</span><br><span class="line">    A[x].recy = A[x].sum = <span class="number">0</span>;</span><br><span class="line">    A[x].v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//删除X</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> is = <span class="built_in">find</span>(x); </span><br><span class="line">    <span class="keyword">if</span> (is==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    SUM--;</span><br><span class="line">    splay(is);</span><br><span class="line">    <span class="keyword">if</span> (A[root].recy&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        A[root].recy--;</span><br><span class="line">        update(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">0</span>]&amp;&amp;!A[root].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        clean(root);</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> old_root = root;</span><br><span class="line">        root = A[root].ch[<span class="number">1</span>];</span><br><span class="line">        A[root].fa = <span class="number">0</span>;</span><br><span class="line">        clean(old_root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> old_root = root;</span><br><span class="line">        root = A[root].ch[<span class="number">0</span>];</span><br><span class="line">        A[root].fa = <span class="number">0</span>;</span><br><span class="line">        clean(old_root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre = find_pre();</span><br><span class="line">    splay(pre);</span><br><span class="line">    <span class="keyword">int</span> old_root = A[pre].ch[<span class="number">1</span>];</span><br><span class="line">    A[pre].ch[<span class="number">1</span>] = A[old_root].ch[<span class="number">1</span>];</span><br><span class="line">    A[A[old_root].ch[<span class="number">1</span>]].fa = pre;</span><br><span class="line">    clean(old_root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="留坑再补"><a href="#留坑再补" class="headerlink" title="留坑再补"></a>留坑再补</h2><h1 id="结言"><a href="#结言" class="headerlink" title="结言"></a>结言</h1>写完了高中的大恐惧splay之后才发现。。。这个也不难阿。。。。只是长而已。。。<br><a href="https://www.luogu.com.cn/problem/P3369" target="_blank" rel="noopener">模板题</a><br>附上我188行的垃圾代码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> recy;<span class="comment">//在该节点的值的重复个数</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//以该节点为根的子树的元素的个数(包含该节点，不是节点数，因为一个节点可能包含多个元素)</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];<span class="comment">//左右儿子，左为0，右为1</span></span><br><span class="line">    <span class="keyword">int</span> fa;<span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">int</span> v;<span class="comment">//值</span></span><br><span class="line">&#125;A[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>,root=<span class="number">0</span>,SUM=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_which</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[A[x].fa].ch[<span class="number">1</span>]==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">    A[x].sum = A[x].recy;</span><br><span class="line">    <span class="keyword">if</span> (A[x].ch[<span class="number">1</span>]) A[x].sum+=A[A[x].ch[<span class="number">1</span>]].sum;</span><br><span class="line">    <span class="keyword">if</span> (A[x].ch[<span class="number">0</span>]) A[x].sum+=A[A[x].ch[<span class="number">0</span>]].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = A[x].fa,g_fa = A[fa].fa,ww = get_which(x),w2=get_which(fa);</span><br><span class="line">    A[fa].ch[ww] = A[x].ch[ww^<span class="number">1</span>];</span><br><span class="line">    A[A[x].ch[ww^<span class="number">1</span>]].fa = fa;</span><br><span class="line">    A[fa].fa = x;</span><br><span class="line">    A[x].fa = g_fa;</span><br><span class="line">    A[x].ch[ww^<span class="number">1</span>] = fa;</span><br><span class="line">    <span class="keyword">if</span> (g_fa)</span><br><span class="line">    A[g_fa].ch[w2] = x;</span><br><span class="line">    update(fa);</span><br><span class="line">    update(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fa;fa=A[x].fa;rotate(x))</span><br><span class="line">    <span class="keyword">if</span> (A[fa].fa)</span><br><span class="line">    rotate((get_which(x)==get_which(fa))?fa:x);</span><br><span class="line">    root = x;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        A[cnt].ch[<span class="number">0</span>]=A[cnt].ch[<span class="number">1</span>]=A[cnt].fa=<span class="number">0</span>;</span><br><span class="line">        A[cnt].v = x;</span><br><span class="line">        A[cnt].sum = A[cnt].recy = <span class="number">1</span>;</span><br><span class="line">        root = cnt;</span><br><span class="line">        SUM++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = root,fa=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[now].v==x)&#123;</span><br><span class="line">            A[now].recy++;</span><br><span class="line">            update(now);</span><br><span class="line">            update(fa);</span><br><span class="line">            splay(now);</span><br><span class="line">            SUM++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa = now;</span><br><span class="line">        now = A[now].ch[A[now].v&lt;x];</span><br><span class="line">        <span class="keyword">if</span> (!now)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            A[fa].ch[A[fa].v&lt;x] = cnt;</span><br><span class="line">            A[cnt].fa = fa;</span><br><span class="line">            A[cnt].ch[<span class="number">0</span>]=A[cnt].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            A[cnt].recy = A[cnt].sum = <span class="number">1</span>;</span><br><span class="line">            A[cnt].v = x;</span><br><span class="line">            splay(cnt);</span><br><span class="line">            SUM++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_rank</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//查x的排名；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!now) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;A[now].v)&#123;</span><br><span class="line">            now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=A[A[now].ch[<span class="number">0</span>]].sum;</span><br><span class="line">            <span class="keyword">if</span> (x==A[now].v) &#123;</span><br><span class="line">                splay(now);</span><br><span class="line">                <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=A[now].recy;</span><br><span class="line">            now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_num</span><span class="params">(<span class="keyword">int</span> rank)</span><span class="comment">//查排名为rank的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rank&gt;SUM) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[now].ch[<span class="number">0</span>]&amp;&amp;A[A[now].ch[<span class="number">0</span>]].sum&gt;=rank)</span><br><span class="line">        now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rank-=A[now].ch[<span class="number">0</span>]?A[A[now].ch[<span class="number">0</span>]].sum:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank&lt;=A[now].recy) <span class="keyword">return</span> A[now].v;</span><br><span class="line">            rank-=A[now].recy;</span><br><span class="line">            now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!now) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[now].v==x) <span class="keyword">return</span> now;</span><br><span class="line">        now = A[now].ch[A[now].v&lt;x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = A[root].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(A[now].ch[<span class="number">1</span>]) now = A[now].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = A[root].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(A[now].ch[<span class="number">0</span>]) now = A[now].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    A[x].ch[<span class="number">0</span>] = A[x].ch[<span class="number">1</span>] = A[x].fa = <span class="number">0</span>;</span><br><span class="line">    A[x].recy = A[x].sum = <span class="number">0</span>;</span><br><span class="line">    A[x].v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//删除X</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> is = <span class="built_in">find</span>(x); </span><br><span class="line">    <span class="keyword">if</span> (is==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    SUM--;</span><br><span class="line">    splay(is);</span><br><span class="line">    <span class="keyword">if</span> (A[root].recy&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        A[root].recy--;</span><br><span class="line">        update(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">0</span>]&amp;&amp;!A[root].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        clean(root);</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> old_root = root;</span><br><span class="line">        root = A[root].ch[<span class="number">1</span>];</span><br><span class="line">        A[root].fa = <span class="number">0</span>;</span><br><span class="line">        clean(old_root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A[root].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> old_root = root;</span><br><span class="line">        root = A[root].ch[<span class="number">0</span>];</span><br><span class="line">        A[root].fa = <span class="number">0</span>;</span><br><span class="line">        clean(old_root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre = find_pre();</span><br><span class="line">    splay(pre);</span><br><span class="line">    <span class="keyword">int</span> old_root = A[pre].ch[<span class="number">1</span>];</span><br><span class="line">    A[pre].ch[<span class="number">1</span>] = A[old_root].ch[<span class="number">1</span>];</span><br><span class="line">    A[A[old_root].ch[<span class="number">1</span>]].fa = pre;</span><br><span class="line">    clean(old_root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,opt,num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;opt,&amp;num);</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">1</span>) &#123;insert(num);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">2</span>) &#123;del(num);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">3</span>) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find_rank(num));<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">4</span>) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find_num(num));<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">5</span>) &#123;insert(num);<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,A[find_pre()].v);del(num);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">6</span>) &#123;insert(num);<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,A[find_last()].v);del(num);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机相关总结</title>
    <url>/2020/01/15/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h1><ul>
<li>Trie树</li>
<li>KMP<a id="more"></a>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1>给定多个模式串和文本串，求模式串在文本串中的出线次数记相关问题。<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="trie树上的匹配"><a href="#trie树上的匹配" class="headerlink" title="trie树上的匹配"></a>trie树上的匹配</h2>所谓AC自动机，其实就是trie树在KMP的思想下进行优化。对于多个模式串的匹配问题可以想到只用trie树显然也是可以做对的，只是复杂度是$N^2$级别的，不可接受。<br>具体来说，比如我们给出模式串acbc,bc,c.然后建树如下：<br><img src="/2020/01/15/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/AC1.jpg" alt="AC1"><br>我们去匹配文本串acbc，假设我们只是单纯的trie树匹配，那么方法就是先匹配a开头的串，再匹配c开头的串，再匹配b开头的串，再匹配c开头的串，就与普通的单串暴力匹配子串有些类似，这样就效率有些慢，而我们发现如果我们匹配第一个串ac碰到c的时候，完全可能将第三个模式串的贡献算一遍，在匹配到acbc的时候，也可以把bc和c的贡献都去算一遍，这样实际只需要匹配一遍就可，每匹配一个字符都可以把他们可能产生的贡献都去记录一遍。这样我们可以构建一个失配指针fail去实现这个。<h2 id="构建fail指针"><a href="#构建fail指针" class="headerlink" title="构建fail指针"></a>构建fail指针</h2>fail指针具体来说是什么呢？<br>（其实严格来将并不一定是失配了才需要用到fail指针，只是一个名字而已）他的作用就是每匹配到一个字符，都去找他可能产生的其他串的贡献。一个i节点字符串是从root到i路径上的节点构成的，我们让i的fail指针指向一个深度最深的，其前缀与i串的后缀相同的节点j即可构建出来的fail指正大概长这样——<br><img src="/2020/01/15/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/AC2.png" alt="AC2"><br>显然在跳fail指针的过程中深度一定是递减的(因为是后缀嘛。。跳过去深度只能小于等于原来的，但是如果等于那不就是原串了嘛，所以一定是递减的)，所以每次最多跳(深度)次,每一个字符都跳的话是n,总复杂度大概n*(模式串最长长度)这个样子。<br>构建过程是采用bfs的形式，首先构建出来trie树，然后在trie树上做bfs,遍历某个节点的所有子节点:</li>
<li>如果子节点存在，则使子节点入队，并让子节点的fail指针指向该节点的fail指针指向的节点的对应子节点；</li>
<li>如果子节点不存在，则使得该子节点指向其fail指针所指向节点的对应子节点。</li>
<li>初始条件是root节点的所有子节点的fail指针都指向root(显然)。</li>
</ul>
<p>(具体想不太明白也没啥，这个地方背板子就行)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">       <span class="keyword">if</span> (AC[<span class="number">0</span>].vis[i]) </span><br><span class="line">       &#123;</span><br><span class="line">           AC[AC[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">            Q.push(AC[<span class="number">0</span>].vis[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    AC[<span class="number">0</span>].fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (AC[x].vis[i])&#123;</span><br><span class="line">                AC[AC[x].vis[i]].fail = AC[AC[x].fail].vis[i];</span><br><span class="line">                Q.push(AC[x].vis[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            AC[x].vis[i] = AC[AC[x].fail].vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>在trie树上每匹配一个字符，就把相应的贡献通过跳fail指针算一遍，因为处理过不存在的子节点，所以每次匹配都会到他应该有的位置。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AC_Query</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        now = AC[now].vis[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = now;t&amp;&amp;AC[t].<span class="built_in">end</span>!=<span class="number">-1</span>;t=AC[t].fail)&#123;</span><br><span class="line">            ans+= AC[t].<span class="built_in">end</span>;</span><br><span class="line">            AC[t].<span class="built_in">end</span> = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><a href="https://www.luogu.com.cn/problem/P3808" target="_blank" rel="noopener"><strong>洛谷P3808 AC自动机</strong></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">&#125;AC[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (AC[now].vis[id]==<span class="number">0</span>)&#123;</span><br><span class="line">            AC[now].vis[id] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = AC[now].vis[id];</span><br><span class="line">    &#125;</span><br><span class="line">    AC[now].<span class="built_in">end</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">       <span class="keyword">if</span> (AC[<span class="number">0</span>].vis[i]) </span><br><span class="line">       &#123;</span><br><span class="line">           AC[AC[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">            Q.push(AC[<span class="number">0</span>].vis[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    AC[<span class="number">0</span>].fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (AC[x].vis[i])&#123;</span><br><span class="line">                AC[AC[x].vis[i]].fail = AC[AC[x].fail].vis[i];</span><br><span class="line">                Q.push(AC[x].vis[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            AC[x].vis[i] = AC[AC[x].fail].vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AC_Query</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        now = AC[now].vis[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = now;t&amp;&amp;AC[t].<span class="built_in">end</span>!=<span class="number">-1</span>;t=AC[t].fail)&#123;</span><br><span class="line">            ans+= AC[t].<span class="built_in">end</span>;</span><br><span class="line">            AC[t].<span class="built_in">end</span> = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        build(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Get_fail();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;AC_Query(s)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="https://www.luogu.com.cn/problem/P3796" target="_blank" rel="noopener">加强版</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">&#125;AC[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (AC[now].vis[id]==<span class="number">0</span>)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) AC[cnt].vis[i] = <span class="number">0</span>;</span><br><span class="line">            AC[cnt].<span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">            AC[cnt].fail = <span class="number">0</span>;</span><br><span class="line">            AC[now].vis[id] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = AC[now].vis[id];</span><br><span class="line">    &#125;</span><br><span class="line">    AC[now].<span class="built_in">end</span>=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">       <span class="keyword">if</span> (AC[<span class="number">0</span>].vis[i]) </span><br><span class="line">       &#123;</span><br><span class="line">           AC[AC[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">            Q.push(AC[<span class="number">0</span>].vis[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    AC[<span class="number">0</span>].fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (AC[x].vis[i])&#123;</span><br><span class="line">                AC[AC[x].vis[i]].fail = AC[AC[x].fail].vis[i];</span><br><span class="line">                Q.push(AC[x].vis[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            AC[x].vis[i] = AC[AC[x].fail].vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AC_Query</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        now = AC[now].vis[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = now;t;t=AC[t].fail)&#123;</span><br><span class="line">            num[AC[t].<span class="built_in">end</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> ss[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) AC[<span class="number">0</span>].vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ss[i];</span><br><span class="line">        build(ss[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    Get_fail();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) num[i]=<span class="number">0</span>;</span><br><span class="line">    AC_Query(s);</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (temp&lt;num[i]) temp = num[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (temp==num[i]) <span class="built_in">cout</span>&lt;&lt;ss[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="https://www.luogu.com.cn/problem/P5357" target="_blank" rel="noopener"><strong>二次加强版</strong></a><br>实际上fail指针满足拓扑结构，所以可以在fail指针上做拓扑DP<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> fail;</span><br><span class="line">&#125;AC[<span class="number">2000001</span>];</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">2000051</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">2000001</span>];</span><br><span class="line"><span class="keyword">int</span> anss[<span class="number">200051</span>];</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">2000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (AC[now].vis[id]==<span class="number">0</span>)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            AC[now].vis[id] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = AC[now].vis[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!AC[now].<span class="built_in">end</span>)AC[now].<span class="built_in">end</span> = v;</span><br><span class="line">    Map[v] = AC[now].<span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">       <span class="keyword">if</span> (AC[<span class="number">0</span>].vis[i]) </span><br><span class="line">       &#123;</span><br><span class="line">           AC[AC[<span class="number">0</span>].vis[i]].fail = <span class="number">0</span>;</span><br><span class="line">            Q.push(AC[<span class="number">0</span>].vis[i]);</span><br><span class="line">            in[<span class="number">0</span>]++;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (AC[x].vis[i])&#123;</span><br><span class="line">                AC[AC[x].vis[i]].fail = AC[AC[x].fail].vis[i];</span><br><span class="line">                in[AC[AC[x].vis[i]].fail]++;</span><br><span class="line">                Q.push(AC[x].vis[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            AC[x].vis[i] = AC[AC[x].fail].vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AC_Query</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = s.length();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        now = AC[now].vis[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        anss[now]++;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> ss[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        build(s,i);</span><br><span class="line">    &#125;</span><br><span class="line">    Get_fail();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    AC_Query(s);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span> (in[i]==<span class="number">0</span>) Q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();     </span><br><span class="line">        num[AC[x].<span class="built_in">end</span>] = anss[x]; </span><br><span class="line">        Q.pop();</span><br><span class="line">        in[AC[x].fail]--;</span><br><span class="line">        anss[AC[x].fail]+=anss[x];</span><br><span class="line">        <span class="keyword">if</span> (in[AC[x].fail]==<span class="number">0</span>) Q.push(AC[x].fail);</span><br><span class="line">     </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;num[Map[i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="然而我只会敲板子QAQAQAQ"><a href="#然而我只会敲板子QAQAQAQ" class="headerlink" title="然而我只会敲板子QAQAQAQ"></a>然而我只会敲板子QAQAQAQ</h1>]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Educational Round 80</title>
    <url>/2020/01/15/Codeforces-Educational-Round-80/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定d,n,求x+$\lceil\frac d {x+1}\rceil$的值能否小于等于n<br><a id="more"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>实际上没啥好纠结的，对号函数嘛，一定在x取$\sqrt d$附近的时候取最小，所以就在呢个点附近求一下就好了。~为这道水题纠结半天真的不值得QAQ~</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,d;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (d%(x+<span class="number">1</span>)) ans++;</span><br><span class="line">    ans+=d/(x+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;d);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ss = <span class="built_in">sqrt</span>(d);</span><br><span class="line">        <span class="comment">// long long ss = 0;</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l = <span class="built_in">max</span>(ss<span class="number">-100</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">0</span>);l&lt;=<span class="built_in">min</span>(ss+<span class="number">100</span>,n<span class="number">-1</span>);l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;l&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (l+f(l)&lt;=n) flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定范围A,B，问有多少个数对(a,b)  (1\&lt;=a\&lt;=A,1\&lt;=b\&lt;=B),满足a*b+a+b=conc(a,b)。conc(a,b)即将两个数当字符串连接起来，比如conc(12,34)=1234.</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>后边的连接显然就是a乘上一个10的幂加b的形式，等式两边同时-b，然后左边可以合并同类项，等号两边再约去a，结果就是b+1=$10^?$的形式。显然可以发现，最后符合条件的数对，b一定是个$10^?-1$,即9,99,999….而a可以取任意值。所以就。。。。随便做了。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=temp)&#123;</span><br><span class="line">    temp = temp*<span class="number">10</span>+<span class="number">9</span>;</span><br><span class="line">    ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> A,B;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;A,&amp;B);</span><br><span class="line">        cout&lt;&lt;A*bit(B)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>emmmmm,感觉已经够简练了，没啥好概括的，直接上题面趴。。。。。<br><a href="http://codeforces.com/contest/1288/problem/C" target="_blank" rel="noopener"><strong>Two Arrays</strong></a></p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>注意到a,b一定是两个有序序列，而且a的末尾一定小于等于b的末尾。因此显然有dp做法——dp[i][j]代表长度为i以j结尾的序列有多少种,转移方程为——<script type="math/tex">dp[i][j] = \sum_{k=1}^ndp[i-1][k]</script>边界条件dp[1][?] = 1。处理之后再用长度为m的dp数据再算一遍即可(因为对a,b序列的处理几乎是一样的，所以算一遍dp数组正反着用就可以了).复杂度O($n^2m$)….某黄姓大仙还有O(mn)的算法，太顶了%%%%</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">11</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> k=<span class="number">1</span>;k&lt;=j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">            dp[i][j]+=dp[i<span class="number">-1</span>][k];</span><br><span class="line">            dp[i][j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">            temp += dp[m][j];</span><br><span class="line">            temp %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=dp[m][i]*temp;</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定n个长度为m的数列，你可以将两个数列合并为一个长度同为m的新数列，从而使得新数列的对应位置的数字为两原数列对应数字的最大值，问合并哪两个数列可以使的合并后得到的数列的最小值最大。</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>在看到最小值最大这种条件的时候就应该反应出来这道题大概率是个二分答案了，事实上也就是个二分答案。如何验证一个答案是否可行呢，因为m特别小，所以可以考虑每次都状态压缩一下每一个数列。假设验证的是x，则如果数列的某个数大于等于x,则在对应位赋值1,否则为0,这样一来枚举每一个数列的子集，看他的补集是否存在即可验证答案正确性，也许会有答案为不存在的数，但是继续二分最终答案一定是某一个x等于某个数列值的答案，因此正确性可以保证。<br>复杂度O($2^m*n\log n$)</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">300010</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> vis[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Map[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,ansl,ansr;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">if</span> (a[i][j]&gt;=x) temp|=(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>));</span><br><span class="line">        vis[temp] = i;</span><br><span class="line">        Map[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> zz = (<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;j++)</span><br><span class="line">        <span class="keyword">if</span> ((j|Map[i])&lt;=Map[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[(~j)&amp;zz]!=<span class="number">0</span>)&#123;</span><br><span class="line">                ansl = i,ansr = vis[(~j)&amp;zz];</span><br><span class="line">                flag = <span class="literal">true</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (judge(mid))&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ansl&lt;&lt;<span class="string">" "</span>&lt;&lt;ansr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定n,你得到一个1,2,3,4,5,6,7…n-1,n的序列，再给定m，有m次操作，每次指定一个数，将该数移动到队首，该数字前面的数字顺次前移，后面的数字不变，比如一开始为[1,2,3,4,5]，指定3，得到[3,1,2,4,5],再指定4，得到[4,3,1,2,5],以此类推。。。问，所有操作结束后每个数字最靠前和最靠后的位置分别是多少。</p>
<h2 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h2><p>题目很唬人，让人联想到一堆恐怖的数据结构，然而实际上树状数组就可以做。</p>
<ul>
<li>先来考虑最靠前的位置，显然每次对x操作都只会影响x以及其之前的数的位置，而且只有x的位置会变小，也就是说，每次操作只需要维护x的最小位置即可(实际上最小位置只有他的原位置和1这两种情况)。</li>
<li>对于最靠后的位置，对于数x操作的时候查一下他前面有几个数，从而维护一下x的最靠后位置，其他受影响的数并不需要去每次都维护，只需要最后所有操作结束后再维护一遍即可，查找前面有几个数可以用树状数组维护。</li>
<li>对于树状数组的使用，可以一开始对1~m留空，使用m+1~m+n，每个点赋值1表示每一个数，这样在求某个元素的位置就是取他的前缀和。然后每次操作对该数对应的位置-1，在前面的新位置+1,每个数对应的位置额外开个数组维护一下即可。</li>
</ul>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T[<span class="number">600100</span>],Map[<span class="number">300100</span>],A[<span class="number">300100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=sum)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x]+=v;</span><br><span class="line">        x+=x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=T[x];</span><br><span class="line">        x-=x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    sum = n+m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;insert(m+i,<span class="number">1</span>);Map[i] = m+i;&#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)A[i][<span class="number">1</span>]=A[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=m,x;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        A[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> is = query(Map[x]);</span><br><span class="line">        A[x][<span class="number">1</span>] = <span class="built_in">max</span>(A[x][<span class="number">1</span>],is);</span><br><span class="line">        insert(Map[x],<span class="number">-1</span>);</span><br><span class="line">        insert(i,<span class="number">1</span>);</span><br><span class="line">        Map[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> is = query(Map[i]);</span><br><span class="line">        A[i][<span class="number">1</span>] = <span class="built_in">max</span>(A[i][<span class="number">1</span>],is);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,A[i][<span class="number">0</span>],A[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数相关总结</title>
    <url>/2020/01/13/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>欧拉函数$\phi(n)$表示小于等于n的正整数中与n互质的数的数目<br><a id="more"></a></p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ul>
<li>积性函数~虽然我不会证~</li>
<li>$\phi(1)=1$</li>
<li>对于质数n,$\phi(n)=n-1$</li>
<li>对于质数的幂次方，$n=p^k$,则有$\phi(n)=p^{k-1}*(p-1)$</li>
</ul>
<p>对于性质4,k=1是显然是成立的，那么我们假设在性质4在k-1的条件下成立，对于1~$p^k$,每一个数都可以表示成$a*p^{k-1}+b$的形式，($0&lt;=a&lt;=p-1$,$1&lt;=b&lt;=p^k$),因为符合欧拉函数定义的数一定其中的b一定不存在因子p,所以对于每一轮b在1到$p^k$的过程中，有贡献的次数刚好是$\phi(p^{k-1})$,一共p轮，所以有$\phi(p^k)$=$p*\phi(p^{k-1})$=$p*p^{k-2}*(p-1)$</p>
<h1 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h1><p>根据唯一分解定理，n=$p_1^{k_1}p_2^{k_2}p_3^{k_3}…p_s^{k_s}$,然后可以根据积性函数的性质有n=$\phi(p_1^{k_1})\phi(p_2^{k_2})\phi(p_3^{k_3}…$<br>然后带入性质4可得$\phi(n)$=$n*\prod_{i=1}^s{\frac{p_i-1}{p_i}}$<br>然后就可以根据这条性质去求了——</p>
<ul>
<li>只求一个或者几个<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i*i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p%i) <span class="keyword">continue</span>;</span><br><span class="line">        ans = ans/i*(i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(p%i==<span class="number">0</span>) p/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p&gt;<span class="number">1</span>) ans = ans/p*(p<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线性筛法<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> E[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++) E[i] = <span class="number">0</span>;</span><br><span class="line">    E[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!E[i])&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&lt;=maxn;j+=i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!E[j])E[j] = j;</span><br><span class="line">            E[j]=E[j]/i*(i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些反演性质"><a href="#一些反演性质" class="headerlink" title="一些反演性质"></a>一些反演性质</h1></li>
<li>n = $\sum_{d|n}^n\phi(d)$</li>
<li>$\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)==1]$=$2(\sum_{i=1}^n\phi(i))-1$<br><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4804" target="_blank" rel="noopener"><strong>BZOJ4804 欧拉心算</strong></a><br>求$\sum_{x=1}^n\sum_{y=1}^n/phi(gcd(x,y))$<br>原式=$\sum_{d=1}^n\phi(d)\sum_{x=1}^{n \over d}\sum_{y=1}^{n \over d} [gcd(x,y)==1]$=$\sum_{d=1}^n\phi(d)(2(\sum_{i=1}^{n \over d}\phi(i))-1)$<br>然后做一个前缀和预处理和整除分块就OJBK了</li>
<li>分块部分<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>;l&lt;=N;l++)&#123;</span><br><span class="line">         <span class="keyword">long</span> <span class="keyword">long</span> r = N/(N/l);</span><br><span class="line">         <span class="comment">//do something (块的左端点是N/l,右端点是r)</span></span><br><span class="line">         l = r;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
<li>Code<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> E[<span class="number">10000010</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> maxn = <span class="number">10000000</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++) E[i] = <span class="number">0</span>;</span><br><span class="line">    E[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;=maxn;j+=i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (E[j]==<span class="number">0</span>) E[j] = j;</span><br><span class="line">            E[j] = E[j]/i*(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    init();</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++) sum[i] = sum[i<span class="number">-1</span>]+E[i];</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>;l&lt;=N;l++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> r = N/(N/l);</span><br><span class="line">            ans2+=(sum[r]-sum[l<span class="number">-1</span>])*(<span class="number">2</span>*sum[N/l]<span class="number">-1</span>);</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1>若gcd(a,m)=1,$a^{\phi(m)} \equiv 1\pmod m$ <h1 id="拓展欧拉定理"><a href="#拓展欧拉定理" class="headerlink" title="拓展欧拉定理"></a>拓展欧拉定理</h1><img src="/2020/01/13/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/拓展欧拉函数.jpg" alt="拓展欧拉函数"><br><a href="https://www.luogu.com.cn/problem/P5091" target="_blank" rel="noopener"><strong>洛谷模板 欧拉定理</strong></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b%a,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i*i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p%i) <span class="keyword">continue</span>;</span><br><span class="line">        ans = ans/i*(i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(p%i==<span class="number">0</span>) p/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p&gt;<span class="number">1</span>) ans = ans/p*(p<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,m,b;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> A,<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = A%m;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&amp;<span class="number">1</span>) ans=ans*temp%m;</span><br><span class="line">        temp = temp*temp%m;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a,&amp;m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ol = phi(m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">int</span> pp = <span class="number">0</span>;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;s[pp]!=<span class="string">'\0'</span>;pp++)</span><br><span class="line">    &#123;</span><br><span class="line">        b = b*<span class="number">10</span>+(s[pp]-<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span> (b&gt;=ol) flag = <span class="literal">true</span>;</span><br><span class="line">        b%=ol;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gcd(a,m)==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mi(a,b%ol)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="built_in">cout</span>&lt;&lt;mi(a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;mi(a,b%ol+ol)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher算法总结</title>
    <url>/2020/01/12/Manacher%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>O(n)复杂度计算一个字符串的回文子串的算法<br><a id="more"></a></p>
<h1 id="具体来说"><a href="#具体来说" class="headerlink" title="具体来说"></a>具体来说</h1><p>对于计算一个字符串的回文子串，暴力算法显然就是枚举每一个字符作为回文中心点，暴力去寻找他的边界，复杂度是O($n^2$)的。所以Manacher算法是极为优秀的，只不过适用范围有点小（大概）。具体实现的话这样做——</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul>
<li>在每两个字符之间插入一个不会出现的字符，如’#’或’$’,使得所有偶长度回文串都变为奇长度的</li>
<li>定义p[i]为第i个字符的回文半径，mx为已经处理过的回文串能达到的最远的位置，id为对应最远回文子串的回文中心，j为当前正在处理的回文中心的关于id的对称点;<br><img src="/2020/01/12/Manacher%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/A.png" alt="AA"><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2>当扫到第i个的时候，对其对称点j为回文中心的回文子串进行判断，</li>
<li>如果该回文串包含在id回文串的内部，则p[i]=p[j];</li>
<li>如果该回文串超出了id回文串，则以i为中心的回文串的右边界显然不会超过mx,所以有p[i]=mx-i;</li>
<li>如果该回文子串的左边界与id串的左边界刚好重合，则不确定后面是否还有可以继续匹配的串，这时候继续从mx向后暴力匹配，并更新mx和id即可。<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>Poj3974 回文串板子题<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">" "</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">3000010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3000010</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">3000100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ss);</span><br><span class="line">        <span class="keyword">if</span> (ss[<span class="number">0</span>]==<span class="string">'E'</span>&amp;&amp;ss[<span class="number">1</span>]==<span class="string">'N'</span>&amp;&amp;ss[<span class="number">2</span>]==<span class="string">'D'</span>&amp;&amp;ss[<span class="number">3</span>]==<span class="string">'\0'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ss);</span><br><span class="line">        s[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            s[<span class="number">2</span>*i+<span class="number">1</span>] = ss[i];</span><br><span class="line">            s[<span class="number">2</span>*i+<span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[<span class="number">2</span>*len+<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;len&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            p[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=mx) &#123;</span><br><span class="line">                id = i;</span><br><span class="line">                <span class="keyword">while</span>(id-p[i]&gt;=<span class="number">0</span>&amp;&amp;id+p[i]&lt;len&amp;&amp;s[id+p[i]]==s[id-p[i]])p[i]++;</span><br><span class="line">                p[i]--;</span><br><span class="line">                mx = id+p[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = id*<span class="number">2</span>-i;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">2</span>*id-mx;</span><br><span class="line">            <span class="comment">// debug(i);debug(j);debug(id);debug(l);debug(mx);cout&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;id&lt;&lt;" "&lt;&lt;l&lt;&lt;" "&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span> (j-p[j]==l)&#123;</span><br><span class="line">                  p[i] = p[j];</span><br><span class="line">                id = i;</span><br><span class="line">                <span class="keyword">while</span>(id-p[i]&gt;=<span class="number">0</span>&amp;&amp;id+p[i]&lt;len&amp;&amp;s[id+p[i]]==s[id-p[i]]) p[i]++;</span><br><span class="line">                p[i]--;</span><br><span class="line">                mx = id+p[i];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (j-p[j]&gt;l) p[i] = p[j];</span><br><span class="line">            <span class="keyword">else</span>  p[i] = mx-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) </span><br><span class="line">            <span class="keyword">if</span> (p[i]&gt;ans) &#123;</span><br><span class="line">                ans = p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;cnt&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>AtcoderDwangoProgrammingContest6th</title>
    <url>/2020/01/12/AtcoderDwangoProgrammingContest6th/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>模拟题。。。看懂了就会做了，略<br><a id="more"></a></p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>~A都不知道怎么A的~</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>n个史莱姆排列在一条水平轴上(保证位置不同)，然后进行n-1次操作：</p>
<ul>
<li>除了最后一个史莱姆之外的其他任何一个史莱姆</li>
<li>将选中的史莱姆移动到他的右边一个史莱姆上</li>
<li>将该史莱姆与这个史莱姆合并<br>显然进行n-1次操作后会只剩下一个史莱姆，然后求所有选择顺序情况下(可以理解选择顺序是一个全排列)所有史莱姆移动距离的和，膜1e9+7.<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2>考虑计算每一段路需要计算的次数，那么显然对于第i段路，之后这段路之前的史莱姆可以贡献答案；然后再分别考虑每个史莱姆：</li>
<li>第i个史莱姆必然能贡献一次答案，贡献次数为(n-1)!</li>
<li>第i-1个史莱姆如果要走过第i段路，那么第i个史莱姆必定在他的前面，而在所有的选择顺序全排列里有一半的情况是第i个史莱姆选在第i-1个之前的，所以贡献次数是(n-1)!/2</li>
<li>第i-2个史莱姆如果要走过第i段路，那么第i,第i-1个史莱姆也应在他前面，而这种情况应该有1/3的情况会出现，即我们不考虑除了i,i-1,i-2之外的元素，只考虑这三个元素的排列情况，那么i-2在第三个位置的情况必然是1/3个总次数，所以贡献次数应该是(n-1)!/3</li>
<li>之后的情况以此类推，第i-j个(i-j>=1)史莱姆对第i段路的贡献次数应该是(n-1)!/j<br>然后综合一下——<br>$\sum_{i=1}^{n-1}dis_i\sum_{j=1}^i(n-1)!/j$<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mi[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">m</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = x;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = mod<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt&amp;<span class="number">1</span>) ans=ans*temp%mod;</span><br><span class="line">        temp = temp*temp%mod;</span><br><span class="line">        cnt&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N);</span><br><span class="line">    mi[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=N;i++) mi[i] = mi[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp = mi[N<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> anss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tt = A[i]-A[i<span class="number">-1</span>];</span><br><span class="line">        t+=temp*m(i<span class="number">-1</span>);</span><br><span class="line">        t%=mod;</span><br><span class="line">        anss+=tt*t;</span><br><span class="line">        anss%=mod;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;anss&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces613(div2)</title>
    <url>/2020/01/11/Codeforces613-div2/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>签到题，输入n输出n+1.<br><a id="more"></a></p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个序列A,问是否有一个除了[1,n]的一个子区间使得其区间和比[1,n]的区间和要大或者相等，如果存在，则输出<strong>NO</strong>,否则输出<strong>YES</strong></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>显然直接去求它的最大区间和就好了，然后去判断这个最大区间是不是[1,n],即可输出答案。求最大区间，可以考虑先进行一遍前缀和预处理，然后对于每一个右端点r,右端点为r的区间的最大值就是sum[l-1]最小的时候的l,然后O(n)扫一遍就能都搞定了~然而连肝五个小时脑子都瓦特了，wa了五发QAQ~</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sans = <span class="number">-1e15</span>,ansl=<span class="number">0</span>,ansr=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> minl=<span class="number">1</span>,minn = <span class="number">1e11</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=n;r++)&#123; </span><br><span class="line">            <span class="keyword">if</span> (minn&gt;=sum[r<span class="number">-1</span>]) &#123;minn = sum[r<span class="number">-1</span>];minl = r;&#125;</span><br><span class="line">            <span class="keyword">if</span> (sans&lt;sum[r]-sum[minl<span class="number">-1</span>])&#123;</span><br><span class="line">                sans = sum[r]-sum[minl<span class="number">-1</span>];</span><br><span class="line">                ansl = minl;ansr = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ansl!=<span class="number">1</span>||ansr!=n) <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>求max(a,b)最小的a,b , 使得LCM(a,b) = X(X为输入值)</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>考虑，如果a,b不是互质的话，即gcd(a,b) = c(c&gt;0),那么应该存在LCM(a/c,b)=LCM(a,b)，或者LCM(a,b/c)=LCM(a,b),总之互质的a,b,总是可以得到最优答案的，具体怎么严谨得证还有待研究。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b%a,a);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/gcd(a,b)*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i,<span class="keyword">long</span> <span class="keyword">long</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;j) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> X;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;X);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> xx = <span class="built_in">sqrt</span>(X);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ansi=<span class="number">1</span>,ansj=X,anss = X;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=xx;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (X%i!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> j = X/i;</span><br><span class="line">        <span class="keyword">if</span> (gcd(i,j)==<span class="number">1</span>)&#123;   </span><br><span class="line">            <span class="keyword">if</span> (anss&gt; <span class="built_in">max</span> (i,j))&#123;</span><br><span class="line">                ansi = i;ansj = j;</span><br><span class="line">                anss = <span class="built_in">max</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ansi&lt;&lt;<span class="string">" "</span>&lt;&lt;ansj&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一组数A,设计一个数X,使得max(ai XOR X)的值最小。</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>建立一课01树(trie树)，在树上做dp。</p>
<ul>
<li>如果该节点只有一个儿子或者没有儿子，那么显然这个位置可以抵消掉变成0。</li>
<li>如果这个节点有两个儿子，那么不论怎么变，这一位都一定是1，对应的值就是&amp;2^i&amp;的形式<br>最后dp解决即可<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2>写的有点乱，有些没用的东西懒得删了……<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> dep;</span><br><span class="line">&#125;N[<span class="number">3100010</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>,anss = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">3100010</span>]; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    N[x].dep=dep;</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]!=<span class="number">-1</span>) dfs(N[x].ch[<span class="number">0</span>],dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">1</span>]!=<span class="number">-1</span>) dfs(N[x].ch[<span class="number">1</span>],dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]!=<span class="number">-1</span>&amp;&amp;N[x].ch[<span class="number">1</span>]!=<span class="number">-1</span>) dp[x] = <span class="built_in">min</span>(dp[x],<span class="built_in">min</span>(dp[N[x].ch[<span class="number">0</span>]],dp[N[x].ch[<span class="number">1</span>]])+(<span class="number">1</span>&lt;&lt;(len-dep)));</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]==<span class="number">-1</span>&amp;&amp;N[x].ch[<span class="number">1</span>]!=<span class="number">-1</span>) dp[x] = <span class="built_in">min</span>(dp[x],dp[N[x].ch[<span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]!=<span class="number">-1</span>&amp;&amp;N[x].ch[<span class="number">1</span>]==<span class="number">-1</span>) dp[x] = <span class="built_in">min</span>(dp[x],dp[N[x].ch[<span class="number">0</span>]]);</span><br><span class="line">    <span class="keyword">if</span> (N[x].ch[<span class="number">0</span>]==<span class="number">-1</span>&amp;&amp;N[x].ch[<span class="number">1</span>]==<span class="number">-1</span>) dp[x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[i]);</span><br><span class="line">        maxx = <span class="built_in">max</span>(maxx,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(maxx)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        maxx&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len--;</span><br><span class="line">    <span class="keyword">int</span> st=<span class="number">0</span>;</span><br><span class="line">    N[<span class="number">0</span>].<span class="built_in">size</span> = <span class="number">2</span>;</span><br><span class="line">    N[<span class="number">0</span>].col = <span class="number">0</span>;</span><br><span class="line">    N[<span class="number">0</span>].ch[<span class="number">1</span>] = N[<span class="number">0</span>].ch[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        st = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=len;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = (A[i]&gt;&gt;j)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (N[st].ch[x]==<span class="number">-1</span>)&#123;</span><br><span class="line">                N[st].ch[x]= ++cnt;</span><br><span class="line">                N[cnt].col = x;</span><br><span class="line">                N[cnt].ch[<span class="number">1</span>] = N[cnt].ch[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">                N[cnt].<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st = N[st].ch[x];</span><br><span class="line">            N[st].<span class="built_in">size</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;i++) dp[i] = (<span class="number">1</span>&lt;&lt;(len+<span class="number">1</span>))<span class="number">-1</span>;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoderBeginnerContest150</title>
    <url>/2020/01/11/AtCoderBeginnerContest150/</url>
    <content><![CDATA[<h1 id="zycdltxdy-喊破嗓子"><a href="#zycdltxdy-喊破嗓子" class="headerlink" title="zycdltxdy!!!!(喊破嗓子)"></a>zycdltxdy!!!!(喊破嗓子)</h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><a id="more"></a>
<p>签到题1，K*500>=X输出 <strong>YES</strong> ,K*500\&lt;X输出 <strong>NO</strong>.</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>签到题2，给一个长度为N的字符串S,问里面有几个子串‘ABC’,暴力匹配即可.</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定N,给定两个全排列P和Q,记他们在所有长度为N的字符典序的排序为a和b,求|a-b|</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>全排列的排列顺序有点类似进制数，在第i位上，Ai是第j个未出现的数字的话，那么该位的贡献就是(j-1)*(i-1)!(i是从左向右扫)。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> mi[<span class="number">10</span>],vis[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> anss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) vis[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        vis[A[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=A[i];j++) temp+=vis[j];</span><br><span class="line">        anss+=temp*mi[N-i];</span><br><span class="line">    &#125;</span><br><span class="line">    anss++;</span><br><span class="line">    <span class="keyword">return</span> anss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N);</span><br><span class="line">    mi[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) mi[i] = mi[i<span class="number">-1</span>]*i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    ans1 = solve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    ans2 = solve();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">abs</span>(ans1-ans2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一组长度为n的偶数数列A，求在0~M范围内有多少X满足：</p>
<ul>
<li>对于数列中的每一个数ai,存在一个非负整数p,使得X=ai*(p+0.5).<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2>由条件可知，对于任意一个ai(1&lt;=i&lt;=n),X是ai/2的奇数倍.<br>所以有：</li>
<li>X是所有数的最小公倍数的倍数</li>
<li>设所有数列的最小公倍数是Xmin,不能存在Xmin是ai/2的偶数倍，以为这样Xmin的所有倍数X都必然是ai/2的偶数倍<br>所以答案特别判断一下条件2,在条件2中的情况不处现时，答案就是M里Xmin的奇数倍数的个数<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd( b % a , a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        ret++;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> N,M;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) A[i]/=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> tt = f(A[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tt!=f(A[i]))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> gcdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        gcdd = gcd(ans,A[i]);</span><br><span class="line">        ans = ans/gcdd; </span><br><span class="line">        ans*=A[i];</span><br><span class="line">        <span class="keyword">if</span> (ans&gt;M) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> anss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans&lt;=M)&#123;</span><br><span class="line">        M-=ans;</span><br><span class="line">        anss++;</span><br><span class="line">        <span class="keyword">if</span> (ans&gt;<span class="number">0</span>) anss+=M/(ans*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;anss&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ZYCDLTXDY"><a href="#ZYCDLTXDY" class="headerlink" title="ZYCDLTXDY!!!"></a>ZYCDLTXDY!!!</h1></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>set用法详解(雾)</title>
    <url>/2020/01/07/set%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%9B%BE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>set是一种基于红黑树的数据结构模板，其支持插入，删除，查找等操作。<br><a id="more"></a></p>
<ul>
<li>set中的元素是排序好的，默认从小到大</li>
<li>set中没有重复元素，multiset中可以有重复元素</li>
<li>set大部分的操作的复杂度都是log级别的<h1 id="set的常用用法"><a href="#set的常用用法" class="headerlink" title="set的常用用法"></a>set的常用用法</h1></li>
<li>begin()             返回set的第一个元素的迭代器</li>
<li>end()               返回set的最后一个元素的下一个位置的迭代器</li>
<li>clear()             删除set中所有的元素</li>
<li>empty()             判断set是否为空</li>
<li>size()              返回set中的元素个数</li>
<li>count(key_value)    返回对应元素的个数</li>
<li>erase(iterator)     删除迭代器iterator指向的值</li>
<li>erase(first,second) 删除迭代器first和second之间的值</li>
<li>erase(key_value)    删除key_value的值(erase返回值为删除的值的个数)</li>
<li>find(key_value)     返回对应值的迭代器，没有则返回end()</li>
<li>insert(key_value)   将key_value插入set，返回值是pair<set<int>::iterator,                            bool&gt;  bool是插入成功与否，iterator是插入的位置</set<int></li>
<li>insert(first,second)将定位器first与second之间的元素插入set</li>
<li>lower_bound(key_value)  返回第一个大于等于key_value的值的迭代器</li>
<li>upper_bound(key_value)  返回第一个大于key_value的值的迭代器<h1 id="改变set内部排序的方法"><a href="#改变set内部排序的方法" class="headerlink" title="改变set内部排序的方法"></a>改变set内部排序的方法</h1></li>
<li>自定义排序函数：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">camp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> struct Node &amp;a,<span class="keyword">const</span> struct Node &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------</span><br><span class="line">    <span class="built_in">set</span>&lt;struct Node,camp&gt; ss;</span><br></pre></td></tr></table></figure></li>
<li>重载结构体比较函数(&lt;)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&gt;a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeforcesHello2020</title>
    <url>/2020/01/04/CodeforcesHello2020/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><a id="more"></a>
<p>给出两组字符串，用类似天干地支纪年法的方法对应名字与年号，问某一年的名字是什么。<br><img src="/2020/01/04/CodeforcesHello2020/2345_image_file_copy_1.jpg" alt="A2"><br><img src="/2020/01/04/CodeforcesHello2020/1578154373(1" alt="A1">.jpg)</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>显然前缀名和后缀名的滚动是相互独立的，两边分别取膜即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>][<span class="number">20</span>],t[<span class="number">100</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,t[i]);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> nn = (x<span class="number">-1</span>)%n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mm = (x<span class="number">-1</span>)%m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s[nn]);i++)</span><br><span class="line">        <span class="built_in">putchar</span>(s[nn][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(t[mm]);i++)</span><br><span class="line">        <span class="built_in">putchar</span>(t[mm][i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出n组数组，随意连接任意两组数组(保持顺序不变，首尾相接)，一共有n^2种连接方法，如果一对数组中满足下述条件,则符合条件<strong>ascent</strong>:<br><img src="/2020/01/04/CodeforcesHello2020/1578154904(1" alt="B2">.jpg)<br>求符合条件的方案数。</p>
<p><img src="/2020/01/04/CodeforcesHello2020/1578155613(1" alt="B1">.jpg)</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>首先考虑，某一数组内部如果已经满足条件，那么与他连接的所有方案都满足，方案数贡献为<strong>2*(n-1)+1</strong>,然后会发现这么算会有重复，所以记temp为已经计算过的内部满足条件的数组数量，则每一个内部满足条件的数组贡献记为<strong>2*(n-temp-1)+1</strong>.</p>
<p>之后我们再考虑内部不满足条件的：对于每一个数组，记录其最大值与最小值。显然，所有最大值比本数组最小值大的数组，连接在本数组的后边一定可以贡献答案。于是我们可以扫一遍，将每组数组的最大值记录在树状数组里，再扫一遍总和答案即可。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mintr[<span class="number">1000100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chamin</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=<span class="number">1000010</span>)&#123;</span><br><span class="line">        mintr[x]++;</span><br><span class="line">        x+= (x&amp;(-x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;"OK"&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">querymin</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ans += mintr[x];</span><br><span class="line">        x-=x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxx,minn;</span><br><span class="line">&#125;A[<span class="number">100110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("aaa.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">memset</span>(mintr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mintr));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>,cnt=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,l;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;l);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tt;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> maxx=<span class="number">0</span>,minn = <span class="number">1000010</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=l;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tt);</span><br><span class="line">            tt++;</span><br><span class="line">            <span class="keyword">if</span> (tt&gt;minn&amp;&amp;minn!=<span class="number">0</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            maxx = <span class="built_in">max</span>(maxx,tt);</span><br><span class="line">            minn = <span class="built_in">min</span>(minn,tt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;ans+=<span class="number">2</span>*(n<span class="number">-1</span>-temp)+<span class="number">1</span>;temp++;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            chamin(minn);</span><br><span class="line">            A[++cnt].maxx = maxx;A[cnt].minn = minn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        ans+=querymin(A[i].maxx<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个规模n,求长度为n的所有全排列中，有多少个子序列，满足该子序列的最大值与最小值只差等于长度-1：<br><img src="/2020/01/04/CodeforcesHello2020/1578156001(1" alt="C1">.jpg)</p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>数学题……~要不是打表失败了我才不会去刚他QAQ~答案就是排列组合，上过高中的都会————<br><img src="/2020/01/04/CodeforcesHello2020/gongshi1.png" alt="C2"></p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mi[<span class="number">250100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    mi[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++) mi[i] = (mi[i<span class="number">-1</span>]*i)%m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=(((i*mi[n-i+<span class="number">1</span>])%m)*mi[i])%m;</span><br><span class="line">        ans%=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出n个数据，每个数据包含两个区间段(暂且叫他们A区间与B区间)，要求任意两个数据的对应区间段，要么都重合要么都不重合，问是否符合条件，符合输出<strong>“YES”</strong>,不符输出<strong>“NO”</strong></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>N2两两判断是不可能过的，所以考虑优化。<br>首先以A的开始与结束时间作为事件发生的时间：</p>
<ul>
<li>在sa时向set插入sb与eb</li>
<li>在ea+1时消除sb与eb<br>这样只要在插入的时候查询，是否当前要插入的开始时间比所有set里的结束时间都早，是否当前要插入的结束时间比所有set里的开始时间都晚，即必须保证插入区间与set内的所有区间都冲突，才是合法的。<br>之后同理再处理一遍B区间对A区间的情况即可，复杂度nlogn.<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sa,ea,sb,eb;</span><br><span class="line">&#125;A[<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> loc,id;</span><br><span class="line">    <span class="keyword">int</span> se;</span><br><span class="line">    <span class="comment">// bool operator &lt; (const Node2&amp; b2) const&#123;</span></span><br><span class="line">    <span class="comment">//     if (loc!=b2.loc) return loc&lt;b2.loc;</span></span><br><span class="line">    <span class="comment">//     return se&lt;b2.se;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;B[<span class="number">300100</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">camp</span><span class="params">(struct Node2 a,struct Node2 b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.loc==b.loc) <span class="keyword">return</span> a.se&lt;b.se;</span><br><span class="line">    <span class="keyword">return</span> a.loc&lt;b.loc;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; l;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> &gt; r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"aaa.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;A[i].sa,&amp;A[i].ea,&amp;A[i].sb,&amp;A[i].eb);</span><br><span class="line">        B[<span class="number">2</span>*i].loc = A[i].sa;B[<span class="number">2</span>*i].id = i;B[<span class="number">2</span>*i].se = <span class="number">1</span>;</span><br><span class="line">        B[<span class="number">2</span>*i+<span class="number">1</span>].loc = A[i].ea+<span class="number">1</span>;B[<span class="number">2</span>*i+<span class="number">1</span>].id = i;B[<span class="number">2</span>*i+<span class="number">1</span>].se = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(B,B+n*<span class="number">2</span>,camp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i].se==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!l.empty()&amp;&amp;!r.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span> (A[B[i].id].sb&gt;*r.<span class="built_in">begin</span>()||A[B[i].id].eb&lt;*l.<span class="built_in">begin</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            l.insert(A[B[i].id].sb);</span><br><span class="line">            r.insert(A[B[i].id].eb);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l.erase(l.<span class="built_in">find</span>(A[B[i].id].sb));</span><br><span class="line">            r.erase(r.<span class="built_in">find</span>(A[B[i].id].eb));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        B[<span class="number">2</span>*i].loc = A[i].sb;B[<span class="number">2</span>*i].id = i;B[<span class="number">2</span>*i].se = <span class="number">1</span>;</span><br><span class="line">        B[<span class="number">2</span>*i+<span class="number">1</span>].loc = A[i].eb+<span class="number">1</span>;B[<span class="number">2</span>*i+<span class="number">1</span>].id = i;B[<span class="number">2</span>*i+<span class="number">1</span>].se = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(B,B+n*<span class="number">2</span>,camp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i].se)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!l.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span> ((A[B[i].id].sa&gt;*r.<span class="built_in">begin</span>())||(A[B[i].id].ea&lt;*l.<span class="built_in">begin</span>()))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            l.insert(A[B[i].id].sa);</span><br><span class="line">            r.insert(A[B[i].id].ea);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l.erase(l.<span class="built_in">find</span>(A[B[i].id].sa));</span><br><span class="line">            r.erase(r.<span class="built_in">find</span>(A[B[i].id].ea));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>QAQAQ</title>
    <url>/2020/01/03/QAQAQ/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>内容</p>
<a id="more"></a>
<h1 id="一级标题2"><a href="#一级标题2" class="headerlink" title="一级标题2"></a>一级标题2</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul>
<li>列表1</li>
<li><p>列表2<br>  a 子列表<br>  b 子列表</p>
<hr>
<p>  普通字体</p>
<hr>
</li>
</ul>
<p><a href="sldjfl">超链接</a></p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1578657044&amp;di=e8d4f6cc7319c7b39a1c997b29aa2c81&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2Fc7c8b4a1780dc0cc40b7bd22cc52f180abf7254d1ee1c-jgx2yP_fw658" alt="QAQ"></p>
<p><em>斜体</em></p>
<p><strong>粗体</strong><br><code>单行代码块</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多行</span><br><span class="line">代码</span><br><span class="line">块</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>引用的</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
